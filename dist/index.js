module.exports =
    /******/ (function (modules, runtime) { // webpackBootstrap
    /******/
    "use strict";
    /******/ 	// The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ 		// Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ 		// Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/            i: moduleId,
            /******/            l: false,
            /******/            exports: {}
            /******/
        };
        /******/
        /******/ 		// Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ 		// Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ 		// Return the exports of the module
        /******/
        return module.exports;
        /******/
    }

    /******/
    /******/
    /******/
    __webpack_require__.ab = __dirname + "/";
    /******/
    /******/ 	// the startup function
    /******/
    function startup() {
        /******/ 		// Load entry module and return exports
        /******/
        return __webpack_require__(410);
        /******/
    };
    /******/
    /******/ 	// run startup
    /******/
    return startup();
    /******/
})
    /************************************************************************/
    /******/ ([
        /* 0 */,
        /* 1 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.Command = void 0;
            const middleware_stack_1 = __webpack_require__(519);

            class Command {
                constructor() {
                    this.middlewareStack = (0, middleware_stack_1.constructStack)();
                }
            }

            exports.Command = Command;


            /***/
        }),
        /* 2 */,
        /* 3 */,
        /* 4 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.TRANSIENT_ERROR_STATUS_CODES = exports.TRANSIENT_ERROR_CODES = exports.THROTTLING_ERROR_CODES = exports.CLOCK_SKEW_ERROR_CODES = void 0;
            exports.CLOCK_SKEW_ERROR_CODES = [
                "AuthFailure",
                "InvalidSignatureException",
                "RequestExpired",
                "RequestInTheFuture",
                "RequestTimeTooSkewed",
                "SignatureDoesNotMatch",
            ];
            exports.THROTTLING_ERROR_CODES = [
                "BandwidthLimitExceeded",
                "EC2ThrottledException",
                "LimitExceededException",
                "PriorRequestNotComplete",
                "ProvisionedThroughputExceededException",
                "RequestLimitExceeded",
                "RequestThrottled",
                "RequestThrottledException",
                "SlowDown",
                "ThrottledException",
                "Throttling",
                "ThrottlingException",
                "TooManyRequestsException",
                "TransactionInProgressException",
            ];
            exports.TRANSIENT_ERROR_CODES = ["AbortError", "TimeoutError", "RequestTimeout", "RequestTimeoutException"];
            exports.TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];


            /***/
        }),
        /* 5 */,
        /* 6 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ReorderReceiptRuleSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ReorderReceiptRuleSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ReorderReceiptRuleSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ReorderReceiptRuleSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ReorderReceiptRuleSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryReorderReceiptRuleSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryReorderReceiptRuleSetCommand)(output, context);
                }
            }

            exports.ReorderReceiptRuleSetCommand = ReorderReceiptRuleSetCommand;


            /***/
        }),
        /* 7 */,
        /* 8 */,
        /* 9 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.VerifyDomainDkimCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class VerifyDomainDkimCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "VerifyDomainDkimCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.VerifyDomainDkimRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.VerifyDomainDkimResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryVerifyDomainDkimCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryVerifyDomainDkimCommand)(output, context);
                }
            }

            exports.VerifyDomainDkimCommand = VerifyDomainDkimCommand;


            /***/
        }),
        /* 10 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SendBulkTemplatedEmailCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SendBulkTemplatedEmailCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SendBulkTemplatedEmailCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SendBulkTemplatedEmailRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SendBulkTemplatedEmailResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySendBulkTemplatedEmailCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySendBulkTemplatedEmailCommand)(output, context);
                }
            }

            exports.SendBulkTemplatedEmailCommand = SendBulkTemplatedEmailCommand;


            /***/
        }),
        /* 11 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.deserializerMiddleware = void 0;
            const deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
                const {response} = await next(args);
                try {
                    const parsed = await deserializer(response, options);
                    return {
                        response,
                        output: parsed,
                    };
                } catch (error) {
                    Object.defineProperty(error, "$response", {
                        value: response,
                    });
                    throw error;
                }
            };
            exports.deserializerMiddleware = deserializerMiddleware;


            /***/
        }),
        /* 12 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const shared = __webpack_require__(190);
            const MimeNode = __webpack_require__(652);
            const mimeFuncs = __webpack_require__(103);

            class MailMessage {
                constructor(mailer, data) {
                    this.mailer = mailer;
                    this.data = {};
                    this.message = null;

                    data = data || {};
                    let options = mailer.options || {};
                    let defaults = mailer._defaults || {};

                    Object.keys(data).forEach(key => {
                        this.data[key] = data[key];
                    });

                    this.data.headers = this.data.headers || {};

                    // apply defaults
                    Object.keys(defaults).forEach(key => {
                        if (!(key in this.data)) {
                            this.data[key] = defaults[key];
                        } else if (key === 'headers') {
                            // headers is a special case. Allow setting individual default headers
                            Object.keys(defaults.headers).forEach(key => {
                                if (!(key in this.data.headers)) {
                                    this.data.headers[key] = defaults.headers[key];
                                }
                            });
                        }
                    });

                    // force specific keys from transporter options
                    ['disableFileAccess', 'disableUrlAccess', 'normalizeHeaderKey'].forEach(key => {
                        if (key in options) {
                            this.data[key] = options[key];
                        }
                    });
                }

                resolveContent(...args) {
                    return shared.resolveContent(...args);
                }

                resolveAll(callback) {
                    let keys = [
                        [this.data, 'html'],
                        [this.data, 'text'],
                        [this.data, 'watchHtml'],
                        [this.data, 'amp'],
                        [this.data, 'icalEvent']
                    ];

                    if (this.data.alternatives && this.data.alternatives.length) {
                        this.data.alternatives.forEach((alternative, i) => {
                            keys.push([this.data.alternatives, i]);
                        });
                    }

                    if (this.data.attachments && this.data.attachments.length) {
                        this.data.attachments.forEach((attachment, i) => {
                            if (!attachment.filename) {
                                attachment.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);
                                if (attachment.filename.indexOf('.') < 0) {
                                    attachment.filename += '.' + mimeFuncs.detectExtension(attachment.contentType);
                                }
                            }

                            if (!attachment.contentType) {
                                attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin');
                            }

                            keys.push([this.data.attachments, i]);
                        });
                    }

                    let mimeNode = new MimeNode();

                    let addressKeys = ['from', 'to', 'cc', 'bcc', 'sender', 'replyTo'];

                    addressKeys.forEach(address => {
                        let value;
                        if (this.message) {
                            value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === 'replyTo' ? 'reply-to' : address)) || []);
                        } else if (this.data[address]) {
                            value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);
                        }
                        if (value && value.length) {
                            this.data[address] = value;
                        } else if (address in this.data) {
                            this.data[address] = null;
                        }
                    });

                    let singleKeys = ['from', 'sender', 'replyTo'];
                    singleKeys.forEach(address => {
                        if (this.data[address]) {
                            this.data[address] = this.data[address].shift();
                        }
                    });

                    let pos = 0;
                    let resolveNext = () => {
                        if (pos >= keys.length) {
                            return callback(null, this.data);
                        }
                        let args = keys[pos++];
                        if (!args[0] || !args[0][args[1]]) {
                            return resolveNext();
                        }
                        shared.resolveContent(...args, (err, value) => {
                            if (err) {
                                return callback(err);
                            }

                            let node = {
                                content: value
                            };
                            if (args[0][args[1]] && typeof args[0][args[1]] === 'object' && !Buffer.isBuffer(args[0][args[1]])) {
                                Object.keys(args[0][args[1]]).forEach(key => {
                                    if (!(key in node) && !['content', 'path', 'href', 'raw'].includes(key)) {
                                        node[key] = args[0][args[1]][key];
                                    }
                                });
                            }

                            args[0][args[1]] = node;
                            resolveNext();
                        });
                    };

                    setImmediate(() => resolveNext());
                }

                normalize(callback) {
                    let envelope = this.data.envelope || this.message.getEnvelope();
                    let messageId = this.message.messageId();

                    this.resolveAll((err, data) => {
                        if (err) {
                            return callback(err);
                        }

                        data.envelope = envelope;
                        data.messageId = messageId;

                        ['html', 'text', 'watchHtml', 'amp'].forEach(key => {
                            if (data[key] && data[key].content) {
                                if (typeof data[key].content === 'string') {
                                    data[key] = data[key].content;
                                } else if (Buffer.isBuffer(data[key].content)) {
                                    data[key] = data[key].content.toString();
                                }
                            }
                        });

                        if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
                            data.icalEvent.content = data.icalEvent.content.toString('base64');
                            data.icalEvent.encoding = 'base64';
                        }

                        if (data.alternatives && data.alternatives.length) {
                            data.alternatives.forEach(alternative => {
                                if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
                                    alternative.content = alternative.content.toString('base64');
                                    alternative.encoding = 'base64';
                                }
                            });
                        }

                        if (data.attachments && data.attachments.length) {
                            data.attachments.forEach(attachment => {
                                if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
                                    attachment.content = attachment.content.toString('base64');
                                    attachment.encoding = 'base64';
                                }
                            });
                        }

                        data.normalizedHeaders = {};
                        Object.keys(data.headers || {}).forEach(key => {
                            let value = [].concat(data.headers[key] || []).shift();
                            value = (value && value.value) || value;
                            if (value) {
                                if (['references', 'in-reply-to', 'message-id', 'content-id'].includes(key)) {
                                    value = this.message._encodeHeaderValue(key, value);
                                }
                                data.normalizedHeaders[key] = value;
                            }
                        });

                        if (data.list && typeof data.list === 'object') {
                            let listHeaders = this._getListHeaders(data.list);
                            listHeaders.forEach(entry => {
                                data.normalizedHeaders[entry.key] = entry.value.map(val => (val && val.value) || val).join(', ');
                            });
                        }

                        if (data.references) {
                            data.normalizedHeaders.references = this.message._encodeHeaderValue('references', data.references);
                        }

                        if (data.inReplyTo) {
                            data.normalizedHeaders['in-reply-to'] = this.message._encodeHeaderValue('in-reply-to', data.inReplyTo);
                        }

                        return callback(null, data);
                    });
                }

                setMailerHeader() {
                    if (!this.message || !this.data.xMailer) {
                        return;
                    }
                    this.message.setHeader('X-Mailer', this.data.xMailer);
                }

                setPriorityHeaders() {
                    if (!this.message || !this.data.priority) {
                        return;
                    }
                    switch ((this.data.priority || '').toString().toLowerCase()) {
                        case 'high':
                            this.message.setHeader('X-Priority', '1 (Highest)');
                            this.message.setHeader('X-MSMail-Priority', 'High');
                            this.message.setHeader('Importance', 'High');
                            break;
                        case 'low':
                            this.message.setHeader('X-Priority', '5 (Lowest)');
                            this.message.setHeader('X-MSMail-Priority', 'Low');
                            this.message.setHeader('Importance', 'Low');
                            break;
                        default:
                        // do not add anything, since all messages are 'Normal' by default
                    }
                }

                setListHeaders() {
                    if (!this.message || !this.data.list || typeof this.data.list !== 'object') {
                        return;
                    }
                    // add optional List-* headers
                    if (this.data.list && typeof this.data.list === 'object') {
                        this._getListHeaders(this.data.list).forEach(listHeader => {
                            listHeader.value.forEach(value => {
                                this.message.addHeader(listHeader.key, value);
                            });
                        });
                    }
                }

                _getListHeaders(listData) {
                    // make sure an url looks like <protocol:url>
                    return Object.keys(listData).map(key => ({
                        key: 'list-' + key.toLowerCase().trim(),
                        value: [].concat(listData[key] || []).map(value => ({
                            prepared: true,
                            foldLines: true,
                            value: []
                                .concat(value || [])
                                .map(value => {
                                    if (typeof value === 'string') {
                                        value = {
                                            url: value
                                        };
                                    }

                                    if (value && value.url) {
                                        if (key.toLowerCase().trim() === 'id') {
                                            // List-ID: "comment" <domain>
                                            let comment = value.comment || '';
                                            if (mimeFuncs.isPlainText(comment)) {
                                                comment = '"' + comment + '"';
                                            } else {
                                                comment = mimeFuncs.encodeWord(comment);
                                            }

                                            return (value.comment ? comment + ' ' : '') + this._formatListUrl(value.url).replace(/^<[^:]+\/{,2}/, '');
                                        }

                                        // List-*: <http://domain> (comment)
                                        let comment = value.comment || '';
                                        if (!mimeFuncs.isPlainText(comment)) {
                                            comment = mimeFuncs.encodeWord(comment);
                                        }

                                        return this._formatListUrl(value.url) + (value.comment ? ' (' + comment + ')' : '');
                                    }

                                    return '';
                                })
                                .filter(value => value)
                                .join(', ')
                        }))
                    }));
                }

                _formatListUrl(url) {
                    url = url.replace(/[\s<]+|[\s>]+/g, '');
                    if (/^(https?|mailto|ftp):/.test(url)) {
                        return '<' + url + '>';
                    }
                    if (/^[^@]+@[^@]+$/.test(url)) {
                        return '<mailto:' + url + '>';
                    }

                    return '<http://' + url + '>';
                }
            }

            module.exports = MailMessage;


            /***/
        }),
        /* 13 */,
        /* 14 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

// We use any as a valid input type
            /* eslint-disable @typescript-eslint/no-explicit-any */
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.toCommandProperties = exports.toCommandValue = void 0;

            /**
             * Sanitizes an input into a string so it can be passed into issueCommand safely
             * @param input input to sanitize into a string
             */
            function toCommandValue(input) {
                if (input === null || input === undefined) {
                    return '';
                } else if (typeof input === 'string' || input instanceof String) {
                    return input;
                }
                return JSON.stringify(input);
            }

            exports.toCommandValue = toCommandValue;

            /**
             *
             * @param annotationProperties
             * @returns The command properties to send with the actual annotation command
             * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
             */
            function toCommandProperties(annotationProperties) {
                if (!Object.keys(annotationProperties).length) {
                    return {};
                }
                return {
                    title: annotationProperties.title,
                    file: annotationProperties.file,
                    line: annotationProperties.startLine,
                    endLine: annotationProperties.endLine,
                    col: annotationProperties.startColumn,
                    endColumn: annotationProperties.endColumn
                };
            }

            exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

            /***/
        }),
        /* 15 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getResolvedPartition = void 0;
            const getResolvedPartition = (region, {partitionHash}) => {
                var _a;
                return (_a = Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region))) !== null && _a !== void 0 ? _a : "aws";
            };
            exports.getResolvedPartition = getResolvedPartition;


            /***/
        }),
        /* 16 */
        /***/ (function (module) {

            module.exports = require("tls");

            /***/
        }),
        /* 17 */,
        /* 18 */,
        /* 19 */,
        /* 20 */,
        /* 21 */,
        /* 22 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(736), exports);
            tslib_1.__exportStar(__webpack_require__(768), exports);


            /***/
        }),
        /* 23 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);

                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);

                    if (enumerableOnly) {
                        symbols = symbols.filter(function (sym) {
                            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                        });
                    }

                    keys.push.apply(keys, symbols);
                }

                return keys;
            }

            function _objectSpread2(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};

                    if (i % 2) {
                        ownKeys(Object(source), true).forEach(function (key) {
                            _defineProperty(target, key, source[key]);
                        });
                    } else if (Object.getOwnPropertyDescriptors) {
                        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                    } else {
                        ownKeys(Object(source)).forEach(function (key) {
                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                        });
                    }
                }

                return target;
            }

            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }

                return obj;
            }

            const Endpoints = {
                actions: {
                    addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
                    approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
                    cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
                    createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
                    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
                    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
                    createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
                    createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
                    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
                    createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
                    createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
                    deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
                    deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
                    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
                    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
                    deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
                    deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
                    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
                    deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
                    disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
                    disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
                    downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
                    downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
                    downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
                    downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
                    enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
                    enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
                    getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
                    getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
                    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
                    getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
                    getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
                    getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
                    getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
                    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
                    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
                    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
                    getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
                    getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, {
                        renamed: ["actions", "getGithubActionsPermissionsRepository"]
                    }],
                    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
                    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
                    getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
                    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
                    getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
                    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
                    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
                    getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
                    getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
                    getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
                    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
                    listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
                    listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
                    listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
                    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
                    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
                    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
                    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
                    listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
                    listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
                    listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
                    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
                    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
                    listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
                    listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
                    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
                    removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
                    reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
                    setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
                    setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
                    setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
                    setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
                    setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
                    setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"]
                },
                activity: {
                    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
                    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
                    deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
                    getFeeds: ["GET /feeds"],
                    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
                    getThread: ["GET /notifications/threads/{thread_id}"],
                    getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
                    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
                    listNotificationsForAuthenticatedUser: ["GET /notifications"],
                    listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
                    listPublicEvents: ["GET /events"],
                    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
                    listPublicEventsForUser: ["GET /users/{username}/events/public"],
                    listPublicOrgEvents: ["GET /orgs/{org}/events"],
                    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
                    listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
                    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
                    listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
                    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
                    listReposStarredByUser: ["GET /users/{username}/starred"],
                    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
                    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
                    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
                    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
                    markNotificationsAsRead: ["PUT /notifications"],
                    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
                    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
                    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
                    setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
                    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
                    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
                },
                apps: {
                    addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}", {}, {
                        renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"]
                    }],
                    addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
                    checkToken: ["POST /applications/{client_id}/token"],
                    createContentAttachment: ["POST /content_references/{content_reference_id}/attachments", {
                        mediaType: {
                            previews: ["corsair"]
                        }
                    }],
                    createContentAttachmentForRepo: ["POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments", {
                        mediaType: {
                            previews: ["corsair"]
                        }
                    }],
                    createFromManifest: ["POST /app-manifests/{code}/conversions"],
                    createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
                    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
                    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
                    deleteToken: ["DELETE /applications/{client_id}/token"],
                    getAuthenticated: ["GET /app"],
                    getBySlug: ["GET /apps/{app_slug}"],
                    getInstallation: ["GET /app/installations/{installation_id}"],
                    getOrgInstallation: ["GET /orgs/{org}/installation"],
                    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
                    getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
                    getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
                    getUserInstallation: ["GET /users/{username}/installation"],
                    getWebhookConfigForApp: ["GET /app/hook/config"],
                    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
                    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
                    listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
                    listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
                    listInstallations: ["GET /app/installations"],
                    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
                    listPlans: ["GET /marketplace_listing/plans"],
                    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
                    listReposAccessibleToInstallation: ["GET /installation/repositories"],
                    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
                    listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
                    listWebhookDeliveries: ["GET /app/hook/deliveries"],
                    redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
                    removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}", {}, {
                        renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"]
                    }],
                    removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
                    resetToken: ["PATCH /applications/{client_id}/token"],
                    revokeInstallationAccessToken: ["DELETE /installation/token"],
                    scopeToken: ["POST /applications/{client_id}/token/scoped"],
                    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
                    unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
                    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
                },
                billing: {
                    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
                    getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
                    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
                    getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
                    getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
                    getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
                },
                checks: {
                    create: ["POST /repos/{owner}/{repo}/check-runs"],
                    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
                    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
                    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
                    listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
                    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
                    listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
                    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
                    rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
                    rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
                    setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
                    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
                },
                codeScanning: {
                    deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
                    getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
                        renamedParameters: {
                            alert_id: "alert_number"
                        }
                    }],
                    getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
                    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
                    listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
                    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
                    listAlertsInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", {}, {
                        renamed: ["codeScanning", "listAlertInstances"]
                    }],
                    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
                    updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
                    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
                },
                codesOfConduct: {
                    getAllCodesOfConduct: ["GET /codes_of_conduct"],
                    getConductCode: ["GET /codes_of_conduct/{key}"]
                },
                emojis: {
                    get: ["GET /emojis"]
                },
                enterpriseAdmin: {
                    disableSelectedOrganizationGithubActionsEnterprise: ["DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
                    enableSelectedOrganizationGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
                    getAllowedActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/selected-actions"],
                    getGithubActionsPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions"],
                    listSelectedOrganizationsEnabledGithubActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/organizations"],
                    setAllowedActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/selected-actions"],
                    setGithubActionsPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions"],
                    setSelectedOrganizationsEnabledGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations"]
                },
                gists: {
                    checkIsStarred: ["GET /gists/{gist_id}/star"],
                    create: ["POST /gists"],
                    createComment: ["POST /gists/{gist_id}/comments"],
                    delete: ["DELETE /gists/{gist_id}"],
                    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
                    fork: ["POST /gists/{gist_id}/forks"],
                    get: ["GET /gists/{gist_id}"],
                    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
                    getRevision: ["GET /gists/{gist_id}/{sha}"],
                    list: ["GET /gists"],
                    listComments: ["GET /gists/{gist_id}/comments"],
                    listCommits: ["GET /gists/{gist_id}/commits"],
                    listForUser: ["GET /users/{username}/gists"],
                    listForks: ["GET /gists/{gist_id}/forks"],
                    listPublic: ["GET /gists/public"],
                    listStarred: ["GET /gists/starred"],
                    star: ["PUT /gists/{gist_id}/star"],
                    unstar: ["DELETE /gists/{gist_id}/star"],
                    update: ["PATCH /gists/{gist_id}"],
                    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
                },
                git: {
                    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
                    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
                    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
                    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
                    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
                    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
                    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
                    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
                    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
                    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
                    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
                    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
                    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
                },
                gitignore: {
                    getAllTemplates: ["GET /gitignore/templates"],
                    getTemplate: ["GET /gitignore/templates/{name}"]
                },
                interactions: {
                    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
                    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
                    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
                    getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, {
                        renamed: ["interactions", "getRestrictionsForAuthenticatedUser"]
                    }],
                    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
                    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
                    removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
                    removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, {
                        renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"]
                    }],
                    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
                    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
                    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
                    setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, {
                        renamed: ["interactions", "setRestrictionsForAuthenticatedUser"]
                    }]
                },
                issues: {
                    addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
                    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
                    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
                    create: ["POST /repos/{owner}/{repo}/issues"],
                    createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
                    createLabel: ["POST /repos/{owner}/{repo}/labels"],
                    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
                    deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
                    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
                    deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
                    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
                    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
                    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
                    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
                    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
                    list: ["GET /issues"],
                    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
                    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
                    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
                    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
                    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
                    listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
                    listForAuthenticatedUser: ["GET /user/issues"],
                    listForOrg: ["GET /orgs/{org}/issues"],
                    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
                    listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
                    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
                    listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
                    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
                    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
                    removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
                    removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
                    removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
                    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
                    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
                    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
                    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
                    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
                    updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
                },
                licenses: {
                    get: ["GET /licenses/{license}"],
                    getAllCommonlyUsed: ["GET /licenses"],
                    getForRepo: ["GET /repos/{owner}/{repo}/license"]
                },
                markdown: {
                    render: ["POST /markdown"],
                    renderRaw: ["POST /markdown/raw", {
                        headers: {
                            "content-type": "text/plain; charset=utf-8"
                        }
                    }]
                },
                meta: {
                    get: ["GET /meta"],
                    getOctocat: ["GET /octocat"],
                    getZen: ["GET /zen"],
                    root: ["GET /"]
                },
                migrations: {
                    cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
                    deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
                    deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
                    downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
                    getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
                    getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
                    getImportStatus: ["GET /repos/{owner}/{repo}/import"],
                    getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
                    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
                    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
                    listForAuthenticatedUser: ["GET /user/migrations"],
                    listForOrg: ["GET /orgs/{org}/migrations"],
                    listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
                    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
                    listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {}, {
                        renamed: ["migrations", "listReposForAuthenticatedUser"]
                    }],
                    mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
                    setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
                    startForAuthenticatedUser: ["POST /user/migrations"],
                    startForOrg: ["POST /orgs/{org}/migrations"],
                    startImport: ["PUT /repos/{owner}/{repo}/import"],
                    unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
                    unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
                    updateImport: ["PATCH /repos/{owner}/{repo}/import"]
                },
                orgs: {
                    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
                    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
                    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
                    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
                    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
                    convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
                    createInvitation: ["POST /orgs/{org}/invitations"],
                    createWebhook: ["POST /orgs/{org}/hooks"],
                    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
                    get: ["GET /orgs/{org}"],
                    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
                    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
                    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
                    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
                    getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
                    list: ["GET /organizations"],
                    listAppInstallations: ["GET /orgs/{org}/installations"],
                    listBlockedUsers: ["GET /orgs/{org}/blocks"],
                    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
                    listForAuthenticatedUser: ["GET /user/orgs"],
                    listForUser: ["GET /users/{username}/orgs"],
                    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
                    listMembers: ["GET /orgs/{org}/members"],
                    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
                    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
                    listPendingInvitations: ["GET /orgs/{org}/invitations"],
                    listPublicMembers: ["GET /orgs/{org}/public_members"],
                    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
                    listWebhooks: ["GET /orgs/{org}/hooks"],
                    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
                    redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
                    removeMember: ["DELETE /orgs/{org}/members/{username}"],
                    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
                    removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
                    removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
                    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
                    setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
                    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
                    update: ["PATCH /orgs/{org}"],
                    updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
                    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
                    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
                },
                packages: {
                    deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
                    deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
                    deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
                    deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    getAllPackageVersionsForAPackageOwnedByAnOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions", {}, {
                        renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"]
                    }],
                    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions", {}, {
                        renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"]
                    }],
                    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
                    getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
                    getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
                    getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
                    getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
                    getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
                    getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
                    listPackagesForAuthenticatedUser: ["GET /user/packages"],
                    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
                    listPackagesForUser: ["GET /users/{username}/packages"],
                    restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
                    restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
                    restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
                    restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
                    restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
                    restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
                },
                projects: {
                    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
                    createCard: ["POST /projects/columns/{column_id}/cards"],
                    createColumn: ["POST /projects/{project_id}/columns"],
                    createForAuthenticatedUser: ["POST /user/projects"],
                    createForOrg: ["POST /orgs/{org}/projects"],
                    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
                    delete: ["DELETE /projects/{project_id}"],
                    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
                    deleteColumn: ["DELETE /projects/columns/{column_id}"],
                    get: ["GET /projects/{project_id}"],
                    getCard: ["GET /projects/columns/cards/{card_id}"],
                    getColumn: ["GET /projects/columns/{column_id}"],
                    getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
                    listCards: ["GET /projects/columns/{column_id}/cards"],
                    listCollaborators: ["GET /projects/{project_id}/collaborators"],
                    listColumns: ["GET /projects/{project_id}/columns"],
                    listForOrg: ["GET /orgs/{org}/projects"],
                    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
                    listForUser: ["GET /users/{username}/projects"],
                    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
                    moveColumn: ["POST /projects/columns/{column_id}/moves"],
                    removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
                    update: ["PATCH /projects/{project_id}"],
                    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
                    updateColumn: ["PATCH /projects/columns/{column_id}"]
                },
                pulls: {
                    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
                    create: ["POST /repos/{owner}/{repo}/pulls"],
                    createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
                    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
                    createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
                    deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
                    deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
                    dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
                    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
                    getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
                    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
                    list: ["GET /repos/{owner}/{repo}/pulls"],
                    listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
                    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
                    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
                    listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
                    listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
                    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
                    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
                    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
                    removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
                    requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
                    submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
                    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
                    updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
                    updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
                    updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
                },
                rateLimit: {
                    get: ["GET /rate_limit"]
                },
                reactions: {
                    createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
                    createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
                    createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
                    createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
                    createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
                    createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
                    createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
                    deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
                    deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
                    deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
                    deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
                    deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
                    deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
                    listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
                    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
                    listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
                    listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
                    listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
                    listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
                },
                repos: {
                    acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}", {}, {
                        renamed: ["repos", "acceptInvitationForAuthenticatedUser"]
                    }],
                    acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
                    addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
                        mapToData: "apps"
                    }],
                    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
                    addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
                        mapToData: "contexts"
                    }],
                    addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
                        mapToData: "teams"
                    }],
                    addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
                        mapToData: "users"
                    }],
                    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
                    checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
                    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
                    compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
                    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
                    createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
                    createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
                    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
                    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
                    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
                    createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
                    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
                    createForAuthenticatedUser: ["POST /user/repos"],
                    createFork: ["POST /repos/{owner}/{repo}/forks"],
                    createInOrg: ["POST /orgs/{org}/repos"],
                    createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
                    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
                    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
                    createRelease: ["POST /repos/{owner}/{repo}/releases"],
                    createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
                    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
                    declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}", {}, {
                        renamed: ["repos", "declineInvitationForAuthenticatedUser"]
                    }],
                    declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
                    delete: ["DELETE /repos/{owner}/{repo}"],
                    deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
                    deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
                    deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
                    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
                    deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
                    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
                    deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
                    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
                    deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
                    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
                    deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
                    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
                    deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
                    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
                    deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
                    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
                    disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
                    disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
                    disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
                    downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, {
                        renamed: ["repos", "downloadZipballArchive"]
                    }],
                    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
                    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
                    enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
                    enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
                    enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
                    generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
                    get: ["GET /repos/{owner}/{repo}"],
                    getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
                    getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
                    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
                    getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
                    getAllTopics: ["GET /repos/{owner}/{repo}/topics", {
                        mediaType: {
                            previews: ["mercy"]
                        }
                    }],
                    getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
                    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
                    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
                    getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
                    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
                    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
                    getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
                    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
                    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
                    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
                    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
                    getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
                    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
                    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
                    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
                    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
                    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
                    getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
                    getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
                    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
                    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
                    getPages: ["GET /repos/{owner}/{repo}/pages"],
                    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
                    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
                    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
                    getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
                    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
                    getReadme: ["GET /repos/{owner}/{repo}/readme"],
                    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
                    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
                    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
                    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
                    getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
                    getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
                    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
                    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
                    getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
                    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
                    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
                    getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
                    getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
                    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
                    listBranches: ["GET /repos/{owner}/{repo}/branches"],
                    listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
                    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
                    listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
                    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
                    listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
                    listCommits: ["GET /repos/{owner}/{repo}/commits"],
                    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
                    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
                    listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
                    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
                    listForAuthenticatedUser: ["GET /user/repos"],
                    listForOrg: ["GET /orgs/{org}/repos"],
                    listForUser: ["GET /users/{username}/repos"],
                    listForks: ["GET /repos/{owner}/{repo}/forks"],
                    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
                    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
                    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
                    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
                    listPublic: ["GET /repositories"],
                    listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
                    listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
                    listReleases: ["GET /repos/{owner}/{repo}/releases"],
                    listTags: ["GET /repos/{owner}/{repo}/tags"],
                    listTeams: ["GET /repos/{owner}/{repo}/teams"],
                    listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
                    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
                    merge: ["POST /repos/{owner}/{repo}/merges"],
                    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
                    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
                    redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
                    removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
                        mapToData: "apps"
                    }],
                    removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
                    removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
                        mapToData: "contexts"
                    }],
                    removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
                    removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
                        mapToData: "teams"
                    }],
                    removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
                        mapToData: "users"
                    }],
                    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
                    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics", {
                        mediaType: {
                            previews: ["mercy"]
                        }
                    }],
                    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
                    setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
                    setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
                        mapToData: "apps"
                    }],
                    setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
                        mapToData: "contexts"
                    }],
                    setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
                        mapToData: "teams"
                    }],
                    setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
                        mapToData: "users"
                    }],
                    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
                    transfer: ["POST /repos/{owner}/{repo}/transfer"],
                    update: ["PATCH /repos/{owner}/{repo}"],
                    updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
                    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
                    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
                    updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
                    updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
                    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
                    updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
                    updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks", {}, {
                        renamed: ["repos", "updateStatusCheckProtection"]
                    }],
                    updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
                    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
                    updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
                    uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
                        baseUrl: "https://uploads.github.com"
                    }]
                },
                search: {
                    code: ["GET /search/code"],
                    commits: ["GET /search/commits"],
                    issuesAndPullRequests: ["GET /search/issues"],
                    labels: ["GET /search/labels"],
                    repos: ["GET /search/repositories"],
                    topics: ["GET /search/topics", {
                        mediaType: {
                            previews: ["mercy"]
                        }
                    }],
                    users: ["GET /search/users"]
                },
                secretScanning: {
                    getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
                    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
                    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
                    updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
                },
                teams: {
                    addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
                    addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
                    addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
                    checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
                    checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
                    create: ["POST /orgs/{org}/teams"],
                    createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
                    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
                    deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
                    deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
                    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
                    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
                    getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
                    getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
                    getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
                    list: ["GET /orgs/{org}/teams"],
                    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
                    listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
                    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
                    listForAuthenticatedUser: ["GET /user/teams"],
                    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
                    listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
                    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
                    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
                    removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
                    removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
                    removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
                    updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
                    updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
                    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
                },
                users: {
                    addEmailForAuthenticated: ["POST /user/emails", {}, {
                        renamed: ["users", "addEmailForAuthenticatedUser"]
                    }],
                    addEmailForAuthenticatedUser: ["POST /user/emails"],
                    block: ["PUT /user/blocks/{username}"],
                    checkBlocked: ["GET /user/blocks/{username}"],
                    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
                    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
                    createGpgKeyForAuthenticated: ["POST /user/gpg_keys", {}, {
                        renamed: ["users", "createGpgKeyForAuthenticatedUser"]
                    }],
                    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
                    createPublicSshKeyForAuthenticated: ["POST /user/keys", {}, {
                        renamed: ["users", "createPublicSshKeyForAuthenticatedUser"]
                    }],
                    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
                    deleteEmailForAuthenticated: ["DELETE /user/emails", {}, {
                        renamed: ["users", "deleteEmailForAuthenticatedUser"]
                    }],
                    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
                    deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}", {}, {
                        renamed: ["users", "deleteGpgKeyForAuthenticatedUser"]
                    }],
                    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
                    deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}", {}, {
                        renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"]
                    }],
                    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
                    follow: ["PUT /user/following/{username}"],
                    getAuthenticated: ["GET /user"],
                    getByUsername: ["GET /users/{username}"],
                    getContextForUser: ["GET /users/{username}/hovercard"],
                    getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}", {}, {
                        renamed: ["users", "getGpgKeyForAuthenticatedUser"]
                    }],
                    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
                    getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}", {}, {
                        renamed: ["users", "getPublicSshKeyForAuthenticatedUser"]
                    }],
                    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
                    list: ["GET /users"],
                    listBlockedByAuthenticated: ["GET /user/blocks", {}, {
                        renamed: ["users", "listBlockedByAuthenticatedUser"]
                    }],
                    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
                    listEmailsForAuthenticated: ["GET /user/emails", {}, {
                        renamed: ["users", "listEmailsForAuthenticatedUser"]
                    }],
                    listEmailsForAuthenticatedUser: ["GET /user/emails"],
                    listFollowedByAuthenticated: ["GET /user/following", {}, {
                        renamed: ["users", "listFollowedByAuthenticatedUser"]
                    }],
                    listFollowedByAuthenticatedUser: ["GET /user/following"],
                    listFollowersForAuthenticatedUser: ["GET /user/followers"],
                    listFollowersForUser: ["GET /users/{username}/followers"],
                    listFollowingForUser: ["GET /users/{username}/following"],
                    listGpgKeysForAuthenticated: ["GET /user/gpg_keys", {}, {
                        renamed: ["users", "listGpgKeysForAuthenticatedUser"]
                    }],
                    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
                    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
                    listPublicEmailsForAuthenticated: ["GET /user/public_emails", {}, {
                        renamed: ["users", "listPublicEmailsForAuthenticatedUser"]
                    }],
                    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
                    listPublicKeysForUser: ["GET /users/{username}/keys"],
                    listPublicSshKeysForAuthenticated: ["GET /user/keys", {}, {
                        renamed: ["users", "listPublicSshKeysForAuthenticatedUser"]
                    }],
                    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
                    setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility", {}, {
                        renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"]
                    }],
                    setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
                    unblock: ["DELETE /user/blocks/{username}"],
                    unfollow: ["DELETE /user/following/{username}"],
                    updateAuthenticated: ["PATCH /user"]
                }
            };

            const VERSION = "5.13.0";

            function endpointsToMethods(octokit, endpointsMap) {
                const newMethods = {};

                for (const [scope, endpoints] of Object.entries(endpointsMap)) {
                    for (const [methodName, endpoint] of Object.entries(endpoints)) {
                        const [route, defaults, decorations] = endpoint;
                        const [method, url] = route.split(/ /);
                        const endpointDefaults = Object.assign({
                            method,
                            url
                        }, defaults);

                        if (!newMethods[scope]) {
                            newMethods[scope] = {};
                        }

                        const scopeMethods = newMethods[scope];

                        if (decorations) {
                            scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
                            continue;
                        }

                        scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
                    }
                }

                return newMethods;
            }

            function decorate(octokit, scope, methodName, defaults, decorations) {
                const requestWithDefaults = octokit.request.defaults(defaults);

                /* istanbul ignore next */

                function withDecorations(...args) {
                    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
                    let options = requestWithDefaults.endpoint.merge(...args); // There are currently no other decorations than `.mapToData`

                    if (decorations.mapToData) {
                        options = Object.assign({}, options, {
                            data: options[decorations.mapToData],
                            [decorations.mapToData]: undefined
                        });
                        return requestWithDefaults(options);
                    }

                    if (decorations.renamed) {
                        const [newScope, newMethodName] = decorations.renamed;
                        octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
                    }

                    if (decorations.deprecated) {
                        octokit.log.warn(decorations.deprecated);
                    }

                    if (decorations.renamedParameters) {
                        // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
                        const options = requestWithDefaults.endpoint.merge(...args);

                        for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
                            if (name in options) {
                                octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);

                                if (!(alias in options)) {
                                    options[alias] = options[name];
                                }

                                delete options[name];
                            }
                        }

                        return requestWithDefaults(options);
                    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488


                    return requestWithDefaults(...args);
                }

                return Object.assign(withDecorations, requestWithDefaults);
            }

            function restEndpointMethods(octokit) {
                const api = endpointsToMethods(octokit, Endpoints);
                return {
                    rest: api
                };
            }

            restEndpointMethods.VERSION = VERSION;

            function legacyRestEndpointMethods(octokit) {
                const api = endpointsToMethods(octokit, Endpoints);
                return _objectSpread2(_objectSpread2({}, api), {}, {
                    rest: api
                });
            }

            legacyRestEndpointMethods.VERSION = VERSION;

            exports.legacyRestEndpointMethods = legacyRestEndpointMethods;
            exports.restEndpointMethods = restEndpointMethods;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 24 */,
        /* 25 */,
        /* 26 */,
        /* 27 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.NodeHttp2Handler = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const querystring_builder_1 = __webpack_require__(242);
            const http2_1 = __webpack_require__(565);
            const get_transformed_headers_1 = __webpack_require__(797);
            const write_request_body_1 = __webpack_require__(367);

            class NodeHttp2Handler {
                constructor({requestTimeout, sessionTimeout, disableConcurrentStreams} = {}) {
                    this.metadata = {handlerProtocol: "h2"};
                    this.requestTimeout = requestTimeout;
                    this.sessionTimeout = sessionTimeout;
                    this.disableConcurrentStreams = disableConcurrentStreams;
                    this.sessionCache = new Map();
                }

                destroy() {
                    for (const sessions of this.sessionCache.values()) {
                        sessions.forEach((session) => this.destroySession(session));
                    }
                    this.sessionCache.clear();
                }

                handle(request, {abortSignal} = {}) {
                    return new Promise((resolve, rejectOriginal) => {
                        let fulfilled = false;
                        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                            fulfilled = true;
                            const abortError = new Error("Request aborted");
                            abortError.name = "AbortError";
                            rejectOriginal(abortError);
                            return;
                        }
                        const {hostname, method, port, protocol, path, query} = request;
                        const authority = `${protocol}//${hostname}${port ? `:${port}` : ""}`;
                        const session = this.getSession(authority, this.disableConcurrentStreams || false);
                        const reject = (err) => {
                            if (this.disableConcurrentStreams) {
                                this.destroySession(session);
                            }
                            fulfilled = true;
                            rejectOriginal(err);
                        };
                        const queryString = (0, querystring_builder_1.buildQueryString)(query || {});
                        const req = session.request({
                            ...request.headers,
                            [http2_1.constants.HTTP2_HEADER_PATH]: queryString ? `${path}?${queryString}` : path,
                            [http2_1.constants.HTTP2_HEADER_METHOD]: method,
                        });
                        req.on("response", (headers) => {
                            const httpResponse = new protocol_http_1.HttpResponse({
                                statusCode: headers[":status"] || -1,
                                headers: (0, get_transformed_headers_1.getTransformedHeaders)(headers),
                                body: req,
                            });
                            fulfilled = true;
                            resolve({response: httpResponse});
                            if (this.disableConcurrentStreams) {
                                session.close();
                                this.deleteSessionFromCache(authority, session);
                            }
                        });
                        const requestTimeout = this.requestTimeout;
                        if (requestTimeout) {
                            req.setTimeout(requestTimeout, () => {
                                req.close();
                                const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                                timeoutError.name = "TimeoutError";
                                reject(timeoutError);
                            });
                        }
                        if (abortSignal) {
                            abortSignal.onabort = () => {
                                req.close();
                                const abortError = new Error("Request aborted");
                                abortError.name = "AbortError";
                                reject(abortError);
                            };
                        }
                        req.on("frameError", (type, code, id) => {
                            reject(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
                        });
                        req.on("error", reject);
                        req.on("aborted", () => {
                            reject(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
                        });
                        req.on("close", () => {
                            if (this.disableConcurrentStreams) {
                                session.destroy();
                            }
                            if (!fulfilled) {
                                reject(new Error("Unexpected error: http2 request did not get a response"));
                            }
                        });
                        (0, write_request_body_1.writeRequestBody)(req, request);
                    });
                }

                getSession(authority, disableConcurrentStreams) {
                    const sessionCache = this.sessionCache;
                    const existingSessions = sessionCache.get(authority) || [];
                    if (existingSessions.length > 0 && !disableConcurrentStreams)
                        return existingSessions[0];
                    const newSession = (0, http2_1.connect)(authority);
                    const destroySessionCb = () => {
                        this.destroySession(newSession);
                        this.deleteSessionFromCache(authority, newSession);
                    };
                    newSession.on("goaway", destroySessionCb);
                    newSession.on("error", destroySessionCb);
                    newSession.on("frameError", destroySessionCb);
                    const sessionTimeout = this.sessionTimeout;
                    if (sessionTimeout) {
                        newSession.setTimeout(sessionTimeout, destroySessionCb);
                    }
                    existingSessions.push(newSession);
                    sessionCache.set(authority, existingSessions);
                    return newSession;
                }

                destroySession(session) {
                    if (!session.destroyed) {
                        session.destroy();
                    }
                }

                deleteSessionFromCache(authority, session) {
                    const existingSessions = this.sessionCache.get(authority) || [];
                    if (!existingSessions.includes(session)) {
                        return;
                    }
                    this.sessionCache.set(authority, existingSessions.filter((s) => s !== session));
                }
            }

            exports.NodeHttp2Handler = NodeHttp2Handler;


            /***/
        }),
        /* 28 */,
        /* 29 */,
        /* 30 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _rng = _interopRequireDefault(__webpack_require__(819));

            var _stringify = _interopRequireDefault(__webpack_require__(993));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
            let _nodeId;

            let _clockseq; // Previous uuid creation time


            let _lastMSecs = 0;
            let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

            function v1(options, buf, offset) {
                let i = buf && offset || 0;
                const b = buf || new Array(16);
                options = options || {};
                let node = options.node || _nodeId;
                let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
                // specified.  We do this lazily to minimize issues related to insufficient
                // system entropy.  See #189

                if (node == null || clockseq == null) {
                    const seedBytes = options.random || (options.rng || _rng.default)();

                    if (node == null) {
                        // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
                        node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
                    }

                    if (clockseq == null) {
                        // Per 4.2.2, randomize (14 bit) clockseq
                        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
                    }
                } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
                // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
                // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
                // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


                let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
                // cycle to simulate higher resolution clock

                let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

                const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

                if (dt < 0 && options.clockseq === undefined) {
                    clockseq = clockseq + 1 & 0x3fff;
                } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
                // time interval


                if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
                    nsecs = 0;
                } // Per 4.2.1.2 Throw error if too many uuids are requested


                if (nsecs >= 10000) {
                    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                }

                _lastMSecs = msecs;
                _lastNSecs = nsecs;
                _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

                msecs += 12219292800000; // `time_low`

                const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
                b[i++] = tl >>> 24 & 0xff;
                b[i++] = tl >>> 16 & 0xff;
                b[i++] = tl >>> 8 & 0xff;
                b[i++] = tl & 0xff; // `time_mid`

                const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
                b[i++] = tmh >>> 8 & 0xff;
                b[i++] = tmh & 0xff; // `time_high_and_version`

                b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

                b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

                b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

                b[i++] = clockseq & 0xff; // `node`

                for (let n = 0; n < 6; ++n) {
                    b[i + n] = node[n];
                }

                return buf || (0, _stringify.default)(b);
            }

            var _default = v1;
            exports.default = _default;

            /***/
        }),
        /* 31 */,
        /* 32 */,
        /* 33 */,
        /* 34 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
            const AssumeRoleCommand_1 = __webpack_require__(942);
            const AssumeRoleWithWebIdentityCommand_1 = __webpack_require__(611);
            const ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
            const decorateDefaultRegion = (region) => {
                if (typeof region !== "function") {
                    return region === undefined ? ASSUME_ROLE_DEFAULT_REGION : region;
                }
                return async () => {
                    try {
                        return await region();
                    } catch (e) {
                        return ASSUME_ROLE_DEFAULT_REGION;
                    }
                };
            };
            const getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
                let stsClient;
                let closureSourceCreds;
                return async (sourceCreds, params) => {
                    closureSourceCreds = sourceCreds;
                    if (!stsClient) {
                        const {logger, region, requestHandler} = stsOptions;
                        stsClient = new stsClientCtor({
                            logger,
                            credentialDefaultProvider: () => async () => closureSourceCreds,
                            region: decorateDefaultRegion(region || stsOptions.region),
                            ...(requestHandler ? {requestHandler} : {}),
                        });
                    }
                    const {Credentials} = await stsClient.send(new AssumeRoleCommand_1.AssumeRoleCommand(params));
                    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
                        throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
                    }
                    return {
                        accessKeyId: Credentials.AccessKeyId,
                        secretAccessKey: Credentials.SecretAccessKey,
                        sessionToken: Credentials.SessionToken,
                        expiration: Credentials.Expiration,
                    };
                };
            };
            exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
            const getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
                let stsClient;
                return async (params) => {
                    if (!stsClient) {
                        const {logger, region, requestHandler} = stsOptions;
                        stsClient = new stsClientCtor({
                            logger,
                            region: decorateDefaultRegion(region || stsOptions.region),
                            ...(requestHandler ? {requestHandler} : {}),
                        });
                    }
                    const {Credentials} = await stsClient.send(new AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand(params));
                    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
                        throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
                    }
                    return {
                        accessKeyId: Credentials.AccessKeyId,
                        secretAccessKey: Credentials.SecretAccessKey,
                        sessionToken: Credentials.SessionToken,
                        expiration: Credentials.Expiration,
                    };
                };
            };
            exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
            const decorateDefaultCredentialProvider = (provider) => (input) => provider({
                roleAssumer: (0, exports.getDefaultRoleAssumer)(input, input.stsClientCtor),
                roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input, input.stsClientCtor),
                ...input,
            });
            exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


            /***/
        }),
        /* 35 */,
        /* 36 */,
        /* 37 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.STS = void 0;
            const AssumeRoleCommand_1 = __webpack_require__(942);
            const AssumeRoleWithSAMLCommand_1 = __webpack_require__(404);
            const AssumeRoleWithWebIdentityCommand_1 = __webpack_require__(611);
            const DecodeAuthorizationMessageCommand_1 = __webpack_require__(71);
            const GetAccessKeyInfoCommand_1 = __webpack_require__(934);
            const GetCallerIdentityCommand_1 = __webpack_require__(979);
            const GetFederationTokenCommand_1 = __webpack_require__(839);
            const GetSessionTokenCommand_1 = __webpack_require__(414);
            const STSClient_1 = __webpack_require__(687);

            class STS extends STSClient_1.STSClient {
                assumeRole(args, optionsOrCb, cb) {
                    const command = new AssumeRoleCommand_1.AssumeRoleCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                assumeRoleWithSAML(args, optionsOrCb, cb) {
                    const command = new AssumeRoleWithSAMLCommand_1.AssumeRoleWithSAMLCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                assumeRoleWithWebIdentity(args, optionsOrCb, cb) {
                    const command = new AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                decodeAuthorizationMessage(args, optionsOrCb, cb) {
                    const command = new DecodeAuthorizationMessageCommand_1.DecodeAuthorizationMessageCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getAccessKeyInfo(args, optionsOrCb, cb) {
                    const command = new GetAccessKeyInfoCommand_1.GetAccessKeyInfoCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getCallerIdentity(args, optionsOrCb, cb) {
                    const command = new GetCallerIdentityCommand_1.GetCallerIdentityCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getFederationToken(args, optionsOrCb, cb) {
                    const command = new GetFederationTokenCommand_1.GetFederationTokenCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getSessionToken(args, optionsOrCb, cb) {
                    const command = new GetSessionTokenCommand_1.GetSessionTokenCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }
            }

            exports.STS = STS;


            /***/
        }),
        /* 38 */,
        /* 39 */,
        /* 40 */,
        /* 41 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_FIPS_ENDPOINT = exports.CONFIG_USE_FIPS_ENDPOINT = exports.ENV_USE_FIPS_ENDPOINT = void 0;
            const util_config_provider_1 = __webpack_require__(361);
            exports.ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
            exports.CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
            exports.DEFAULT_USE_FIPS_ENDPOINT = false;
            exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
                environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.ENV),
                configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
                default: false,
            };


            /***/
        }),
        /* 42 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UpdateConfigurationSetSendingEnabledCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class UpdateConfigurationSetSendingEnabledCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "UpdateConfigurationSetSendingEnabledCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.UpdateConfigurationSetSendingEnabledRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryUpdateConfigurationSetSendingEnabledCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryUpdateConfigurationSetSendingEnabledCommand)(output, context);
                }
            }

            exports.UpdateConfigurationSetSendingEnabledCommand = UpdateConfigurationSetSendingEnabledCommand;


            /***/
        }),
        /* 43 */,
        /* 44 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            class Deprecation extends Error {
                constructor(message) {
                    super(message); // Maintains proper stack trace (only available on V8)

                    /* istanbul ignore next */

                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    }

                    this.name = 'Deprecation';
                }

            }

            exports.Deprecation = Deprecation;


            /***/
        }),
        /* 45 */,
        /* 46 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SendBounceCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SendBounceCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SendBounceCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SendBounceRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SendBounceResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySendBounceCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySendBounceCommand)(output, context);
                }
            }

            exports.SendBounceCommand = SendBounceCommand;


            /***/
        }),
        /* 47 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.IMDS_REGION_PATH = exports.DEFAULTS_MODE_OPTIONS = exports.ENV_IMDS_DISABLED = exports.AWS_DEFAULT_REGION_ENV = exports.AWS_REGION_ENV = exports.AWS_EXECUTION_ENV = void 0;
            exports.AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
            exports.AWS_REGION_ENV = "AWS_REGION";
            exports.AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
            exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
            exports.DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
            exports.IMDS_REGION_PATH = "/latest/meta-data/placement/region";


            /***/
        }),
        /* 48 */,
        /* 49 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            var universalUserAgent = __webpack_require__(922);
            var beforeAfterHook = __webpack_require__(595);
            var request = __webpack_require__(339);
            var graphql = __webpack_require__(911);
            var authToken = __webpack_require__(475);

            function _objectWithoutPropertiesLoose(source, excluded) {
                if (source == null) return {};
                var target = {};
                var sourceKeys = Object.keys(source);
                var key, i;

                for (i = 0; i < sourceKeys.length; i++) {
                    key = sourceKeys[i];
                    if (excluded.indexOf(key) >= 0) continue;
                    target[key] = source[key];
                }

                return target;
            }

            function _objectWithoutProperties(source, excluded) {
                if (source == null) return {};

                var target = _objectWithoutPropertiesLoose(source, excluded);

                var key, i;

                if (Object.getOwnPropertySymbols) {
                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

                    for (i = 0; i < sourceSymbolKeys.length; i++) {
                        key = sourceSymbolKeys[i];
                        if (excluded.indexOf(key) >= 0) continue;
                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
                        target[key] = source[key];
                    }
                }

                return target;
            }

            const VERSION = "3.6.0";

            const _excluded = ["authStrategy"];

            class Octokit {
                constructor(options = {}) {
                    const hook = new beforeAfterHook.Collection();
                    const requestDefaults = {
                        baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
                        headers: {},
                        request: Object.assign({}, options.request, {
                            // @ts-ignore internal usage only, no need to type
                            hook: hook.bind(null, "request")
                        }),
                        mediaType: {
                            previews: [],
                            format: ""
                        }
                    }; // prepend default user agent with `options.userAgent` if set

                    requestDefaults.headers["user-agent"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(" ");

                    if (options.baseUrl) {
                        requestDefaults.baseUrl = options.baseUrl;
                    }

                    if (options.previews) {
                        requestDefaults.mediaType.previews = options.previews;
                    }

                    if (options.timeZone) {
                        requestDefaults.headers["time-zone"] = options.timeZone;
                    }

                    this.request = request.request.defaults(requestDefaults);
                    this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);
                    this.log = Object.assign({
                        debug: () => {
                        },
                        info: () => {
                        },
                        warn: console.warn.bind(console),
                        error: console.error.bind(console)
                    }, options.log);
                    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
                    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
                    // (2) If only `options.auth` is set, use the default token authentication strategy.
                    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
                    // TODO: type `options.auth` based on `options.authStrategy`.

                    if (!options.authStrategy) {
                        if (!options.auth) {
                            // (1)
                            this.auth = async () => ({
                                type: "unauthenticated"
                            });
                        } else {
                            // (2)
                            const auth = authToken.createTokenAuth(options.auth); // @ts-ignore  \_()_/

                            hook.wrap("request", auth.hook);
                            this.auth = auth;
                        }
                    } else {
                        const {
                                authStrategy
                            } = options,
                            otherOptions = _objectWithoutProperties(options, _excluded);

                        const auth = authStrategy(Object.assign({
                            request: this.request,
                            log: this.log,
                            // we pass the current octokit instance as well as its constructor options
                            // to allow for authentication strategies that return a new octokit instance
                            // that shares the same internal state as the current one. The original
                            // requirement for this was the "event-octokit" authentication strategy
                            // of https://github.com/probot/octokit-auth-probot.
                            octokit: this,
                            octokitOptions: otherOptions
                        }, options.auth)); // @ts-ignore  \_()_/

                        hook.wrap("request", auth.hook);
                        this.auth = auth;
                    } // apply plugins
                    // https://stackoverflow.com/a/16345172


                    const classConstructor = this.constructor;
                    classConstructor.plugins.forEach(plugin => {
                        Object.assign(this, plugin(this, options));
                    });
                }

                static defaults(defaults) {
                    const OctokitWithDefaults = class extends this {
                        constructor(...args) {
                            const options = args[0] || {};

                            if (typeof defaults === "function") {
                                super(defaults(options));
                                return;
                            }

                            super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
                                userAgent: `${options.userAgent} ${defaults.userAgent}`
                            } : null));
                        }

                    };
                    return OctokitWithDefaults;
                }

                /**
                 * Attach a plugin (or many) to your Octokit instance.
                 *
                 * @example
                 * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
                 */


                static plugin(...newPlugins) {
                    var _a;

                    const currentPlugins = this.plugins;
                    const NewOctokit = (_a = class extends this {
                    }, _a.plugins = currentPlugins.concat(newPlugins.filter(plugin => !currentPlugins.includes(plugin))), _a);
                    return NewOctokit;
                }

            }

            Octokit.VERSION = VERSION;
            Octokit.plugins = [];

            exports.Octokit = Octokit;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 50 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromImdsCredentials = exports.isImdsCredentials = void 0;
            const isImdsCredentials = (arg) => Boolean(arg) &&
                typeof arg === "object" &&
                typeof arg.AccessKeyId === "string" &&
                typeof arg.SecretAccessKey === "string" &&
                typeof arg.Token === "string" &&
                typeof arg.Expiration === "string";
            exports.isImdsCredentials = isImdsCredentials;
            const fromImdsCredentials = (creds) => ({
                accessKeyId: creds.AccessKeyId,
                secretAccessKey: creds.SecretAccessKey,
                sessionToken: creds.Token,
                expiration: new Date(creds.Expiration),
            });
            exports.fromImdsCredentials = fromImdsCredentials;


            /***/
        }),
        /* 51 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _rng = _interopRequireDefault(__webpack_require__(819));

            var _stringify = _interopRequireDefault(__webpack_require__(993));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            function v4(options, buf, offset) {
                options = options || {};

                const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


                rnds[6] = rnds[6] & 0x0f | 0x40;
                rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

                if (buf) {
                    offset = offset || 0;

                    for (let i = 0; i < 16; ++i) {
                        buf[offset + i] = rnds[i];
                    }

                    return buf;
                }

                return (0, _stringify.default)(rnds);
            }

            var _default = v4;
            exports.default = _default;

            /***/
        }),
        /* 52 */
        /***/ (function (module) {

            module.exports = {
                "name": "@aws-sdk/client-sts",
                "description": "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
                "version": "3.56.0",
                "scripts": {
                    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
                    "build:cjs": "tsc -p tsconfig.cjs.json",
                    "build:docs": "typedoc",
                    "build:es": "tsc -p tsconfig.es.json",
                    "build:types": "tsc -p tsconfig.types.json",
                    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
                    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo"
                },
                "main": "./dist-cjs/index.js",
                "types": "./dist-types/index.d.ts",
                "module": "./dist-es/index.js",
                "sideEffects": false,
                "dependencies": {
                    "@aws-crypto/sha256-browser": "2.0.0",
                    "@aws-crypto/sha256-js": "2.0.0",
                    "@aws-sdk/config-resolver": "3.56.0",
                    "@aws-sdk/credential-provider-node": "3.56.0",
                    "@aws-sdk/fetch-http-handler": "3.55.0",
                    "@aws-sdk/hash-node": "3.55.0",
                    "@aws-sdk/invalid-dependency": "3.55.0",
                    "@aws-sdk/middleware-content-length": "3.55.0",
                    "@aws-sdk/middleware-host-header": "3.55.0",
                    "@aws-sdk/middleware-logger": "3.55.0",
                    "@aws-sdk/middleware-retry": "3.56.0",
                    "@aws-sdk/middleware-sdk-sts": "3.56.0",
                    "@aws-sdk/middleware-serde": "3.55.0",
                    "@aws-sdk/middleware-signing": "3.56.0",
                    "@aws-sdk/middleware-stack": "3.55.0",
                    "@aws-sdk/middleware-user-agent": "3.55.0",
                    "@aws-sdk/node-config-provider": "3.56.0",
                    "@aws-sdk/node-http-handler": "3.55.0",
                    "@aws-sdk/protocol-http": "3.55.0",
                    "@aws-sdk/smithy-client": "3.55.0",
                    "@aws-sdk/types": "3.55.0",
                    "@aws-sdk/url-parser": "3.55.0",
                    "@aws-sdk/util-base64-browser": "3.55.0",
                    "@aws-sdk/util-base64-node": "3.55.0",
                    "@aws-sdk/util-body-length-browser": "3.55.0",
                    "@aws-sdk/util-body-length-node": "3.55.0",
                    "@aws-sdk/util-defaults-mode-browser": "3.55.0",
                    "@aws-sdk/util-defaults-mode-node": "3.56.0",
                    "@aws-sdk/util-user-agent-browser": "3.55.0",
                    "@aws-sdk/util-user-agent-node": "3.56.0",
                    "@aws-sdk/util-utf8-browser": "3.55.0",
                    "@aws-sdk/util-utf8-node": "3.55.0",
                    "entities": "2.2.0",
                    "fast-xml-parser": "3.19.0",
                    "tslib": "^2.3.1"
                },
                "devDependencies": {
                    "@aws-sdk/service-client-documentation-generator": "3.55.0",
                    "@tsconfig/recommended": "1.0.1",
                    "@types/node": "^12.7.5",
                    "concurrently": "7.0.0",
                    "downlevel-dts": "0.7.0",
                    "rimraf": "3.0.2",
                    "typedoc": "0.19.2",
                    "typescript": "~4.6.2"
                },
                "engines": {"node": ">=12.0.0"},
                "typesVersions": {"<4.0": {"dist-types/*": ["dist-types/ts3.4/*"]}},
                "files": ["dist-*"],
                "author": {"name": "AWS SDK for JavaScript Team", "url": "https://aws.amazon.com/javascript/"},
                "license": "Apache-2.0",
                "browser": {"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"},
                "react-native": {"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"},
                "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
                "repository": {
                    "type": "git",
                    "url": "https://github.com/aws/aws-sdk-js-v3.git",
                    "directory": "clients/client-sts"
                }
            };

            /***/
        }),
        /* 53 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SENSITIVE_STRING = void 0;
            exports.SENSITIVE_STRING = "***SensitiveInformation***";


            /***/
        }),
        /* 54 */,
        /* 55 */,
        /* 56 */,
        /* 57 */,
        /* 58 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.isClockSkewed = void 0;
            const getSkewCorrectedDate_1 = __webpack_require__(217);
            const isClockSkewed = (clockTime, systemClockOffset) => Math.abs((0, getSkewCorrectedDate_1.getSkewCorrectedDate)(systemClockOffset).getTime() - clockTime) >= 300000;
            exports.isClockSkewed = isClockSkewed;


            /***/
        }),
        /* 59 */
        /***/ (function (module) {

            module.exports = require("assert");

            /***/
        }),
        /* 60 */,
        /* 61 */,
        /* 62 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListTemplatesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ListTemplatesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ListTemplatesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListTemplatesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListTemplatesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryListTemplatesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryListTemplatesCommand)(output, context);
                }
            }

            exports.ListTemplatesCommand = ListTemplatesCommand;


            /***/
        }),
        /* 63 */,
        /* 64 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.paginateListIdentities = void 0;
            const ListIdentitiesCommand_1 = __webpack_require__(843);
            const SES_1 = __webpack_require__(302);
            const SESClient_1 = __webpack_require__(522);
            const makePagedClientRequest = async (client, input, ...args) => {
                return await client.send(new ListIdentitiesCommand_1.ListIdentitiesCommand(input), ...args);
            };
            const makePagedRequest = async (client, input, ...args) => {
                return await client.listIdentities(input, ...args);
            };

            async function* paginateListIdentities(config, input, ...additionalArguments) {
                let token = config.startingToken || undefined;
                let hasNext = true;
                let page;
                while (hasNext) {
                    input.NextToken = token;
                    input["MaxItems"] = config.pageSize;
                    if (config.client instanceof SES_1.SES) {
                        page = await makePagedRequest(config.client, input, ...additionalArguments);
                    } else if (config.client instanceof SESClient_1.SESClient) {
                        page = await makePagedClientRequest(config.client, input, ...additionalArguments);
                    } else {
                        throw new Error("Invalid client, expected SES | SESClient");
                    }
                    yield page;
                    token = page.NextToken;
                    hasNext = !!token;
                }
                return undefined;
            }

            exports.paginateListIdentities = paginateListIdentities;


            /***/
        }),
        /* 65 */,
        /* 66 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.isCrtAvailable = void 0;
            const isCrtAvailable = () => {
                try {
                    if (true && __webpack_require__(617)) {
                        return ["md/crt-avail"];
                    }
                    return null;
                } catch (e) {
                    return null;
                }
            };
            exports.isCrtAvailable = isCrtAvailable;


            /***/
        }),
        /* 67 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getLoggerPlugin = exports.loggerMiddlewareOptions = exports.loggerMiddleware = void 0;
            const loggerMiddleware = () => (next, context) => async (args) => {
                const {clientName, commandName, inputFilterSensitiveLog, logger, outputFilterSensitiveLog} = context;
                const response = await next(args);
                if (!logger) {
                    return response;
                }
                if (typeof logger.info === "function") {
                    const {$metadata, ...outputWithoutMetadata} = response.output;
                    logger.info({
                        clientName,
                        commandName,
                        input: inputFilterSensitiveLog(args.input),
                        output: outputFilterSensitiveLog(outputWithoutMetadata),
                        metadata: $metadata,
                    });
                }
                return response;
            };
            exports.loggerMiddleware = loggerMiddleware;
            exports.loggerMiddlewareOptions = {
                name: "loggerMiddleware",
                tags: ["LOGGER"],
                step: "initialize",
                override: true,
            };
            const getLoggerPlugin = (options) => ({
                applyToStack: (clientStack) => {
                    clientStack.add((0, exports.loggerMiddleware)(), exports.loggerMiddlewareOptions);
                },
            });
            exports.getLoggerPlugin = getLoggerPlugin;


            /***/
        }),
        /* 68 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetIdentityDkimAttributesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetIdentityDkimAttributesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetIdentityDkimAttributesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetIdentityDkimAttributesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetIdentityDkimAttributesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetIdentityDkimAttributesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetIdentityDkimAttributesCommand)(output, context);
                }
            }

            exports.GetIdentityDkimAttributesCommand = GetIdentityDkimAttributesCommand;


            /***/
        }),
        /* 69 */,
        /* 70 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.MAX_PRESIGNED_TTL = exports.KEY_TYPE_IDENTIFIER = exports.MAX_CACHE_SIZE = exports.UNSIGNED_PAYLOAD = exports.EVENT_ALGORITHM_IDENTIFIER = exports.ALGORITHM_IDENTIFIER_V4A = exports.ALGORITHM_IDENTIFIER = exports.UNSIGNABLE_PATTERNS = exports.SEC_HEADER_PATTERN = exports.PROXY_HEADER_PATTERN = exports.ALWAYS_UNSIGNABLE_HEADERS = exports.HOST_HEADER = exports.TOKEN_HEADER = exports.SHA256_HEADER = exports.SIGNATURE_HEADER = exports.GENERATED_HEADERS = exports.DATE_HEADER = exports.AMZ_DATE_HEADER = exports.AUTH_HEADER = exports.REGION_SET_PARAM = exports.TOKEN_QUERY_PARAM = exports.SIGNATURE_QUERY_PARAM = exports.EXPIRES_QUERY_PARAM = exports.SIGNED_HEADERS_QUERY_PARAM = exports.AMZ_DATE_QUERY_PARAM = exports.CREDENTIAL_QUERY_PARAM = exports.ALGORITHM_QUERY_PARAM = void 0;
            exports.ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
            exports.CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
            exports.AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
            exports.SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
            exports.EXPIRES_QUERY_PARAM = "X-Amz-Expires";
            exports.SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
            exports.TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
            exports.REGION_SET_PARAM = "X-Amz-Region-Set";
            exports.AUTH_HEADER = "authorization";
            exports.AMZ_DATE_HEADER = exports.AMZ_DATE_QUERY_PARAM.toLowerCase();
            exports.DATE_HEADER = "date";
            exports.GENERATED_HEADERS = [exports.AUTH_HEADER, exports.AMZ_DATE_HEADER, exports.DATE_HEADER];
            exports.SIGNATURE_HEADER = exports.SIGNATURE_QUERY_PARAM.toLowerCase();
            exports.SHA256_HEADER = "x-amz-content-sha256";
            exports.TOKEN_HEADER = exports.TOKEN_QUERY_PARAM.toLowerCase();
            exports.HOST_HEADER = "host";
            exports.ALWAYS_UNSIGNABLE_HEADERS = {
                authorization: true,
                "cache-control": true,
                connection: true,
                expect: true,
                from: true,
                "keep-alive": true,
                "max-forwards": true,
                pragma: true,
                referer: true,
                te: true,
                trailer: true,
                "transfer-encoding": true,
                upgrade: true,
                "user-agent": true,
                "x-amzn-trace-id": true,
            };
            exports.PROXY_HEADER_PATTERN = /^proxy-/;
            exports.SEC_HEADER_PATTERN = /^sec-/;
            exports.UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
            exports.ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
            exports.ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
            exports.EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
            exports.UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
            exports.MAX_CACHE_SIZE = 50;
            exports.KEY_TYPE_IDENTIFIER = "aws4_request";
            exports.MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;


            /***/
        }),
        /* 71 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DecodeAuthorizationMessageCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const middleware_signing_1 = __webpack_require__(22);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(575);
            const Aws_query_1 = __webpack_require__(139);

            class DecodeAuthorizationMessageCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "STSClient";
                    const commandName = "DecodeAuthorizationMessageCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DecodeAuthorizationMessageRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DecodeAuthorizationMessageResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDecodeAuthorizationMessageCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDecodeAuthorizationMessageCommand)(output, context);
                }
            }

            exports.DecodeAuthorizationMessageCommand = DecodeAuthorizationMessageCommand;


            /***/
        }),
        /* 72 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.defaultRegionInfoProvider = void 0;
            const config_resolver_1 = __webpack_require__(772);
            const regionHash = {
                "us-gov-west-1": {
                    variants: [
                        {
                            hostname: "email-fips.us-gov-west-1.amazonaws.com",
                            tags: ["fips"],
                        },
                    ],
                },
            };
            const partitionHash = {
                aws: {
                    regions: [
                        "af-south-1",
                        "ap-east-1",
                        "ap-northeast-1",
                        "ap-northeast-2",
                        "ap-northeast-3",
                        "ap-south-1",
                        "ap-southeast-1",
                        "ap-southeast-2",
                        "ap-southeast-3",
                        "ca-central-1",
                        "eu-central-1",
                        "eu-north-1",
                        "eu-south-1",
                        "eu-west-1",
                        "eu-west-2",
                        "eu-west-3",
                        "me-south-1",
                        "sa-east-1",
                        "us-east-1",
                        "us-east-2",
                        "us-west-1",
                        "us-west-2",
                    ],
                    regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "email.{region}.amazonaws.com",
                            tags: [],
                        },
                        {
                            hostname: "email-fips.{region}.amazonaws.com",
                            tags: ["fips"],
                        },
                        {
                            hostname: "email-fips.{region}.api.aws",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "email.{region}.api.aws",
                            tags: ["dualstack"],
                        },
                    ],
                },
                "aws-cn": {
                    regions: ["cn-north-1", "cn-northwest-1"],
                    regionRegex: "^cn\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "email.{region}.amazonaws.com.cn",
                            tags: [],
                        },
                        {
                            hostname: "email-fips.{region}.amazonaws.com.cn",
                            tags: ["fips"],
                        },
                        {
                            hostname: "email-fips.{region}.api.amazonwebservices.com.cn",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "email.{region}.api.amazonwebservices.com.cn",
                            tags: ["dualstack"],
                        },
                    ],
                },
                "aws-iso": {
                    regions: ["us-iso-east-1", "us-iso-west-1"],
                    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "email.{region}.c2s.ic.gov",
                            tags: [],
                        },
                        {
                            hostname: "email-fips.{region}.c2s.ic.gov",
                            tags: ["fips"],
                        },
                    ],
                },
                "aws-iso-b": {
                    regions: ["us-isob-east-1"],
                    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "email.{region}.sc2s.sgov.gov",
                            tags: [],
                        },
                        {
                            hostname: "email-fips.{region}.sc2s.sgov.gov",
                            tags: ["fips"],
                        },
                    ],
                },
                "aws-us-gov": {
                    regions: ["fips-us-gov-west-1", "us-gov-east-1", "us-gov-west-1"],
                    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "email.{region}.amazonaws.com",
                            tags: [],
                        },
                        {
                            hostname: "email-fips.{region}.amazonaws.com",
                            tags: ["fips"],
                        },
                        {
                            hostname: "email-fips.{region}.api.aws",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "email.{region}.api.aws",
                            tags: ["dualstack"],
                        },
                    ],
                },
            };
            const defaultRegionInfoProvider = async (region, options) => (0, config_resolver_1.getRegionInfo)(region, {
                ...options,
                signingService: "ses",
                regionHash,
                partitionHash,
            });
            exports.defaultRegionInfoProvider = defaultRegionInfoProvider;


            /***/
        }),
        /* 73 */,
        /* 74 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DefaultRateLimiter = void 0;
            const service_error_classification_1 = __webpack_require__(868);

            class DefaultRateLimiter {
                constructor(options) {
                    var _a, _b, _c, _d, _e;
                    this.currentCapacity = 0;
                    this.enabled = false;
                    this.lastMaxRate = 0;
                    this.measuredTxRate = 0;
                    this.requestCount = 0;
                    this.lastTimestamp = 0;
                    this.timeWindow = 0;
                    this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;
                    this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;
                    this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;
                    this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;
                    this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;
                    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
                    this.lastThrottleTime = currentTimeInSeconds;
                    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
                    this.fillRate = this.minFillRate;
                    this.maxCapacity = this.minCapacity;
                }

                getCurrentTimeInSeconds() {
                    return Date.now() / 1000;
                }

                async getSendToken() {
                    return this.acquireTokenBucket(1);
                }

                async acquireTokenBucket(amount) {
                    if (!this.enabled) {
                        return;
                    }
                    this.refillTokenBucket();
                    if (amount > this.currentCapacity) {
                        const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
                        await new Promise((resolve) => setTimeout(resolve, delay));
                    }
                    this.currentCapacity = this.currentCapacity - amount;
                }

                refillTokenBucket() {
                    const timestamp = this.getCurrentTimeInSeconds();
                    if (!this.lastTimestamp) {
                        this.lastTimestamp = timestamp;
                        return;
                    }
                    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
                    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
                    this.lastTimestamp = timestamp;
                }

                updateClientSendingRate(response) {
                    let calculatedRate;
                    this.updateMeasuredRate();
                    if ((0, service_error_classification_1.isThrottlingError)(response)) {
                        const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
                        this.lastMaxRate = rateToUse;
                        this.calculateTimeWindow();
                        this.lastThrottleTime = this.getCurrentTimeInSeconds();
                        calculatedRate = this.cubicThrottle(rateToUse);
                        this.enableTokenBucket();
                    } else {
                        this.calculateTimeWindow();
                        calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
                    }
                    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
                    this.updateTokenBucketRate(newRate);
                }

                calculateTimeWindow() {
                    this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
                }

                cubicThrottle(rateToUse) {
                    return this.getPrecise(rateToUse * this.beta);
                }

                cubicSuccess(timestamp) {
                    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
                }

                enableTokenBucket() {
                    this.enabled = true;
                }

                updateTokenBucketRate(newRate) {
                    this.refillTokenBucket();
                    this.fillRate = Math.max(newRate, this.minFillRate);
                    this.maxCapacity = Math.max(newRate, this.minCapacity);
                    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
                }

                updateMeasuredRate() {
                    const t = this.getCurrentTimeInSeconds();
                    const timeBucket = Math.floor(t * 2) / 2;
                    this.requestCount++;
                    if (timeBucket > this.lastTxRateBucket) {
                        const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
                        this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
                        this.requestCount = 0;
                        this.lastTxRateBucket = timeBucket;
                    }
                }

                getPrecise(num) {
                    return parseFloat(num.toFixed(8));
                }
            }

            exports.DefaultRateLimiter = DefaultRateLimiter;


            /***/
        }),
        /* 75 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromString = exports.fromArrayBuffer = void 0;
            const is_array_buffer_1 = __webpack_require__(865);
            const buffer_1 = __webpack_require__(670);
            const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
                if (!(0, is_array_buffer_1.isArrayBuffer)(input)) {
                    throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
                }
                return buffer_1.Buffer.from(input, offset, length);
            };
            exports.fromArrayBuffer = fromArrayBuffer;
            const fromString = (input, encoding) => {
                if (typeof input !== "string") {
                    throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
                }
                return encoding ? buffer_1.Buffer.from(input, encoding) : buffer_1.Buffer.from(input);
            };
            exports.fromString = fromString;


            /***/
        }),
        /* 76 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 77 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SendEmailCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SendEmailCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SendEmailCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SendEmailRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SendEmailResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySendEmailCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySendEmailCommand)(output, context);
                }
            }

            exports.SendEmailCommand = SendEmailCommand;


            /***/
        }),
        /* 78 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.calculateBodyLength = void 0;
            const fs_1 = __webpack_require__(747);
            const calculateBodyLength = (body) => {
                if (!body) {
                    return 0;
                }
                if (typeof body === "string") {
                    return Buffer.from(body).length;
                } else if (typeof body.byteLength === "number") {
                    return body.byteLength;
                } else if (typeof body.size === "number") {
                    return body.size;
                } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
                    return (0, fs_1.lstatSync)(body.path).size;
                } else if (typeof body.fd === "number") {
                    return (0, fs_1.fstatSync)(body.fd).size;
                }
                throw new Error(`Body Length computation failed for ${body}`);
            };
            exports.calculateBodyLength = calculateBodyLength;


            /***/
        }),
        /* 79 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 80 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.strictParseByte = exports.strictParseShort = exports.strictParseInt32 = exports.strictParseInt = exports.strictParseLong = exports.limitedParseFloat32 = exports.limitedParseFloat = exports.handleFloat = exports.limitedParseDouble = exports.strictParseFloat32 = exports.strictParseFloat = exports.strictParseDouble = exports.expectUnion = exports.expectString = exports.expectObject = exports.expectNonNull = exports.expectByte = exports.expectShort = exports.expectInt32 = exports.expectInt = exports.expectLong = exports.expectFloat32 = exports.expectNumber = exports.expectBoolean = exports.parseBoolean = void 0;
            const parseBoolean = (value) => {
                switch (value) {
                    case "true":
                        return true;
                    case "false":
                        return false;
                    default:
                        throw new Error(`Unable to parse boolean value "${value}"`);
                }
            };
            exports.parseBoolean = parseBoolean;
            const expectBoolean = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                if (typeof value === "boolean") {
                    return value;
                }
                throw new TypeError(`Expected boolean, got ${typeof value}`);
            };
            exports.expectBoolean = expectBoolean;
            const expectNumber = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                if (typeof value === "number") {
                    return value;
                }
                throw new TypeError(`Expected number, got ${typeof value}`);
            };
            exports.expectNumber = expectNumber;
            const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
            const expectFloat32 = (value) => {
                const expected = (0, exports.expectNumber)(value);
                if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
                    if (Math.abs(expected) > MAX_FLOAT) {
                        throw new TypeError(`Expected 32-bit float, got ${value}`);
                    }
                }
                return expected;
            };
            exports.expectFloat32 = expectFloat32;
            const expectLong = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                if (Number.isInteger(value) && !Number.isNaN(value)) {
                    return value;
                }
                throw new TypeError(`Expected integer, got ${typeof value}`);
            };
            exports.expectLong = expectLong;
            exports.expectInt = exports.expectLong;
            const expectInt32 = (value) => expectSizedInt(value, 32);
            exports.expectInt32 = expectInt32;
            const expectShort = (value) => expectSizedInt(value, 16);
            exports.expectShort = expectShort;
            const expectByte = (value) => expectSizedInt(value, 8);
            exports.expectByte = expectByte;
            const expectSizedInt = (value, size) => {
                const expected = (0, exports.expectLong)(value);
                if (expected !== undefined && castInt(expected, size) !== expected) {
                    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
                }
                return expected;
            };
            const castInt = (value, size) => {
                switch (size) {
                    case 32:
                        return Int32Array.of(value)[0];
                    case 16:
                        return Int16Array.of(value)[0];
                    case 8:
                        return Int8Array.of(value)[0];
                }
            };
            const expectNonNull = (value, location) => {
                if (value === null || value === undefined) {
                    if (location) {
                        throw new TypeError(`Expected a non-null value for ${location}`);
                    }
                    throw new TypeError("Expected a non-null value");
                }
                return value;
            };
            exports.expectNonNull = expectNonNull;
            const expectObject = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                if (typeof value === "object" && !Array.isArray(value)) {
                    return value;
                }
                throw new TypeError(`Expected object, got ${typeof value}`);
            };
            exports.expectObject = expectObject;
            const expectString = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                if (typeof value === "string") {
                    return value;
                }
                throw new TypeError(`Expected string, got ${typeof value}`);
            };
            exports.expectString = expectString;
            const expectUnion = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                const asObject = (0, exports.expectObject)(value);
                const setKeys = Object.entries(asObject)
                    .filter(([_, v]) => v !== null && v !== undefined)
                    .map(([k, _]) => k);
                if (setKeys.length === 0) {
                    throw new TypeError(`Unions must have exactly one non-null member`);
                }
                if (setKeys.length > 1) {
                    throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
                }
                return asObject;
            };
            exports.expectUnion = expectUnion;
            const strictParseDouble = (value) => {
                if (typeof value == "string") {
                    return (0, exports.expectNumber)(parseNumber(value));
                }
                return (0, exports.expectNumber)(value);
            };
            exports.strictParseDouble = strictParseDouble;
            exports.strictParseFloat = exports.strictParseDouble;
            const strictParseFloat32 = (value) => {
                if (typeof value == "string") {
                    return (0, exports.expectFloat32)(parseNumber(value));
                }
                return (0, exports.expectFloat32)(value);
            };
            exports.strictParseFloat32 = strictParseFloat32;
            const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
            const parseNumber = (value) => {
                const matches = value.match(NUMBER_REGEX);
                if (matches === null || matches[0].length !== value.length) {
                    throw new TypeError(`Expected real number, got implicit NaN`);
                }
                return parseFloat(value);
            };
            const limitedParseDouble = (value) => {
                if (typeof value == "string") {
                    return parseFloatString(value);
                }
                return (0, exports.expectNumber)(value);
            };
            exports.limitedParseDouble = limitedParseDouble;
            exports.handleFloat = exports.limitedParseDouble;
            exports.limitedParseFloat = exports.limitedParseDouble;
            const limitedParseFloat32 = (value) => {
                if (typeof value == "string") {
                    return parseFloatString(value);
                }
                return (0, exports.expectFloat32)(value);
            };
            exports.limitedParseFloat32 = limitedParseFloat32;
            const parseFloatString = (value) => {
                switch (value) {
                    case "NaN":
                        return NaN;
                    case "Infinity":
                        return Infinity;
                    case "-Infinity":
                        return -Infinity;
                    default:
                        throw new Error(`Unable to parse float value: ${value}`);
                }
            };
            const strictParseLong = (value) => {
                if (typeof value === "string") {
                    return (0, exports.expectLong)(parseNumber(value));
                }
                return (0, exports.expectLong)(value);
            };
            exports.strictParseLong = strictParseLong;
            exports.strictParseInt = exports.strictParseLong;
            const strictParseInt32 = (value) => {
                if (typeof value === "string") {
                    return (0, exports.expectInt32)(parseNumber(value));
                }
                return (0, exports.expectInt32)(value);
            };
            exports.strictParseInt32 = strictParseInt32;
            const strictParseShort = (value) => {
                if (typeof value === "string") {
                    return (0, exports.expectShort)(parseNumber(value));
                }
                return (0, exports.expectShort)(value);
            };
            exports.strictParseShort = strictParseShort;
            const strictParseByte = (value) => {
                if (typeof value === "string") {
                    return (0, exports.expectByte)(parseNumber(value));
                }
                return (0, exports.expectByte)(value);
            };
            exports.strictParseByte = strictParseByte;


            /***/
        }),
        /* 81 */,
        /* 82 */,
        /* 83 */,
        /* 84 */
        /***/ (function (module) {

            /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
            /* global global, define, System, Reflect, Promise */
            var __extends;
            var __assign;
            var __rest;
            var __decorate;
            var __param;
            var __metadata;
            var __awaiter;
            var __generator;
            var __exportStar;
            var __values;
            var __read;
            var __spread;
            var __spreadArrays;
            var __spreadArray;
            var __await;
            var __asyncGenerator;
            var __asyncDelegator;
            var __asyncValues;
            var __makeTemplateObject;
            var __importStar;
            var __importDefault;
            var __classPrivateFieldGet;
            var __classPrivateFieldSet;
            var __createBinding;
            (function (factory) {
                var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
                if (typeof define === "function" && define.amd) {
                    define("tslib", ["exports"], function (exports) {
                        factory(createExporter(root, createExporter(exports)));
                    });
                } else if (true && typeof module.exports === "object") {
                    factory(createExporter(root, createExporter(module.exports)));
                } else {
                    factory(createExporter(root));
                }

                function createExporter(exports, previous) {
                    if (exports !== root) {
                        if (typeof Object.create === "function") {
                            Object.defineProperty(exports, "__esModule", {value: true});
                        } else {
                            exports.__esModule = true;
                        }
                    }
                    return function (id, v) {
                        return exports[id] = previous ? previous(id, v) : v;
                    };
                }
            })
            (function (exporter) {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                    };

                __extends = function (d, b) {
                    if (typeof b !== "function" && b !== null)
                        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };

                __assign = Object.assign || function (t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                    }
                    return t;
                };

                __rest = function (s, e) {
                    var t = {};
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                        t[p] = s[p];
                    if (s != null && typeof Object.getOwnPropertySymbols === "function")
                        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                                t[p[i]] = s[p[i]];
                        }
                    return t;
                };

                __decorate = function (decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                        d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };

                __param = function (paramIndex, decorator) {
                    return function (target, key) {
                        decorator(target, key, paramIndex);
                    }
                };

                __metadata = function (metadataKey, metadataValue) {
                    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
                };

                __awaiter = function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P ? value : new P(function (resolve) {
                            resolve(value);
                        });
                    }

                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }

                        function rejected(value) {
                            try {
                                step(generator["throw"](value));
                            } catch (e) {
                                reject(e);
                            }
                        }

                        function step(result) {
                            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                        }

                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };

                __generator = function (thisArg, body) {
                    var _ = {
                        label: 0, sent: function () {
                            if (t[0] & 1) throw t[1];
                            return t[1];
                        }, trys: [], ops: []
                    }, f, y, t, g;
                    return g = {
                        next: verb(0),
                        "throw": verb(1),
                        "return": verb(2)
                    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                        return this;
                    }), g;

                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }

                    function step(op) {
                        if (f) throw new TypeError("Generator is already executing.");
                        while (_) try {
                            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                            if (y = 0, t) op = [op[0] & 2, t.value];
                            switch (op[0]) {
                                case 0:
                                case 1:
                                    t = op;
                                    break;
                                case 4:
                                    _.label++;
                                    return {value: op[1], done: false};
                                case 5:
                                    _.label++;
                                    y = op[1];
                                    op = [0];
                                    continue;
                                case 7:
                                    op = _.ops.pop();
                                    _.trys.pop();
                                    continue;
                                default:
                                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                        _ = 0;
                                        continue;
                                    }
                                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                        _.label = op[1];
                                        break;
                                    }
                                    if (op[0] === 6 && _.label < t[1]) {
                                        _.label = t[1];
                                        t = op;
                                        break;
                                    }
                                    if (t && _.label < t[2]) {
                                        _.label = t[2];
                                        _.ops.push(op);
                                        break;
                                    }
                                    if (t[2]) _.ops.pop();
                                    _.trys.pop();
                                    continue;
                            }
                            op = body.call(thisArg, _);
                        } catch (e) {
                            op = [6, e];
                            y = 0;
                        } finally {
                            f = t = 0;
                        }
                        if (op[0] & 5) throw op[1];
                        return {value: op[0] ? op[1] : void 0, done: true};
                    }
                };

                __exportStar = function (m, o) {
                    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
                };

                __createBinding = Object.create ? (function (o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    Object.defineProperty(o, k2, {
                        enumerable: true, get: function () {
                            return m[k];
                        }
                    });
                }) : (function (o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });

                __values = function (o) {
                    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
                    if (m) return m.call(o);
                    if (o && typeof o.length === "number") return {
                        next: function () {
                            if (o && i >= o.length) o = void 0;
                            return {value: o && o[i++], done: !o};
                        }
                    };
                    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
                };

                __read = function (o, n) {
                    var m = typeof Symbol === "function" && o[Symbol.iterator];
                    if (!m) return o;
                    var i = m.call(o), r, ar = [], e;
                    try {
                        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                    } catch (error) {
                        e = {error: error};
                    } finally {
                        try {
                            if (r && !r.done && (m = i["return"])) m.call(i);
                        } finally {
                            if (e) throw e.error;
                        }
                    }
                    return ar;
                };

                /** @deprecated */
                __spread = function () {
                    for (var ar = [], i = 0; i < arguments.length; i++)
                        ar = ar.concat(__read(arguments[i]));
                    return ar;
                };

                /** @deprecated */
                __spreadArrays = function () {
                    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
                    for (var r = Array(s), k = 0, i = 0; i < il; i++)
                        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                            r[k] = a[j];
                    return r;
                };

                __spreadArray = function (to, from, pack) {
                    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
                        if (ar || !(i in from)) {
                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                            ar[i] = from[i];
                        }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                };

                __await = function (v) {
                    return this instanceof __await ? (this.v = v, this) : new __await(v);
                };

                __asyncGenerator = function (thisArg, _arguments, generator) {
                    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                    var g = generator.apply(thisArg, _arguments || []), i, q = [];
                    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
                        return this;
                    }, i;

                    function verb(n) {
                        if (g[n]) i[n] = function (v) {
                            return new Promise(function (a, b) {
                                q.push([n, v, a, b]) > 1 || resume(n, v);
                            });
                        };
                    }

                    function resume(n, v) {
                        try {
                            step(g[n](v));
                        } catch (e) {
                            settle(q[0][3], e);
                        }
                    }

                    function step(r) {
                        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                    }

                    function fulfill(value) {
                        resume("next", value);
                    }

                    function reject(value) {
                        resume("throw", value);
                    }

                    function settle(f, v) {
                        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
                    }
                };

                __asyncDelegator = function (o) {
                    var i, p;
                    return i = {}, verb("next"), verb("throw", function (e) {
                        throw e;
                    }), verb("return"), i[Symbol.iterator] = function () {
                        return this;
                    }, i;

                    function verb(n, f) {
                        i[n] = o[n] ? function (v) {
                            return (p = !p) ? {value: __await(o[n](v)), done: n === "return"} : f ? f(v) : v;
                        } : f;
                    }
                };

                __asyncValues = function (o) {
                    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                    var m = o[Symbol.asyncIterator], i;
                    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
                        return this;
                    }, i);

                    function verb(n) {
                        i[n] = o[n] && function (v) {
                            return new Promise(function (resolve, reject) {
                                v = o[n](v), settle(resolve, reject, v.done, v.value);
                            });
                        };
                    }

                    function settle(resolve, reject, d, v) {
                        Promise.resolve(v).then(function (v) {
                            resolve({value: v, done: d});
                        }, reject);
                    }
                };

                __makeTemplateObject = function (cooked, raw) {
                    if (Object.defineProperty) {
                        Object.defineProperty(cooked, "raw", {value: raw});
                    } else {
                        cooked.raw = raw;
                    }
                    return cooked;
                };

                var __setModuleDefault = Object.create ? (function (o, v) {
                    Object.defineProperty(o, "default", {enumerable: true, value: v});
                }) : function (o, v) {
                    o["default"] = v;
                };

                __importStar = function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };

                __importDefault = function (mod) {
                    return (mod && mod.__esModule) ? mod : {"default": mod};
                };

                __classPrivateFieldGet = function (receiver, state, kind, f) {
                    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
                    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
                };

                __classPrivateFieldSet = function (receiver, state, value, kind, f) {
                    if (kind === "m") throw new TypeError("Private method is not writable");
                    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
                    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
                };

                exporter("__extends", __extends);
                exporter("__assign", __assign);
                exporter("__rest", __rest);
                exporter("__decorate", __decorate);
                exporter("__param", __param);
                exporter("__metadata", __metadata);
                exporter("__awaiter", __awaiter);
                exporter("__generator", __generator);
                exporter("__exportStar", __exportStar);
                exporter("__createBinding", __createBinding);
                exporter("__values", __values);
                exporter("__read", __read);
                exporter("__spread", __spread);
                exporter("__spreadArrays", __spreadArrays);
                exporter("__spreadArray", __spreadArray);
                exporter("__await", __await);
                exporter("__asyncGenerator", __asyncGenerator);
                exporter("__asyncDelegator", __asyncDelegator);
                exporter("__asyncValues", __asyncValues);
                exporter("__makeTemplateObject", __makeTemplateObject);
                exporter("__importStar", __importStar);
                exporter("__importDefault", __importDefault);
                exporter("__classPrivateFieldGet", __classPrivateFieldGet);
                exporter("__classPrivateFieldSet", __classPrivateFieldSet);
            });


            /***/
        }),
        /* 85 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _crypto = _interopRequireDefault(__webpack_require__(417));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            function md5(bytes) {
                if (Array.isArray(bytes)) {
                    bytes = Buffer.from(bytes);
                } else if (typeof bytes === 'string') {
                    bytes = Buffer.from(bytes, 'utf8');
                }

                return _crypto.default.createHash('md5').update(bytes).digest();
            }

            var _default = md5;
            exports.default = _default;

            /***/
        }),
        /* 86 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SetActiveReceiptRuleSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SetActiveReceiptRuleSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SetActiveReceiptRuleSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SetActiveReceiptRuleSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SetActiveReceiptRuleSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySetActiveReceiptRuleSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySetActiveReceiptRuleSetCommand)(output, context);
                }
            }

            exports.SetActiveReceiptRuleSetCommand = SetActiveReceiptRuleSetCommand;


            /***/
        }),
        /* 87 */
        /***/ (function (module) {

            module.exports = require("os");

            /***/
        }),
        /* 88 */,
        /* 89 */,
        /* 90 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListReceiptFiltersCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ListReceiptFiltersCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ListReceiptFiltersCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListReceiptFiltersRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListReceiptFiltersResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryListReceiptFiltersCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryListReceiptFiltersCommand)(output, context);
                }
            }

            exports.ListReceiptFiltersCommand = ListReceiptFiltersCommand;


            /***/
        }),
        /* 91 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListConfigurationSetsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ListConfigurationSetsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ListConfigurationSetsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListConfigurationSetsRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListConfigurationSetsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryListConfigurationSetsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryListConfigurationSetsCommand)(output, context);
                }
            }

            exports.ListConfigurationSetsCommand = ListConfigurationSetsCommand;


            /***/
        }),
        /* 92 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                Object.defineProperty(o, k2, {
                    enumerable: true, get: function () {
                        return m[k];
                    }
                });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", {enumerable: true, value: v});
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.issue = exports.issueCommand = void 0;
            const os = __importStar(__webpack_require__(87));
            const utils_1 = __webpack_require__(14);

            /**
             * Commands
             *
             * Command Format:
             *   ::name key=value,key=value::message
             *
             * Examples:
             *   ::warning::This is the message
             *   ::set-env name=MY_VAR::some value
             */
            function issueCommand(command, properties, message) {
                const cmd = new Command(command, properties, message);
                process.stdout.write(cmd.toString() + os.EOL);
            }

            exports.issueCommand = issueCommand;

            function issue(name, message = '') {
                issueCommand(name, {}, message);
            }

            exports.issue = issue;
            const CMD_STRING = '::';

            class Command {
                constructor(command, properties, message) {
                    if (!command) {
                        command = 'missing.command';
                    }
                    this.command = command;
                    this.properties = properties;
                    this.message = message;
                }

                toString() {
                    let cmdStr = CMD_STRING + this.command;
                    if (this.properties && Object.keys(this.properties).length > 0) {
                        cmdStr += ' ';
                        let first = true;
                        for (const key in this.properties) {
                            if (this.properties.hasOwnProperty(key)) {
                                const val = this.properties[key];
                                if (val) {
                                    if (first) {
                                        first = false;
                                    } else {
                                        cmdStr += ',';
                                    }
                                    cmdStr += `${key}=${escapeProperty(val)}`;
                                }
                            }
                        }
                    }
                    cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
                    return cmdStr;
                }
            }

            function escapeData(s) {
                return utils_1.toCommandValue(s)
                    .replace(/%/g, '%25')
                    .replace(/\r/g, '%0D')
                    .replace(/\n/g, '%0A');
            }

            function escapeProperty(s) {
                return utils_1.toCommandValue(s)
                    .replace(/%/g, '%25')
                    .replace(/\r/g, '%0D')
                    .replace(/\n/g, '%0A')
                    .replace(/:/g, '%3A')
                    .replace(/,/g, '%2C');
            }

//# sourceMappingURL=command.js.map

            /***/
        }),
        /* 93 */,
        /* 94 */,
        /* 95 */,
        /* 96 */,
        /* 97 */,
        /* 98 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.LazyJsonString = exports.StringWrapper = void 0;
            const StringWrapper = function () {
                const Class = Object.getPrototypeOf(this).constructor;
                const Constructor = Function.bind.apply(String, [null, ...arguments]);
                const instance = new Constructor();
                Object.setPrototypeOf(instance, Class.prototype);
                return instance;
            };
            exports.StringWrapper = StringWrapper;
            exports.StringWrapper.prototype = Object.create(String.prototype, {
                constructor: {
                    value: exports.StringWrapper,
                    enumerable: false,
                    writable: true,
                    configurable: true,
                },
            });
            Object.setPrototypeOf(exports.StringWrapper, String);

            class LazyJsonString extends exports.StringWrapper {
                static fromObject(object) {
                    if (object instanceof LazyJsonString) {
                        return object;
                    } else if (object instanceof String || typeof object === "string") {
                        return new LazyJsonString(object);
                    }
                    return new LazyJsonString(JSON.stringify(object));
                }

                deserializeJSON() {
                    return JSON.parse(super.toString());
                }

                toJSON() {
                    return super.toString();
                }
            }

            exports.LazyJsonString = LazyJsonString;


            /***/
        }),
        /* 99 */,
        /* 100 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListReceiptRuleSetsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ListReceiptRuleSetsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ListReceiptRuleSetsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListReceiptRuleSetsRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListReceiptRuleSetsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryListReceiptRuleSetsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryListReceiptRuleSetsCommand)(output, context);
                }
            }

            exports.ListReceiptRuleSetsCommand = ListReceiptRuleSetsCommand;


            /***/
        }),
        /* 101 */,
        /* 102 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveSSOCredentials = void 0;
            const client_sso_1 = __webpack_require__(266);
            const property_provider_1 = __webpack_require__(118);
            const shared_ini_file_loader_1 = __webpack_require__(706);
            const EXPIRE_WINDOW_MS = 15 * 60 * 1000;
            const SHOULD_FAIL_CREDENTIAL_CHAIN = false;
            const resolveSSOCredentials = async ({ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient,}) => {
                let token;
                const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
                try {
                    token = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoStartUrl);
                } catch (e) {
                    throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
                }
                if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {
                    throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
                }
                const {accessToken} = token;
                const sso = ssoClient || new client_sso_1.SSOClient({region: ssoRegion});
                let ssoResp;
                try {
                    ssoResp = await sso.send(new client_sso_1.GetRoleCredentialsCommand({
                        accountId: ssoAccountId,
                        roleName: ssoRoleName,
                        accessToken,
                    }));
                } catch (e) {
                    throw property_provider_1.CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);
                }
                const {roleCredentials: {accessKeyId, secretAccessKey, sessionToken, expiration} = {}} = ssoResp;
                if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
                    throw new property_provider_1.CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
                }
                return {accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration)};
            };
            exports.resolveSSOCredentials = resolveSSOCredentials;


            /***/
        }),
        /* 103 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";
            /* eslint no-control-regex:0 */


            const base64 = __webpack_require__(528);
            const qp = __webpack_require__(529);
            const mimeTypes = __webpack_require__(332);

            module.exports = {
                /**
                 * Checks if a value is plaintext string (uses only printable 7bit chars)
                 *
                 * @param {String} value String to be tested
                 * @returns {Boolean} true if it is a plaintext string
                 */
                isPlainText(value, isParam) {
                    const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
                    if (typeof value !== 'string' || re.test(value)) {
                        return false;
                    } else {
                        return true;
                    }
                },

                /**
                 * Checks if a multi line string containes lines longer than the selected value.
                 *
                 * Useful when detecting if a mail message needs any processing at all 
                 * if only plaintext characters are used and lines are short, then there is
                 * no need to encode the values in any way. If the value is plaintext but has
                 * longer lines then allowed, then use format=flowed
                 *
                 * @param {Number} lineLength Max line length to check for
                 * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars
                 */
                hasLongerLines(str, lineLength) {
                    if (str.length > 128 * 1024) {
                        // do not test strings longer than 128kB
                        return true;
                    }
                    return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);
                },

                /**
                 * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)
                 *
                 * @param {String|Buffer} data String to be encoded
                 * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
                 * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
                 * @return {String} Single or several mime words joined together
                 */
                encodeWord(data, mimeWordEncoding, maxLength) {
                    mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);
                    maxLength = maxLength || 0;

                    let encodedStr;
                    let toCharset = 'UTF-8';

                    if (maxLength && maxLength > 7 + toCharset.length) {
                        maxLength -= 7 + toCharset.length;
                    }

                    if (mimeWordEncoding === 'Q') {
                        // https://tools.ietf.org/html/rfc2047#section-5 rule (3)
                        encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, chr => {
                            let ord = chr.charCodeAt(0).toString(16).toUpperCase();
                            if (chr === ' ') {
                                return '_';
                            } else {
                                return '=' + (ord.length === 1 ? '0' + ord : ord);
                            }
                        });
                    } else if (mimeWordEncoding === 'B') {
                        encodedStr = typeof data === 'string' ? data : base64.encode(data);
                        maxLength = maxLength ? Math.max(3, ((maxLength - (maxLength % 4)) / 4) * 3) : 0;
                    }

                    if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : base64.encode(data)).length > maxLength) {
                        if (mimeWordEncoding === 'Q') {
                            encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');
                        } else {
                            // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences
                            let parts = [];
                            let lpart = '';
                            for (let i = 0, len = encodedStr.length; i < len; i++) {
                                let chr = encodedStr.charAt(i);
                                // check if we can add this character to the existing string
                                // without breaking byte length limit
                                if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
                                    lpart += chr;
                                } else {
                                    // we hit the length limit, so push the existing string and start over
                                    parts.push(base64.encode(lpart));
                                    lpart = chr;
                                }
                            }
                            if (lpart) {
                                parts.push(base64.encode(lpart));
                            }

                            if (parts.length > 1) {
                                encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');
                            } else {
                                encodedStr = parts.join('');
                            }
                        }
                    } else if (mimeWordEncoding === 'B') {
                        encodedStr = base64.encode(data);
                    }

                    return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');
                },

                /**
                 * Finds word sequences with non ascii text and converts these to mime words
                 *
                 * @param {String} value String to be encoded
                 * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
                 * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
                 * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match
                 * @return {String} String with possible mime words
                 */
                encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {
                    maxLength = maxLength || 0;

                    let encodedValue;

                    // find first word with a non-printable ascii or special symbol in it
                    let firstMatch = value.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
                    if (!firstMatch) {
                        return value;
                    }

                    if (encodeAll) {
                        // if it is requested to encode everything or the string contains something that resebles encoded word, then encode everything

                        return this.encodeWord(value, mimeWordEncoding, maxLength);
                    }

                    // find the last word with a non-printable ascii in it
                    let lastMatch = value.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
                    if (!lastMatch) {
                        // should not happen
                        return value;
                    }

                    let startIndex =
                        firstMatch.index +
                        (
                            firstMatch[0].match(/[^\s]/) || {
                                index: 0
                            }
                        ).index;
                    let endIndex = lastMatch.index + (lastMatch[1] || '').length;

                    encodedValue =
                        (startIndex ? value.substr(0, startIndex) : '') +
                        this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || 'Q', maxLength) +
                        (endIndex < value.length ? value.substr(endIndex) : '');

                    return encodedValue;
                },

                /**
                 * Joins parsed header value together as 'value; param1=value1; param2=value2'
                 * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.
                 *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html
                 * @param {Object} structured Parsed header value
                 * @return {String} joined header value
                 */
                buildHeaderValue(structured) {
                    let paramsArray = [];

                    Object.keys(structured.params || {}).forEach(param => {
                        // filename might include unicode characters so it is a special case
                        // other values probably do not
                        let value = structured.params[param];
                        if (!this.isPlainText(value, true) || value.length >= 75) {
                            this.buildHeaderParam(param, value, 50).forEach(encodedParam => {
                                if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {
                                    paramsArray.push(encodedParam.key + '=' + encodedParam.value);
                                } else {
                                    paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));
                                }
                            });
                        } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value)) {
                            paramsArray.push(param + '=' + JSON.stringify(value));
                        } else {
                            paramsArray.push(param + '=' + value);
                        }
                    });

                    return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');
                },

                /**
                 * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)
                 * Useful for splitting long parameter values.
                 *
                 * For example
                 *      title="unicode string"
                 * becomes
                 *     title*0*=utf-8''unicode
                 *     title*1*=%20string
                 *
                 * @param {String|Buffer} data String to be encoded
                 * @param {Number} [maxLength=50] Max length for generated chunks
                 * @param {String} [fromCharset='UTF-8'] Source sharacter set
                 * @return {Array} A list of encoded keys and headers
                 */
                buildHeaderParam(key, data, maxLength) {
                    let list = [];
                    let encodedStr = typeof data === 'string' ? data : (data || '').toString();
                    let encodedStrArr;
                    let chr, ord;
                    let line;
                    let startPos = 0;
                    let i, len;

                    maxLength = maxLength || 50;

                    // process ascii only text
                    if (this.isPlainText(data, true)) {
                        // check if conversion is even needed
                        if (encodedStr.length <= maxLength) {
                            return [
                                {
                                    key,
                                    value: encodedStr
                                }
                            ];
                        }

                        encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), str => {
                            list.push({
                                line: str
                            });
                            return '';
                        });

                        if (encodedStr) {
                            list.push({
                                line: encodedStr
                            });
                        }
                    } else {
                        if (/[\uD800-\uDBFF]/.test(encodedStr)) {
                            // string containts surrogate pairs, so normalize it to an array of bytes
                            encodedStrArr = [];
                            for (i = 0, len = encodedStr.length; i < len; i++) {
                                chr = encodedStr.charAt(i);
                                ord = chr.charCodeAt(0);
                                if (ord >= 0xd800 && ord <= 0xdbff && i < len - 1) {
                                    chr += encodedStr.charAt(i + 1);
                                    encodedStrArr.push(chr);
                                    i++;
                                } else {
                                    encodedStrArr.push(chr);
                                }
                            }
                            encodedStr = encodedStrArr;
                        }

                        // first line includes the charset and language info and needs to be encoded
                        // even if it does not contain any unicode characters
                        line = 'utf-8\x27\x27';
                        let encoded = true;
                        startPos = 0;

                        // process text with unicode or special chars
                        for (i = 0, len = encodedStr.length; i < len; i++) {
                            chr = encodedStr[i];

                            if (encoded) {
                                chr = this.safeEncodeURIComponent(chr);
                            } else {
                                // try to urlencode current char
                                chr = chr === ' ' ? chr : this.safeEncodeURIComponent(chr);
                                // By default it is not required to encode a line, the need
                                // only appears when the string contains unicode or special chars
                                // in this case we start processing the line over and encode all chars
                                if (chr !== encodedStr[i]) {
                                    // Check if it is even possible to add the encoded char to the line
                                    // If not, there is no reason to use this line, just push it to the list
                                    // and start a new line with the char that needs encoding
                                    if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {
                                        list.push({
                                            line,
                                            encoded
                                        });
                                        line = '';
                                        startPos = i - 1;
                                    } else {
                                        encoded = true;
                                        i = startPos;
                                        line = '';
                                        continue;
                                    }
                                }
                            }

                            // if the line is already too long, push it to the list and start a new one
                            if ((line + chr).length >= maxLength) {
                                list.push({
                                    line,
                                    encoded
                                });
                                line = chr = encodedStr[i] === ' ' ? ' ' : this.safeEncodeURIComponent(encodedStr[i]);
                                if (chr === encodedStr[i]) {
                                    encoded = false;
                                    startPos = i - 1;
                                } else {
                                    encoded = true;
                                }
                            } else {
                                line += chr;
                            }
                        }

                        if (line) {
                            list.push({
                                line,
                                encoded
                            });
                        }
                    }

                    return list.map((item, i) => ({
                        // encoded lines: {name}*{part}*
                        // unencoded lines: {name}*{part}
                        // if any line needs to be encoded then the first line (part==0) is always encoded
                        key: key + '*' + i + (item.encoded ? '*' : ''),
                        value: item.line
                    }));
                },

                /**
                 * Parses a header value with key=value arguments into a structured
                 * object.
                 *
                 *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->
                 *   {
                 *     'value': 'text/plain',
                 *     'params': {
                 *       'charset': 'UTF-8'
                 *     }
                 *   }
                 *
                 * @param {String} str Header value
                 * @return {Object} Header value as a parsed structure
                 */
                parseHeaderValue(str) {
                    let response = {
                        value: false,
                        params: {}
                    };
                    let key = false;
                    let value = '';
                    let type = 'value';
                    let quote = false;
                    let escaped = false;
                    let chr;

                    for (let i = 0, len = str.length; i < len; i++) {
                        chr = str.charAt(i);
                        if (type === 'key') {
                            if (chr === '=') {
                                key = value.trim().toLowerCase();
                                type = 'value';
                                value = '';
                                continue;
                            }
                            value += chr;
                        } else {
                            if (escaped) {
                                value += chr;
                            } else if (chr === '\\') {
                                escaped = true;
                                continue;
                            } else if (quote && chr === quote) {
                                quote = false;
                            } else if (!quote && chr === '"') {
                                quote = chr;
                            } else if (!quote && chr === ';') {
                                if (key === false) {
                                    response.value = value.trim();
                                } else {
                                    response.params[key] = value.trim();
                                }
                                type = 'key';
                                value = '';
                            } else {
                                value += chr;
                            }
                            escaped = false;
                        }
                    }

                    if (type === 'value') {
                        if (key === false) {
                            response.value = value.trim();
                        } else {
                            response.params[key] = value.trim();
                        }
                    } else if (value.trim()) {
                        response.params[value.trim().toLowerCase()] = '';
                    }

                    // handle parameter value continuations
                    // https://tools.ietf.org/html/rfc2231#section-3

                    // preprocess values
                    Object.keys(response.params).forEach(key => {
                        let actualKey, nr, match, value;
                        if ((match = key.match(/(\*(\d+)|\*(\d+)\*|\*)$/))) {
                            actualKey = key.substr(0, match.index);
                            nr = Number(match[2] || match[3]) || 0;

                            if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {
                                response.params[actualKey] = {
                                    charset: false,
                                    values: []
                                };
                            }

                            value = response.params[key];

                            if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {
                                response.params[actualKey].charset = match[1] || 'iso-8859-1';
                                value = match[2];
                            }

                            response.params[actualKey].values[nr] = value;

                            // remove the old reference
                            delete response.params[key];
                        }
                    });

                    // concatenate split rfc2231 strings and convert encoded strings to mime encoded words
                    Object.keys(response.params).forEach(key => {
                        let value;
                        if (response.params[key] && Array.isArray(response.params[key].values)) {
                            value = response.params[key].values.map(val => val || '').join('');

                            if (response.params[key].charset) {
                                // convert "%AB" to "=?charset?Q?=AB?="
                                response.params[key] =
                                    '=?' +
                                    response.params[key].charset +
                                    '?Q?' +
                                    value
                                        // fix invalidly encoded chars
                                        .replace(/[=?_\s]/g, s => {
                                            let c = s.charCodeAt(0).toString(16);
                                            if (s === ' ') {
                                                return '_';
                                            } else {
                                                return '%' + (c.length < 2 ? '0' : '') + c;
                                            }
                                        })
                                        // change from urlencoding to percent encoding
                                        .replace(/%/g, '=') +
                                    '?=';
                            } else {
                                response.params[key] = value;
                            }
                        }
                    });

                    return response;
                },

                /**
                 * Returns file extension for a content type string. If no suitable extensions
                 * are found, 'bin' is used as the default extension
                 *
                 * @param {String} mimeType Content type to be checked for
                 * @return {String} File extension
                 */
                detectExtension: mimeType => mimeTypes.detectExtension(mimeType),

                /**
                 * Returns content type for a file extension. If no suitable content types
                 * are found, 'application/octet-stream' is used as the default content type
                 *
                 * @param {String} extension Extension to be checked for
                 * @return {String} File extension
                 */
                detectMimeType: extension => mimeTypes.detectMimeType(extension),

                /**
                 * Folds long lines, useful for folding header lines (afterSpace=false) and
                 * flowed text (afterSpace=true)
                 *
                 * @param {String} str String to be folded
                 * @param {Number} [lineLength=76] Maximum length of a line
                 * @param {Boolean} afterSpace If true, leave a space in th end of a line
                 * @return {String} String with folded lines
                 */
                foldLines(str, lineLength, afterSpace) {
                    str = (str || '').toString();
                    lineLength = lineLength || 76;

                    let pos = 0,
                        len = str.length,
                        result = '',
                        line,
                        match;

                    while (pos < len) {
                        line = str.substr(pos, lineLength);
                        if (line.length < lineLength) {
                            result += line;
                            break;
                        }
                        if ((match = line.match(/^[^\n\r]*(\r?\n|\r)/))) {
                            line = match[0];
                            result += line;
                            pos += line.length;
                            continue;
                        } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {
                            line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));
                        } else if ((match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/))) {
                            line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));
                        }

                        result += line;
                        pos += line.length;
                        if (pos < len) {
                            result += '\r\n';
                        }
                    }

                    return result;
                },

                /**
                 * Splits a mime encoded string. Needed for dividing mime words into smaller chunks
                 *
                 * @param {String} str Mime encoded string to be split up
                 * @param {Number} maxlen Maximum length of characters for one part (minimum 12)
                 * @return {Array} Split string
                 */
                splitMimeEncodedString: (str, maxlen) => {
                    let curLine,
                        match,
                        chr,
                        done,
                        lines = [];

                    // require at least 12 symbols to fit possible 4 octet UTF-8 sequences
                    maxlen = Math.max(maxlen || 0, 12);

                    while (str.length) {
                        curLine = str.substr(0, maxlen);

                        // move incomplete escaped char back to main
                        if ((match = curLine.match(/[=][0-9A-F]?$/i))) {
                            curLine = curLine.substr(0, match.index);
                        }

                        done = false;
                        while (!done) {
                            done = true;
                            // check if not middle of a unicode char sequence
                            if ((match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i))) {
                                chr = parseInt(match[1], 16);
                                // invalid sequence, move one char back anc recheck
                                if (chr < 0xc2 && chr > 0x7f) {
                                    curLine = curLine.substr(0, curLine.length - 3);
                                    done = false;
                                }
                            }
                        }

                        if (curLine.length) {
                            lines.push(curLine);
                        }
                        str = str.substr(curLine.length);
                    }

                    return lines;
                },

                encodeURICharComponent: chr => {
                    let res = '';
                    let ord = chr.charCodeAt(0).toString(16).toUpperCase();

                    if (ord.length % 2) {
                        ord = '0' + ord;
                    }

                    if (ord.length > 2) {
                        for (let i = 0, len = ord.length / 2; i < len; i++) {
                            res += '%' + ord.substr(i, 2);
                        }
                    } else {
                        res += '%' + ord;
                    }

                    return res;
                },

                safeEncodeURIComponent(str) {
                    str = (str || '').toString();

                    try {
                        // might throw if we try to encode invalid sequences, eg. partial emoji
                        str = encodeURIComponent(str);
                    } catch (E) {
                        // should never run
                        return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, '');
                    }

                    // ensure chars that are not handled by encodeURICompent are converted as well
                    return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, chr => this.encodeURICharComponent(chr));
                }
            };


            /***/
        }),
        /* 104 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.HttpResponse = void 0;

            class HttpResponse {
                constructor(options) {
                    this.statusCode = options.statusCode;
                    this.headers = options.headers || {};
                    this.body = options.body;
                }

                static isInstance(response) {
                    if (!response)
                        return false;
                    const resp = response;
                    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
                }
            }

            exports.HttpResponse = HttpResponse;


            /***/
        }),
        /* 105 */,
        /* 106 */,
        /* 107 */,
        /* 108 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DescribeActiveReceiptRuleSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DescribeActiveReceiptRuleSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DescribeActiveReceiptRuleSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DescribeActiveReceiptRuleSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DescribeActiveReceiptRuleSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDescribeActiveReceiptRuleSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDescribeActiveReceiptRuleSetCommand)(output, context);
                }
            }

            exports.DescribeActiveReceiptRuleSetCommand = DescribeActiveReceiptRuleSetCommand;


            /***/
        }),
        /* 109 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.emitWarningIfUnsupportedVersion = void 0;
            let warningEmitted = false;
            const emitWarningIfUnsupportedVersion = (version) => {
                if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 12) {
                    warningEmitted = true;
                    process.emitWarning(`The AWS SDK for JavaScript (v3) will\n` +
                        `no longer support Node.js ${version} as of January 1, 2022.\n` +
                        `To continue receiving updates to AWS services, bug fixes, and security\n` +
                        `updates please upgrade to Node.js 12.x or later.\n\n` +
                        `More information can be found at: https://a.co/1l6FLnu`, `NodeDeprecationWarning`);
                }
            };
            exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;


            /***/
        }),
        /* 110 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SetIdentityFeedbackForwardingEnabledCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SetIdentityFeedbackForwardingEnabledCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SetIdentityFeedbackForwardingEnabledCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SetIdentityFeedbackForwardingEnabledRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SetIdentityFeedbackForwardingEnabledResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySetIdentityFeedbackForwardingEnabledCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySetIdentityFeedbackForwardingEnabledCommand)(output, context);
                }
            }

            exports.SetIdentityFeedbackForwardingEnabledCommand = SetIdentityFeedbackForwardingEnabledCommand;


            /***/
        }),
        /* 111 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            Object.defineProperty(exports, "v1", {
                enumerable: true,
                get: function () {
                    return _v.default;
                }
            });
            Object.defineProperty(exports, "v3", {
                enumerable: true,
                get: function () {
                    return _v2.default;
                }
            });
            Object.defineProperty(exports, "v4", {
                enumerable: true,
                get: function () {
                    return _v3.default;
                }
            });
            Object.defineProperty(exports, "v5", {
                enumerable: true,
                get: function () {
                    return _v4.default;
                }
            });
            Object.defineProperty(exports, "NIL", {
                enumerable: true,
                get: function () {
                    return _nil.default;
                }
            });
            Object.defineProperty(exports, "version", {
                enumerable: true,
                get: function () {
                    return _version.default;
                }
            });
            Object.defineProperty(exports, "validate", {
                enumerable: true,
                get: function () {
                    return _validate.default;
                }
            });
            Object.defineProperty(exports, "stringify", {
                enumerable: true,
                get: function () {
                    return _stringify.default;
                }
            });
            Object.defineProperty(exports, "parse", {
                enumerable: true,
                get: function () {
                    return _parse.default;
                }
            });

            var _v = _interopRequireDefault(__webpack_require__(30));

            var _v2 = _interopRequireDefault(__webpack_require__(997));

            var _v3 = _interopRequireDefault(__webpack_require__(51));

            var _v4 = _interopRequireDefault(__webpack_require__(887));

            var _nil = _interopRequireDefault(__webpack_require__(771));

            var _version = _interopRequireDefault(__webpack_require__(547));

            var _validate = _interopRequireDefault(__webpack_require__(960));

            var _stringify = _interopRequireDefault(__webpack_require__(993));

            var _parse = _interopRequireDefault(__webpack_require__(527));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            /***/
        }),
        /* 112 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SSO = void 0;
            const GetRoleCredentialsCommand_1 = __webpack_require__(513);
            const ListAccountRolesCommand_1 = __webpack_require__(223);
            const ListAccountsCommand_1 = __webpack_require__(994);
            const LogoutCommand_1 = __webpack_require__(904);
            const SSOClient_1 = __webpack_require__(995);

            class SSO extends SSOClient_1.SSOClient {
                getRoleCredentials(args, optionsOrCb, cb) {
                    const command = new GetRoleCredentialsCommand_1.GetRoleCredentialsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listAccountRoles(args, optionsOrCb, cb) {
                    const command = new ListAccountRolesCommand_1.ListAccountRolesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listAccounts(args, optionsOrCb, cb) {
                    const command = new ListAccountsCommand_1.ListAccountsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                logout(args, optionsOrCb, cb) {
                    const command = new LogoutCommand_1.LogoutCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }
            }

            exports.SSO = SSO;


            /***/
        }),
        /* 113 */,
        /* 114 */,
        /* 115 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteConfigurationSetEventDestinationCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteConfigurationSetEventDestinationCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteConfigurationSetEventDestinationCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteConfigurationSetEventDestinationRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteConfigurationSetEventDestinationResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteConfigurationSetEventDestinationCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteConfigurationSetEventDestinationCommand)(output, context);
                }
            }

            exports.DeleteConfigurationSetEventDestinationCommand = DeleteConfigurationSetEventDestinationCommand;


            /***/
        }),
        /* 116 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.providerConfigFromInit = exports.DEFAULT_MAX_RETRIES = exports.DEFAULT_TIMEOUT = void 0;
            exports.DEFAULT_TIMEOUT = 1000;
            exports.DEFAULT_MAX_RETRIES = 0;
            const providerConfigFromInit = ({
                                                maxRetries = exports.DEFAULT_MAX_RETRIES,
                                                timeout = exports.DEFAULT_TIMEOUT,
                                            }) => ({maxRetries, timeout});
            exports.providerConfigFromInit = providerConfigFromInit;


            /***/
        }),
        /* 117 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            const util = __webpack_require__(176);

            const defaultOptions = {
                allowBooleanAttributes: false, //A tag can have attributes without any value
            };

            const props = ['allowBooleanAttributes'];

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
            exports.validate = function (xmlData, options) {
                options = util.buildOptions(options, defaultOptions, props);

                //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
                //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
                //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
                const tags = [];
                let tagFound = false;

                //indicates that the root tag has been closed (aka. depth 0 has been reached)
                let reachedRoot = false;

                if (xmlData[0] === '\ufeff') {
                    // check for byte order mark (BOM)
                    xmlData = xmlData.substr(1);
                }

                for (let i = 0; i < xmlData.length; i++) {

                    if (xmlData[i] === '<' && xmlData[i + 1] === '?') {
                        i += 2;
                        i = readPI(xmlData, i);
                        if (i.err) return i;
                    } else if (xmlData[i] === '<') {
                        //starting of tag
                        //read until you reach to '>' avoiding any '>' in attribute value

                        i++;

                        if (xmlData[i] === '!') {
                            i = readCommentAndCDATA(xmlData, i);
                            continue;
                        } else {
                            let closingTag = false;
                            if (xmlData[i] === '/') {
                                //closing tag
                                closingTag = true;
                                i++;
                            }
                            //read tagname
                            let tagName = '';
                            for (; i < xmlData.length &&
                                   xmlData[i] !== '>' &&
                                   xmlData[i] !== ' ' &&
                                   xmlData[i] !== '\t' &&
                                   xmlData[i] !== '\n' &&
                                   xmlData[i] !== '\r'; i++
                            ) {
                                tagName += xmlData[i];
                            }
                            tagName = tagName.trim();
                            //console.log(tagName);

                            if (tagName[tagName.length - 1] === '/') {
                                //self closing tag without attributes
                                tagName = tagName.substring(0, tagName.length - 1);
                                //continue;
                                i--;
                            }
                            if (!validateTagName(tagName)) {
                                let msg;
                                if (tagName.trim().length === 0) {
                                    msg = "There is an unnecessary space between tag name and backward slash '</ ..'.";
                                } else {
                                    msg = "Tag '" + tagName + "' is an invalid name.";
                                }
                                return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
                            }

                            const result = readAttributeStr(xmlData, i);
                            if (result === false) {
                                return getErrorObject('InvalidAttr', "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
                            }
                            let attrStr = result.value;
                            i = result.index;

                            if (attrStr[attrStr.length - 1] === '/') {
                                //self closing tag
                                attrStr = attrStr.substring(0, attrStr.length - 1);
                                const isValid = validateAttributeString(attrStr, options);
                                if (isValid === true) {
                                    tagFound = true;
                                    //continue; //text may presents after self closing tag
                                } else {
                                    //the result from the nested function returns the position of the error within the attribute
                                    //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
                                    //this gives us the absolute index in the entire xml, which we can use to find the line at last
                                    return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
                                }
                            } else if (closingTag) {
                                if (!result.tagClosed) {
                                    return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
                                } else if (attrStr.trim().length > 0) {
                                    return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, i));
                                } else {
                                    const otg = tags.pop();
                                    if (tagName !== otg) {
                                        return getErrorObject('InvalidTag', "Closing tag '" + otg + "' is expected inplace of '" + tagName + "'.", getLineNumberForPosition(xmlData, i));
                                    }

                                    //when there are no more tags, we reached the root level.
                                    if (tags.length == 0) {
                                        reachedRoot = true;
                                    }
                                }
                            } else {
                                const isValid = validateAttributeString(attrStr, options);
                                if (isValid !== true) {
                                    //the result from the nested function returns the position of the error within the attribute
                                    //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
                                    //this gives us the absolute index in the entire xml, which we can use to find the line at last
                                    return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
                                }

                                //if the root level has been reached before ...
                                if (reachedRoot === true) {
                                    return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
                                } else {
                                    tags.push(tagName);
                                }
                                tagFound = true;
                            }

                            //skip tag text value
                            //It may include comments and CDATA value
                            for (i++; i < xmlData.length; i++) {
                                if (xmlData[i] === '<') {
                                    if (xmlData[i + 1] === '!') {
                                        //comment or CADATA
                                        i++;
                                        i = readCommentAndCDATA(xmlData, i);
                                        continue;
                                    } else if (xmlData[i + 1] === '?') {
                                        i = readPI(xmlData, ++i);
                                        if (i.err) return i;
                                    } else {
                                        break;
                                    }
                                } else if (xmlData[i] === '&') {
                                    const afterAmp = validateAmpersand(xmlData, i);
                                    if (afterAmp == -1)
                                        return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                                    i = afterAmp;
                                }
                            } //end of reading tag text value
                            if (xmlData[i] === '<') {
                                i--;
                            }
                        }
                    } else {
                        if (xmlData[i] === ' ' || xmlData[i] === '\t' || xmlData[i] === '\n' || xmlData[i] === '\r') {
                            continue;
                        }
                        return getErrorObject('InvalidChar', "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
                    }
                }

                if (!tagFound) {
                    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
                } else if (tags.length > 0) {
                    return getErrorObject('InvalidXml', "Invalid '" + JSON.stringify(tags, null, 4).replace(/\r?\n/g, '') + "' found.", 1);
                }

                return true;
            };

            /**
             * Read Processing insstructions and skip
             * @param {*} xmlData
             * @param {*} i
             */
            function readPI(xmlData, i) {
                var start = i;
                for (; i < xmlData.length; i++) {
                    if (xmlData[i] == '?' || xmlData[i] == ' ') {
                        //tagname
                        var tagname = xmlData.substr(start, i - start);
                        if (i > 5 && tagname === 'xml') {
                            return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
                        } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
                            //check if valid attribut string
                            i++;
                            break;
                        } else {
                            continue;
                        }
                    }
                }
                return i;
            }

            function readCommentAndCDATA(xmlData, i) {
                if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
                    //comment
                    for (i += 3; i < xmlData.length; i++) {
                        if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
                            i += 2;
                            break;
                        }
                    }
                } else if (
                    xmlData.length > i + 8 &&
                    xmlData[i + 1] === 'D' &&
                    xmlData[i + 2] === 'O' &&
                    xmlData[i + 3] === 'C' &&
                    xmlData[i + 4] === 'T' &&
                    xmlData[i + 5] === 'Y' &&
                    xmlData[i + 6] === 'P' &&
                    xmlData[i + 7] === 'E'
                ) {
                    let angleBracketsCount = 1;
                    for (i += 8; i < xmlData.length; i++) {
                        if (xmlData[i] === '<') {
                            angleBracketsCount++;
                        } else if (xmlData[i] === '>') {
                            angleBracketsCount--;
                            if (angleBracketsCount === 0) {
                                break;
                            }
                        }
                    }
                } else if (
                    xmlData.length > i + 9 &&
                    xmlData[i + 1] === '[' &&
                    xmlData[i + 2] === 'C' &&
                    xmlData[i + 3] === 'D' &&
                    xmlData[i + 4] === 'A' &&
                    xmlData[i + 5] === 'T' &&
                    xmlData[i + 6] === 'A' &&
                    xmlData[i + 7] === '['
                ) {
                    for (i += 8; i < xmlData.length; i++) {
                        if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
                            i += 2;
                            break;
                        }
                    }
                }

                return i;
            }

            var doubleQuote = '"';
            var singleQuote = "'";

            /**
             * Keep reading xmlData until '<' is found outside the attribute value.
             * @param {string} xmlData
             * @param {number} i
             */
            function readAttributeStr(xmlData, i) {
                let attrStr = '';
                let startChar = '';
                let tagClosed = false;
                for (; i < xmlData.length; i++) {
                    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
                        if (startChar === '') {
                            startChar = xmlData[i];
                        } else if (startChar !== xmlData[i]) {
                            //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
                            continue;
                        } else {
                            startChar = '';
                        }
                    } else if (xmlData[i] === '>') {
                        if (startChar === '') {
                            tagClosed = true;
                            break;
                        }
                    }
                    attrStr += xmlData[i];
                }
                if (startChar !== '') {
                    return false;
                }

                return {
                    value: attrStr,
                    index: i,
                    tagClosed: tagClosed
                };
            }

            /**
             * Select all the attributes whether valid or invalid.
             */
            const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

            function validateAttributeString(attrStr, options) {
                //console.log("start:"+attrStr+":end");

                //if(attrStr.trim().length === 0) return true; //empty string

                const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
                const attrNames = {};

                for (let i = 0; i < matches.length; i++) {
                    if (matches[i][1].length === 0) {
                        //nospace before attribute name: a="sd"b="saf"
                        return getErrorObject('InvalidAttr', "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(attrStr, matches[i][0]))
                    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
                        //independent attribute: ab
                        return getErrorObject('InvalidAttr', "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(attrStr, matches[i][0]));
                    }
                    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
                    const attrName = matches[i][2];
                    if (!validateAttrName(attrName)) {
                        return getErrorObject('InvalidAttr', "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(attrStr, matches[i][0]));
                    }
                    if (!attrNames.hasOwnProperty(attrName)) {
                        //check for duplicate attribute.
                        attrNames[attrName] = 1;
                    } else {
                        return getErrorObject('InvalidAttr', "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(attrStr, matches[i][0]));
                    }
                }

                return true;
            }

            function validateNumberAmpersand(xmlData, i) {
                let re = /\d/;
                if (xmlData[i] === 'x') {
                    i++;
                    re = /[\da-fA-F]/;
                }
                for (; i < xmlData.length; i++) {
                    if (xmlData[i] === ';')
                        return i;
                    if (!xmlData[i].match(re))
                        break;
                }
                return -1;
            }

            function validateAmpersand(xmlData, i) {
                // https://www.w3.org/TR/xml/#dt-charref
                i++;
                if (xmlData[i] === ';')
                    return -1;
                if (xmlData[i] === '#') {
                    i++;
                    return validateNumberAmpersand(xmlData, i);
                }
                let count = 0;
                for (; i < xmlData.length; i++, count++) {
                    if (xmlData[i].match(/\w/) && count < 20)
                        continue;
                    if (xmlData[i] === ';')
                        break;
                    return -1;
                }
                return i;
            }

            function getErrorObject(code, message, lineNumber) {
                return {
                    err: {
                        code: code,
                        msg: message,
                        line: lineNumber,
                    },
                };
            }

            function validateAttrName(attrName) {
                return util.isName(attrName);
            }

// const startsWithXML = /^xml/i;

            function validateTagName(tagname) {
                return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
            }

//this function returns the line number for the character at the given index
            function getLineNumberForPosition(xmlData, index) {
                var lines = xmlData.substring(0, index).split(/\r?\n/);
                return lines.length;
            }

//this function returns the position of the last character of match within attrStr
            function getPositionFromMatch(attrStr, match) {
                return attrStr.indexOf(match) + match.length;
            }


            /***/
        }),
        /* 118 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(517), exports);
            tslib_1.__exportStar(__webpack_require__(354), exports);
            tslib_1.__exportStar(__webpack_require__(151), exports);
            tslib_1.__exportStar(__webpack_require__(574), exports);
            tslib_1.__exportStar(__webpack_require__(329), exports);


            /***/
        }),
        /* 119 */,
        /* 120 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveRegionConfig = void 0;
            const getRealRegion_1 = __webpack_require__(396);
            const isFipsRegion_1 = __webpack_require__(403);
            const resolveRegionConfig = (input) => {
                const {region, useFipsEndpoint} = input;
                if (!region) {
                    throw new Error("Region is missing");
                }
                return {
                    ...input,
                    region: async () => {
                        if (typeof region === "string") {
                            return (0, getRealRegion_1.getRealRegion)(region);
                        }
                        const providedRegion = await region();
                        return (0, getRealRegion_1.getRealRegion)(providedRegion);
                    },
                    useFipsEndpoint: async () => {
                        const providedRegion = typeof region === "string" ? region : await region();
                        if ((0, isFipsRegion_1.isFipsRegion)(providedRegion)) {
                            return true;
                        }
                        return typeof useFipsEndpoint === "boolean" ? Promise.resolve(useFipsEndpoint) : useFipsEndpoint();
                    },
                };
            };
            exports.resolveRegionConfig = resolveRegionConfig;


            /***/
        }),
        /* 121 */,
        /* 122 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getValueFromTextNode = void 0;
            const getValueFromTextNode = (obj) => {
                const textNodeName = "#text";
                for (const key in obj) {
                    if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
                        obj[key] = obj[key][textNodeName];
                    } else if (typeof obj[key] === "object" && obj[key] !== null) {
                        obj[key] = (0, exports.getValueFromTextNode)(obj[key]);
                    }
                }
                return obj;
            };
            exports.getValueFromTextNode = getValueFromTextNode;


            /***/
        }),
        /* 123 */,
        /* 124 */,
        /* 125 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UpdateTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class UpdateTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "UpdateTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.UpdateTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.UpdateTemplateResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryUpdateTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryUpdateTemplateCommand)(output, context);
                }
            }

            exports.UpdateTemplateCommand = UpdateTemplateCommand;


            /***/
        }),
        /* 126 */,
        /* 127 */,
        /* 128 */,
        /* 129 */
        /***/ (function (module) {

            module.exports = require("child_process");

            /***/
        }),
        /* 130 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.EndpointMode = void 0;
            var EndpointMode;
            (function (EndpointMode) {
                EndpointMode["IPv4"] = "IPv4";
                EndpointMode["IPv6"] = "IPv6";
            })(EndpointMode = exports.EndpointMode || (exports.EndpointMode = {}));


            /***/
        }),
        /* 131 */,
        /* 132 */,
        /* 133 */,
        /* 134 */,
        /* 135 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.decorateServiceException = exports.ServiceException = void 0;

            class ServiceException extends Error {
                constructor(options) {
                    super(options.message);
                    Object.setPrototypeOf(this, ServiceException.prototype);
                    this.name = options.name;
                    this.$fault = options.$fault;
                    this.$metadata = options.$metadata;
                }
            }

            exports.ServiceException = ServiceException;
            const decorateServiceException = (exception, additions = {}) => {
                Object.entries(additions)
                    .filter(([, v]) => v !== undefined)
                    .forEach(([k, v]) => {
                        if (exception[k] == undefined || exception[k] === "") {
                            exception[k] = v;
                        }
                    });
                const message = exception.message || exception.Message || "UnknownError";
                exception.message = message;
                delete exception.Message;
                return exception;
            };
            exports.decorateServiceException = decorateServiceException;


            /***/
        }),
        /* 136 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromContainerMetadata = exports.ENV_CMDS_AUTH_TOKEN = exports.ENV_CMDS_RELATIVE_URI = exports.ENV_CMDS_FULL_URI = void 0;
            const property_provider_1 = __webpack_require__(118);
            const url_1 = __webpack_require__(835);
            const httpRequest_1 = __webpack_require__(214);
            const ImdsCredentials_1 = __webpack_require__(50);
            const RemoteProviderInit_1 = __webpack_require__(116);
            const retry_1 = __webpack_require__(545);
            exports.ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
            exports.ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
            exports.ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
            const fromContainerMetadata = (init = {}) => {
                const {timeout, maxRetries} = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
                return () => (0, retry_1.retry)(async () => {
                    const requestOptions = await getCmdsUri();
                    const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
                    if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
                        throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
                    }
                    return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
                }, maxRetries);
            };
            exports.fromContainerMetadata = fromContainerMetadata;
            const requestFromEcsImds = async (timeout, options) => {
                if (process.env[exports.ENV_CMDS_AUTH_TOKEN]) {
                    options.headers = {
                        ...options.headers,
                        Authorization: process.env[exports.ENV_CMDS_AUTH_TOKEN],
                    };
                }
                const buffer = await (0, httpRequest_1.httpRequest)({
                    ...options,
                    timeout,
                });
                return buffer.toString();
            };
            const CMDS_IP = "169.254.170.2";
            const GREENGRASS_HOSTS = {
                localhost: true,
                "127.0.0.1": true,
            };
            const GREENGRASS_PROTOCOLS = {
                "http:": true,
                "https:": true,
            };
            const getCmdsUri = async () => {
                if (process.env[exports.ENV_CMDS_RELATIVE_URI]) {
                    return {
                        hostname: CMDS_IP,
                        path: process.env[exports.ENV_CMDS_RELATIVE_URI],
                    };
                }
                if (process.env[exports.ENV_CMDS_FULL_URI]) {
                    const parsed = (0, url_1.parse)(process.env[exports.ENV_CMDS_FULL_URI]);
                    if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
                        throw new property_provider_1.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
                    }
                    if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
                        throw new property_provider_1.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
                    }
                    return {
                        ...parsed,
                        port: parsed.port ? parseInt(parsed.port, 10) : undefined,
                    };
                }
                throw new property_provider_1.CredentialsProviderError("The container metadata credential provider cannot be used unless" +
                    ` the ${exports.ENV_CMDS_RELATIVE_URI} or ${exports.ENV_CMDS_FULL_URI} environment` +
                    " variable is set", false);
            };


            /***/
        }),
        /* 137 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.deleteHeader = exports.getHeaderValue = exports.hasHeader = void 0;
            const hasHeader = (soughtHeader, headers) => {
                soughtHeader = soughtHeader.toLowerCase();
                for (const headerName of Object.keys(headers)) {
                    if (soughtHeader === headerName.toLowerCase()) {
                        return true;
                    }
                }
                return false;
            };
            exports.hasHeader = hasHeader;
            const getHeaderValue = (soughtHeader, headers) => {
                soughtHeader = soughtHeader.toLowerCase();
                for (const headerName of Object.keys(headers)) {
                    if (soughtHeader === headerName.toLowerCase()) {
                        return headers[headerName];
                    }
                }
                return undefined;
            };
            exports.getHeaderValue = getHeaderValue;
            const deleteHeader = (soughtHeader, headers) => {
                soughtHeader = soughtHeader.toLowerCase();
                for (const headerName of Object.keys(headers)) {
                    if (soughtHeader === headerName.toLowerCase()) {
                        delete headers[headerName];
                    }
                }
            };
            exports.deleteHeader = deleteHeader;


            /***/
        }),
        /* 138 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(942), exports);
            tslib_1.__exportStar(__webpack_require__(404), exports);
            tslib_1.__exportStar(__webpack_require__(611), exports);
            tslib_1.__exportStar(__webpack_require__(71), exports);
            tslib_1.__exportStar(__webpack_require__(934), exports);
            tslib_1.__exportStar(__webpack_require__(979), exports);
            tslib_1.__exportStar(__webpack_require__(839), exports);
            tslib_1.__exportStar(__webpack_require__(414), exports);


            /***/
        }),
        /* 139 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.deserializeAws_queryGetSessionTokenCommand = exports.deserializeAws_queryGetFederationTokenCommand = exports.deserializeAws_queryGetCallerIdentityCommand = exports.deserializeAws_queryGetAccessKeyInfoCommand = exports.deserializeAws_queryDecodeAuthorizationMessageCommand = exports.deserializeAws_queryAssumeRoleWithWebIdentityCommand = exports.deserializeAws_queryAssumeRoleWithSAMLCommand = exports.deserializeAws_queryAssumeRoleCommand = exports.serializeAws_queryGetSessionTokenCommand = exports.serializeAws_queryGetFederationTokenCommand = exports.serializeAws_queryGetCallerIdentityCommand = exports.serializeAws_queryGetAccessKeyInfoCommand = exports.serializeAws_queryDecodeAuthorizationMessageCommand = exports.serializeAws_queryAssumeRoleWithWebIdentityCommand = exports.serializeAws_queryAssumeRoleWithSAMLCommand = exports.serializeAws_queryAssumeRoleCommand = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const smithy_client_1 = __webpack_require__(449);
            const entities_1 = __webpack_require__(364);
            const fast_xml_parser_1 = __webpack_require__(446);
            const models_0_1 = __webpack_require__(575);
            const STSServiceException_1 = __webpack_require__(838);
            const serializeAws_queryAssumeRoleCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryAssumeRoleRequest(input, context),
                    Action: "AssumeRole",
                    Version: "2011-06-15",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryAssumeRoleCommand = serializeAws_queryAssumeRoleCommand;
            const serializeAws_queryAssumeRoleWithSAMLCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryAssumeRoleWithSAMLRequest(input, context),
                    Action: "AssumeRoleWithSAML",
                    Version: "2011-06-15",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryAssumeRoleWithSAMLCommand = serializeAws_queryAssumeRoleWithSAMLCommand;
            const serializeAws_queryAssumeRoleWithWebIdentityCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryAssumeRoleWithWebIdentityRequest(input, context),
                    Action: "AssumeRoleWithWebIdentity",
                    Version: "2011-06-15",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryAssumeRoleWithWebIdentityCommand = serializeAws_queryAssumeRoleWithWebIdentityCommand;
            const serializeAws_queryDecodeAuthorizationMessageCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDecodeAuthorizationMessageRequest(input, context),
                    Action: "DecodeAuthorizationMessage",
                    Version: "2011-06-15",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDecodeAuthorizationMessageCommand = serializeAws_queryDecodeAuthorizationMessageCommand;
            const serializeAws_queryGetAccessKeyInfoCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetAccessKeyInfoRequest(input, context),
                    Action: "GetAccessKeyInfo",
                    Version: "2011-06-15",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetAccessKeyInfoCommand = serializeAws_queryGetAccessKeyInfoCommand;
            const serializeAws_queryGetCallerIdentityCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetCallerIdentityRequest(input, context),
                    Action: "GetCallerIdentity",
                    Version: "2011-06-15",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetCallerIdentityCommand = serializeAws_queryGetCallerIdentityCommand;
            const serializeAws_queryGetFederationTokenCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetFederationTokenRequest(input, context),
                    Action: "GetFederationToken",
                    Version: "2011-06-15",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetFederationTokenCommand = serializeAws_queryGetFederationTokenCommand;
            const serializeAws_queryGetSessionTokenCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetSessionTokenRequest(input, context),
                    Action: "GetSessionToken",
                    Version: "2011-06-15",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetSessionTokenCommand = serializeAws_queryGetSessionTokenCommand;
            const deserializeAws_queryAssumeRoleCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryAssumeRoleCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryAssumeRoleResponse(data.AssumeRoleResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryAssumeRoleCommand = deserializeAws_queryAssumeRoleCommand;
            const deserializeAws_queryAssumeRoleCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ExpiredTokenException":
                    case "com.amazonaws.sts#ExpiredTokenException":
                        throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
                    case "MalformedPolicyDocumentException":
                    case "com.amazonaws.sts#MalformedPolicyDocumentException":
                        throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
                    case "PackedPolicyTooLargeException":
                    case "com.amazonaws.sts#PackedPolicyTooLargeException":
                        throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
                    case "RegionDisabledException":
                    case "com.amazonaws.sts#RegionDisabledException":
                        throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new STSServiceException_1.STSServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryAssumeRoleWithSAMLCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryAssumeRoleWithSAMLCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryAssumeRoleWithSAMLResponse(data.AssumeRoleWithSAMLResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryAssumeRoleWithSAMLCommand = deserializeAws_queryAssumeRoleWithSAMLCommand;
            const deserializeAws_queryAssumeRoleWithSAMLCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ExpiredTokenException":
                    case "com.amazonaws.sts#ExpiredTokenException":
                        throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
                    case "IDPRejectedClaimException":
                    case "com.amazonaws.sts#IDPRejectedClaimException":
                        throw await deserializeAws_queryIDPRejectedClaimExceptionResponse(parsedOutput, context);
                    case "InvalidIdentityTokenException":
                    case "com.amazonaws.sts#InvalidIdentityTokenException":
                        throw await deserializeAws_queryInvalidIdentityTokenExceptionResponse(parsedOutput, context);
                    case "MalformedPolicyDocumentException":
                    case "com.amazonaws.sts#MalformedPolicyDocumentException":
                        throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
                    case "PackedPolicyTooLargeException":
                    case "com.amazonaws.sts#PackedPolicyTooLargeException":
                        throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
                    case "RegionDisabledException":
                    case "com.amazonaws.sts#RegionDisabledException":
                        throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new STSServiceException_1.STSServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryAssumeRoleWithWebIdentityCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryAssumeRoleWithWebIdentityCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryAssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryAssumeRoleWithWebIdentityCommand = deserializeAws_queryAssumeRoleWithWebIdentityCommand;
            const deserializeAws_queryAssumeRoleWithWebIdentityCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ExpiredTokenException":
                    case "com.amazonaws.sts#ExpiredTokenException":
                        throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
                    case "IDPCommunicationErrorException":
                    case "com.amazonaws.sts#IDPCommunicationErrorException":
                        throw await deserializeAws_queryIDPCommunicationErrorExceptionResponse(parsedOutput, context);
                    case "IDPRejectedClaimException":
                    case "com.amazonaws.sts#IDPRejectedClaimException":
                        throw await deserializeAws_queryIDPRejectedClaimExceptionResponse(parsedOutput, context);
                    case "InvalidIdentityTokenException":
                    case "com.amazonaws.sts#InvalidIdentityTokenException":
                        throw await deserializeAws_queryInvalidIdentityTokenExceptionResponse(parsedOutput, context);
                    case "MalformedPolicyDocumentException":
                    case "com.amazonaws.sts#MalformedPolicyDocumentException":
                        throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
                    case "PackedPolicyTooLargeException":
                    case "com.amazonaws.sts#PackedPolicyTooLargeException":
                        throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
                    case "RegionDisabledException":
                    case "com.amazonaws.sts#RegionDisabledException":
                        throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new STSServiceException_1.STSServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDecodeAuthorizationMessageCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDecodeAuthorizationMessageCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDecodeAuthorizationMessageResponse(data.DecodeAuthorizationMessageResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDecodeAuthorizationMessageCommand = deserializeAws_queryDecodeAuthorizationMessageCommand;
            const deserializeAws_queryDecodeAuthorizationMessageCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidAuthorizationMessageException":
                    case "com.amazonaws.sts#InvalidAuthorizationMessageException":
                        throw await deserializeAws_queryInvalidAuthorizationMessageExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new STSServiceException_1.STSServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetAccessKeyInfoCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetAccessKeyInfoCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetAccessKeyInfoResponse(data.GetAccessKeyInfoResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetAccessKeyInfoCommand = deserializeAws_queryGetAccessKeyInfoCommand;
            const deserializeAws_queryGetAccessKeyInfoCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new STSServiceException_1.STSServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetCallerIdentityCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetCallerIdentityCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetCallerIdentityResponse(data.GetCallerIdentityResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetCallerIdentityCommand = deserializeAws_queryGetCallerIdentityCommand;
            const deserializeAws_queryGetCallerIdentityCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new STSServiceException_1.STSServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetFederationTokenCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetFederationTokenCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetFederationTokenResponse(data.GetFederationTokenResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetFederationTokenCommand = deserializeAws_queryGetFederationTokenCommand;
            const deserializeAws_queryGetFederationTokenCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "MalformedPolicyDocumentException":
                    case "com.amazonaws.sts#MalformedPolicyDocumentException":
                        throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
                    case "PackedPolicyTooLargeException":
                    case "com.amazonaws.sts#PackedPolicyTooLargeException":
                        throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
                    case "RegionDisabledException":
                    case "com.amazonaws.sts#RegionDisabledException":
                        throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new STSServiceException_1.STSServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetSessionTokenCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetSessionTokenCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetSessionTokenResponse(data.GetSessionTokenResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetSessionTokenCommand = deserializeAws_queryGetSessionTokenCommand;
            const deserializeAws_queryGetSessionTokenCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "RegionDisabledException":
                    case "com.amazonaws.sts#RegionDisabledException":
                        throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new STSServiceException_1.STSServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryExpiredTokenExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryExpiredTokenException(body.Error, context);
                const exception = new models_0_1.ExpiredTokenException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryIDPCommunicationErrorExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryIDPCommunicationErrorException(body.Error, context);
                const exception = new models_0_1.IDPCommunicationErrorException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryIDPRejectedClaimExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryIDPRejectedClaimException(body.Error, context);
                const exception = new models_0_1.IDPRejectedClaimException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidAuthorizationMessageExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidAuthorizationMessageException(body.Error, context);
                const exception = new models_0_1.InvalidAuthorizationMessageException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidIdentityTokenExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidIdentityTokenException(body.Error, context);
                const exception = new models_0_1.InvalidIdentityTokenException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryMalformedPolicyDocumentExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryMalformedPolicyDocumentException(body.Error, context);
                const exception = new models_0_1.MalformedPolicyDocumentException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryPackedPolicyTooLargeExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryPackedPolicyTooLargeException(body.Error, context);
                const exception = new models_0_1.PackedPolicyTooLargeException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryRegionDisabledExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryRegionDisabledException(body.Error, context);
                const exception = new models_0_1.RegionDisabledException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const serializeAws_queryAssumeRoleRequest = (input, context) => {
                const entries = {};
                if (input.RoleArn !== undefined && input.RoleArn !== null) {
                    entries["RoleArn"] = input.RoleArn;
                }
                if (input.RoleSessionName !== undefined && input.RoleSessionName !== null) {
                    entries["RoleSessionName"] = input.RoleSessionName;
                }
                if (input.PolicyArns !== undefined && input.PolicyArns !== null) {
                    const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `PolicyArns.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.Policy !== undefined && input.Policy !== null) {
                    entries["Policy"] = input.Policy;
                }
                if (input.DurationSeconds !== undefined && input.DurationSeconds !== null) {
                    entries["DurationSeconds"] = input.DurationSeconds;
                }
                if (input.Tags !== undefined && input.Tags !== null) {
                    const memberEntries = serializeAws_querytagListType(input.Tags, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Tags.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.TransitiveTagKeys !== undefined && input.TransitiveTagKeys !== null) {
                    const memberEntries = serializeAws_querytagKeyListType(input.TransitiveTagKeys, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `TransitiveTagKeys.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ExternalId !== undefined && input.ExternalId !== null) {
                    entries["ExternalId"] = input.ExternalId;
                }
                if (input.SerialNumber !== undefined && input.SerialNumber !== null) {
                    entries["SerialNumber"] = input.SerialNumber;
                }
                if (input.TokenCode !== undefined && input.TokenCode !== null) {
                    entries["TokenCode"] = input.TokenCode;
                }
                if (input.SourceIdentity !== undefined && input.SourceIdentity !== null) {
                    entries["SourceIdentity"] = input.SourceIdentity;
                }
                return entries;
            };
            const serializeAws_queryAssumeRoleWithSAMLRequest = (input, context) => {
                const entries = {};
                if (input.RoleArn !== undefined && input.RoleArn !== null) {
                    entries["RoleArn"] = input.RoleArn;
                }
                if (input.PrincipalArn !== undefined && input.PrincipalArn !== null) {
                    entries["PrincipalArn"] = input.PrincipalArn;
                }
                if (input.SAMLAssertion !== undefined && input.SAMLAssertion !== null) {
                    entries["SAMLAssertion"] = input.SAMLAssertion;
                }
                if (input.PolicyArns !== undefined && input.PolicyArns !== null) {
                    const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `PolicyArns.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.Policy !== undefined && input.Policy !== null) {
                    entries["Policy"] = input.Policy;
                }
                if (input.DurationSeconds !== undefined && input.DurationSeconds !== null) {
                    entries["DurationSeconds"] = input.DurationSeconds;
                }
                return entries;
            };
            const serializeAws_queryAssumeRoleWithWebIdentityRequest = (input, context) => {
                const entries = {};
                if (input.RoleArn !== undefined && input.RoleArn !== null) {
                    entries["RoleArn"] = input.RoleArn;
                }
                if (input.RoleSessionName !== undefined && input.RoleSessionName !== null) {
                    entries["RoleSessionName"] = input.RoleSessionName;
                }
                if (input.WebIdentityToken !== undefined && input.WebIdentityToken !== null) {
                    entries["WebIdentityToken"] = input.WebIdentityToken;
                }
                if (input.ProviderId !== undefined && input.ProviderId !== null) {
                    entries["ProviderId"] = input.ProviderId;
                }
                if (input.PolicyArns !== undefined && input.PolicyArns !== null) {
                    const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `PolicyArns.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.Policy !== undefined && input.Policy !== null) {
                    entries["Policy"] = input.Policy;
                }
                if (input.DurationSeconds !== undefined && input.DurationSeconds !== null) {
                    entries["DurationSeconds"] = input.DurationSeconds;
                }
                return entries;
            };
            const serializeAws_queryDecodeAuthorizationMessageRequest = (input, context) => {
                const entries = {};
                if (input.EncodedMessage !== undefined && input.EncodedMessage !== null) {
                    entries["EncodedMessage"] = input.EncodedMessage;
                }
                return entries;
            };
            const serializeAws_queryGetAccessKeyInfoRequest = (input, context) => {
                const entries = {};
                if (input.AccessKeyId !== undefined && input.AccessKeyId !== null) {
                    entries["AccessKeyId"] = input.AccessKeyId;
                }
                return entries;
            };
            const serializeAws_queryGetCallerIdentityRequest = (input, context) => {
                const entries = {};
                return entries;
            };
            const serializeAws_queryGetFederationTokenRequest = (input, context) => {
                const entries = {};
                if (input.Name !== undefined && input.Name !== null) {
                    entries["Name"] = input.Name;
                }
                if (input.Policy !== undefined && input.Policy !== null) {
                    entries["Policy"] = input.Policy;
                }
                if (input.PolicyArns !== undefined && input.PolicyArns !== null) {
                    const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `PolicyArns.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.DurationSeconds !== undefined && input.DurationSeconds !== null) {
                    entries["DurationSeconds"] = input.DurationSeconds;
                }
                if (input.Tags !== undefined && input.Tags !== null) {
                    const memberEntries = serializeAws_querytagListType(input.Tags, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Tags.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryGetSessionTokenRequest = (input, context) => {
                const entries = {};
                if (input.DurationSeconds !== undefined && input.DurationSeconds !== null) {
                    entries["DurationSeconds"] = input.DurationSeconds;
                }
                if (input.SerialNumber !== undefined && input.SerialNumber !== null) {
                    entries["SerialNumber"] = input.SerialNumber;
                }
                if (input.TokenCode !== undefined && input.TokenCode !== null) {
                    entries["TokenCode"] = input.TokenCode;
                }
                return entries;
            };
            const serializeAws_querypolicyDescriptorListType = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    const memberEntries = serializeAws_queryPolicyDescriptorType(entry, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        entries[`member.${counter}.${key}`] = value;
                    });
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryPolicyDescriptorType = (input, context) => {
                const entries = {};
                if (input.arn !== undefined && input.arn !== null) {
                    entries["arn"] = input.arn;
                }
                return entries;
            };
            const serializeAws_queryTag = (input, context) => {
                const entries = {};
                if (input.Key !== undefined && input.Key !== null) {
                    entries["Key"] = input.Key;
                }
                if (input.Value !== undefined && input.Value !== null) {
                    entries["Value"] = input.Value;
                }
                return entries;
            };
            const serializeAws_querytagKeyListType = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    entries[`member.${counter}`] = entry;
                    counter++;
                }
                return entries;
            };
            const serializeAws_querytagListType = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    const memberEntries = serializeAws_queryTag(entry, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        entries[`member.${counter}.${key}`] = value;
                    });
                    counter++;
                }
                return entries;
            };
            const deserializeAws_queryAssumedRoleUser = (output, context) => {
                const contents = {
                    AssumedRoleId: undefined,
                    Arn: undefined,
                };
                if (output["AssumedRoleId"] !== undefined) {
                    contents.AssumedRoleId = (0, smithy_client_1.expectString)(output["AssumedRoleId"]);
                }
                if (output["Arn"] !== undefined) {
                    contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
                }
                return contents;
            };
            const deserializeAws_queryAssumeRoleResponse = (output, context) => {
                const contents = {
                    Credentials: undefined,
                    AssumedRoleUser: undefined,
                    PackedPolicySize: undefined,
                    SourceIdentity: undefined,
                };
                if (output["Credentials"] !== undefined) {
                    contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
                }
                if (output["AssumedRoleUser"] !== undefined) {
                    contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
                }
                if (output["PackedPolicySize"] !== undefined) {
                    contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
                }
                if (output["SourceIdentity"] !== undefined) {
                    contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
                }
                return contents;
            };
            const deserializeAws_queryAssumeRoleWithSAMLResponse = (output, context) => {
                const contents = {
                    Credentials: undefined,
                    AssumedRoleUser: undefined,
                    PackedPolicySize: undefined,
                    Subject: undefined,
                    SubjectType: undefined,
                    Issuer: undefined,
                    Audience: undefined,
                    NameQualifier: undefined,
                    SourceIdentity: undefined,
                };
                if (output["Credentials"] !== undefined) {
                    contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
                }
                if (output["AssumedRoleUser"] !== undefined) {
                    contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
                }
                if (output["PackedPolicySize"] !== undefined) {
                    contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
                }
                if (output["Subject"] !== undefined) {
                    contents.Subject = (0, smithy_client_1.expectString)(output["Subject"]);
                }
                if (output["SubjectType"] !== undefined) {
                    contents.SubjectType = (0, smithy_client_1.expectString)(output["SubjectType"]);
                }
                if (output["Issuer"] !== undefined) {
                    contents.Issuer = (0, smithy_client_1.expectString)(output["Issuer"]);
                }
                if (output["Audience"] !== undefined) {
                    contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
                }
                if (output["NameQualifier"] !== undefined) {
                    contents.NameQualifier = (0, smithy_client_1.expectString)(output["NameQualifier"]);
                }
                if (output["SourceIdentity"] !== undefined) {
                    contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
                }
                return contents;
            };
            const deserializeAws_queryAssumeRoleWithWebIdentityResponse = (output, context) => {
                const contents = {
                    Credentials: undefined,
                    SubjectFromWebIdentityToken: undefined,
                    AssumedRoleUser: undefined,
                    PackedPolicySize: undefined,
                    Provider: undefined,
                    Audience: undefined,
                    SourceIdentity: undefined,
                };
                if (output["Credentials"] !== undefined) {
                    contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
                }
                if (output["SubjectFromWebIdentityToken"] !== undefined) {
                    contents.SubjectFromWebIdentityToken = (0, smithy_client_1.expectString)(output["SubjectFromWebIdentityToken"]);
                }
                if (output["AssumedRoleUser"] !== undefined) {
                    contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
                }
                if (output["PackedPolicySize"] !== undefined) {
                    contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
                }
                if (output["Provider"] !== undefined) {
                    contents.Provider = (0, smithy_client_1.expectString)(output["Provider"]);
                }
                if (output["Audience"] !== undefined) {
                    contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
                }
                if (output["SourceIdentity"] !== undefined) {
                    contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
                }
                return contents;
            };
            const deserializeAws_queryCredentials = (output, context) => {
                const contents = {
                    AccessKeyId: undefined,
                    SecretAccessKey: undefined,
                    SessionToken: undefined,
                    Expiration: undefined,
                };
                if (output["AccessKeyId"] !== undefined) {
                    contents.AccessKeyId = (0, smithy_client_1.expectString)(output["AccessKeyId"]);
                }
                if (output["SecretAccessKey"] !== undefined) {
                    contents.SecretAccessKey = (0, smithy_client_1.expectString)(output["SecretAccessKey"]);
                }
                if (output["SessionToken"] !== undefined) {
                    contents.SessionToken = (0, smithy_client_1.expectString)(output["SessionToken"]);
                }
                if (output["Expiration"] !== undefined) {
                    contents.Expiration = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["Expiration"]));
                }
                return contents;
            };
            const deserializeAws_queryDecodeAuthorizationMessageResponse = (output, context) => {
                const contents = {
                    DecodedMessage: undefined,
                };
                if (output["DecodedMessage"] !== undefined) {
                    contents.DecodedMessage = (0, smithy_client_1.expectString)(output["DecodedMessage"]);
                }
                return contents;
            };
            const deserializeAws_queryExpiredTokenException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryFederatedUser = (output, context) => {
                const contents = {
                    FederatedUserId: undefined,
                    Arn: undefined,
                };
                if (output["FederatedUserId"] !== undefined) {
                    contents.FederatedUserId = (0, smithy_client_1.expectString)(output["FederatedUserId"]);
                }
                if (output["Arn"] !== undefined) {
                    contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
                }
                return contents;
            };
            const deserializeAws_queryGetAccessKeyInfoResponse = (output, context) => {
                const contents = {
                    Account: undefined,
                };
                if (output["Account"] !== undefined) {
                    contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
                }
                return contents;
            };
            const deserializeAws_queryGetCallerIdentityResponse = (output, context) => {
                const contents = {
                    UserId: undefined,
                    Account: undefined,
                    Arn: undefined,
                };
                if (output["UserId"] !== undefined) {
                    contents.UserId = (0, smithy_client_1.expectString)(output["UserId"]);
                }
                if (output["Account"] !== undefined) {
                    contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
                }
                if (output["Arn"] !== undefined) {
                    contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
                }
                return contents;
            };
            const deserializeAws_queryGetFederationTokenResponse = (output, context) => {
                const contents = {
                    Credentials: undefined,
                    FederatedUser: undefined,
                    PackedPolicySize: undefined,
                };
                if (output["Credentials"] !== undefined) {
                    contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
                }
                if (output["FederatedUser"] !== undefined) {
                    contents.FederatedUser = deserializeAws_queryFederatedUser(output["FederatedUser"], context);
                }
                if (output["PackedPolicySize"] !== undefined) {
                    contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
                }
                return contents;
            };
            const deserializeAws_queryGetSessionTokenResponse = (output, context) => {
                const contents = {
                    Credentials: undefined,
                };
                if (output["Credentials"] !== undefined) {
                    contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
                }
                return contents;
            };
            const deserializeAws_queryIDPCommunicationErrorException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryIDPRejectedClaimException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidAuthorizationMessageException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidIdentityTokenException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryMalformedPolicyDocumentException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryPackedPolicyTooLargeException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryRegionDisabledException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeMetadata = (output) => {
                var _a;
                return ({
                    httpStatusCode: output.statusCode,
                    requestId: (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"],
                    extendedRequestId: output.headers["x-amz-id-2"],
                    cfId: output.headers["x-amz-cf-id"],
                });
            };
            const collectBody = (streamBody = new Uint8Array(), context) => {
                if (streamBody instanceof Uint8Array) {
                    return Promise.resolve(streamBody);
                }
                return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
            };
            const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
            const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
                const {hostname, protocol = "https", port, path: basePath} = await context.endpoint();
                const contents = {
                    protocol,
                    hostname,
                    port,
                    method: "POST",
                    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
                    headers,
                };
                if (resolvedHostname !== undefined) {
                    contents.hostname = resolvedHostname;
                }
                if (body !== undefined) {
                    contents.body = body;
                }
                return new protocol_http_1.HttpRequest(contents);
            };
            const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
                if (encoded.length) {
                    const parsedObj = (0, fast_xml_parser_1.parse)(encoded, {
                        attributeNamePrefix: "",
                        ignoreAttributes: false,
                        parseNodeValue: false,
                        trimValues: false,
                        tagValueProcessor: (val) => (val.trim() === "" && val.includes("\n") ? "" : (0, entities_1.decodeHTML)(val)),
                    });
                    const textNodeName = "#text";
                    const key = Object.keys(parsedObj)[0];
                    const parsedObjToReturn = parsedObj[key];
                    if (parsedObjToReturn[textNodeName]) {
                        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
                        delete parsedObjToReturn[textNodeName];
                    }
                    return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
                }
                return {};
            });
            const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
                .map(([key, value]) => (0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value))
                .join("&");
            const loadQueryErrorCode = (output, data) => {
                if (data.Error.Code !== undefined) {
                    return data.Error.Code;
                }
                if (output.statusCode == 404) {
                    return "NotFound";
                }
                return "";
            };


            /***/
        }),
        /* 140 */,
        /* 141 */,
        /* 142 */,
        /* 143 */,
        /* 144 */,
        /* 145 */
        /***/ (function (module) {

            module.exports = {
                "name": "@aws-sdk/client-ses",
                "description": "AWS SDK for JavaScript Ses Client for Node.js, Browser and React Native",
                "version": "3.56.0",
                "scripts": {
                    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
                    "build:cjs": "tsc -p tsconfig.cjs.json",
                    "build:docs": "typedoc",
                    "build:es": "tsc -p tsconfig.es.json",
                    "build:types": "tsc -p tsconfig.types.json",
                    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
                    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo"
                },
                "main": "./dist-cjs/index.js",
                "types": "./dist-types/index.d.ts",
                "module": "./dist-es/index.js",
                "sideEffects": false,
                "dependencies": {
                    "@aws-crypto/sha256-browser": "2.0.0",
                    "@aws-crypto/sha256-js": "2.0.0",
                    "@aws-sdk/client-sts": "3.56.0",
                    "@aws-sdk/config-resolver": "3.56.0",
                    "@aws-sdk/credential-provider-node": "3.56.0",
                    "@aws-sdk/fetch-http-handler": "3.55.0",
                    "@aws-sdk/hash-node": "3.55.0",
                    "@aws-sdk/invalid-dependency": "3.55.0",
                    "@aws-sdk/middleware-content-length": "3.55.0",
                    "@aws-sdk/middleware-host-header": "3.55.0",
                    "@aws-sdk/middleware-logger": "3.55.0",
                    "@aws-sdk/middleware-retry": "3.56.0",
                    "@aws-sdk/middleware-serde": "3.55.0",
                    "@aws-sdk/middleware-signing": "3.56.0",
                    "@aws-sdk/middleware-stack": "3.55.0",
                    "@aws-sdk/middleware-user-agent": "3.55.0",
                    "@aws-sdk/node-config-provider": "3.56.0",
                    "@aws-sdk/node-http-handler": "3.55.0",
                    "@aws-sdk/protocol-http": "3.55.0",
                    "@aws-sdk/smithy-client": "3.55.0",
                    "@aws-sdk/types": "3.55.0",
                    "@aws-sdk/url-parser": "3.55.0",
                    "@aws-sdk/util-base64-browser": "3.55.0",
                    "@aws-sdk/util-base64-node": "3.55.0",
                    "@aws-sdk/util-body-length-browser": "3.55.0",
                    "@aws-sdk/util-body-length-node": "3.55.0",
                    "@aws-sdk/util-defaults-mode-browser": "3.55.0",
                    "@aws-sdk/util-defaults-mode-node": "3.56.0",
                    "@aws-sdk/util-user-agent-browser": "3.55.0",
                    "@aws-sdk/util-user-agent-node": "3.56.0",
                    "@aws-sdk/util-utf8-browser": "3.55.0",
                    "@aws-sdk/util-utf8-node": "3.55.0",
                    "@aws-sdk/util-waiter": "3.55.0",
                    "entities": "2.2.0",
                    "fast-xml-parser": "3.19.0",
                    "tslib": "^2.3.1"
                },
                "devDependencies": {
                    "@aws-sdk/service-client-documentation-generator": "3.55.0",
                    "@tsconfig/recommended": "1.0.1",
                    "@types/node": "^12.7.5",
                    "concurrently": "7.0.0",
                    "downlevel-dts": "0.7.0",
                    "rimraf": "3.0.2",
                    "typedoc": "0.19.2",
                    "typescript": "~4.6.2"
                },
                "engines": {"node": ">=12.0.0"},
                "typesVersions": {"<4.0": {"dist-types/*": ["dist-types/ts3.4/*"]}},
                "files": ["dist-*"],
                "author": {"name": "AWS SDK for JavaScript Team", "url": "https://aws.amazon.com/javascript/"},
                "license": "Apache-2.0",
                "browser": {"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"},
                "react-native": {"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"},
                "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-ses",
                "repository": {
                    "type": "git",
                    "url": "https://github.com/aws/aws-sdk-js-v3.git",
                    "directory": "clients/client-ses"
                }
            };

            /***/
        }),
        /* 146 */,
        /* 147 */,
        /* 148 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            const util = __webpack_require__(176);

            const convertToJson = function (node, options, parentTagName) {
                const jObj = {};

                // when no child node or attr is present
                if ((!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {
                    return util.isExist(node.val) ? node.val : '';
                }

                // otherwise create a textnode if node has some text
                if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {
                    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName)
                    jObj[options.textNodeName] = asArray ? [node.val] : node.val;
                }

                util.merge(jObj, node.attrsMap, options.arrayMode);

                const keys = Object.keys(node.child);
                for (let index = 0; index < keys.length; index++) {
                    const tagName = keys[index];
                    if (node.child[tagName] && node.child[tagName].length > 1) {
                        jObj[tagName] = [];
                        for (let tag in node.child[tagName]) {
                            if (node.child[tagName].hasOwnProperty(tag)) {
                                jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));
                            }
                        }
                    } else {
                        const result = convertToJson(node.child[tagName][0], options, tagName);
                        const asArray = (options.arrayMode === true && typeof result === 'object') || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);
                        jObj[tagName] = asArray ? [result] : result;
                    }
                }

                //add value
                return jObj;
            };

            exports.convertToJson = convertToJson;


            /***/
        }),
        /* 149 */,
        /* 150 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(672), exports);
            tslib_1.__exportStar(__webpack_require__(330), exports);
            tslib_1.__exportStar(__webpack_require__(546), exports);
            tslib_1.__exportStar(__webpack_require__(864), exports);
            tslib_1.__exportStar(__webpack_require__(788), exports);
            tslib_1.__exportStar(__webpack_require__(194), exports);
            tslib_1.__exportStar(__webpack_require__(448), exports);
            tslib_1.__exportStar(__webpack_require__(253), exports);
            tslib_1.__exportStar(__webpack_require__(554), exports);
            tslib_1.__exportStar(__webpack_require__(602), exports);
            tslib_1.__exportStar(__webpack_require__(115), exports);
            tslib_1.__exportStar(__webpack_require__(812), exports);
            tslib_1.__exportStar(__webpack_require__(425), exports);
            tslib_1.__exportStar(__webpack_require__(251), exports);
            tslib_1.__exportStar(__webpack_require__(384), exports);
            tslib_1.__exportStar(__webpack_require__(186), exports);
            tslib_1.__exportStar(__webpack_require__(184), exports);
            tslib_1.__exportStar(__webpack_require__(711), exports);
            tslib_1.__exportStar(__webpack_require__(908), exports);
            tslib_1.__exportStar(__webpack_require__(954), exports);
            tslib_1.__exportStar(__webpack_require__(108), exports);
            tslib_1.__exportStar(__webpack_require__(322), exports);
            tslib_1.__exportStar(__webpack_require__(227), exports);
            tslib_1.__exportStar(__webpack_require__(369), exports);
            tslib_1.__exportStar(__webpack_require__(455), exports);
            tslib_1.__exportStar(__webpack_require__(444), exports);
            tslib_1.__exportStar(__webpack_require__(68), exports);
            tslib_1.__exportStar(__webpack_require__(871), exports);
            tslib_1.__exportStar(__webpack_require__(861), exports);
            tslib_1.__exportStar(__webpack_require__(391), exports);
            tslib_1.__exportStar(__webpack_require__(370), exports);
            tslib_1.__exportStar(__webpack_require__(998), exports);
            tslib_1.__exportStar(__webpack_require__(156), exports);
            tslib_1.__exportStar(__webpack_require__(756), exports);
            tslib_1.__exportStar(__webpack_require__(91), exports);
            tslib_1.__exportStar(__webpack_require__(458), exports);
            tslib_1.__exportStar(__webpack_require__(843), exports);
            tslib_1.__exportStar(__webpack_require__(836), exports);
            tslib_1.__exportStar(__webpack_require__(90), exports);
            tslib_1.__exportStar(__webpack_require__(100), exports);
            tslib_1.__exportStar(__webpack_require__(62), exports);
            tslib_1.__exportStar(__webpack_require__(395), exports);
            tslib_1.__exportStar(__webpack_require__(991), exports);
            tslib_1.__exportStar(__webpack_require__(641), exports);
            tslib_1.__exportStar(__webpack_require__(6), exports);
            tslib_1.__exportStar(__webpack_require__(46), exports);
            tslib_1.__exportStar(__webpack_require__(10), exports);
            tslib_1.__exportStar(__webpack_require__(651), exports);
            tslib_1.__exportStar(__webpack_require__(77), exports);
            tslib_1.__exportStar(__webpack_require__(577), exports);
            tslib_1.__exportStar(__webpack_require__(907), exports);
            tslib_1.__exportStar(__webpack_require__(86), exports);
            tslib_1.__exportStar(__webpack_require__(462), exports);
            tslib_1.__exportStar(__webpack_require__(110), exports);
            tslib_1.__exportStar(__webpack_require__(398), exports);
            tslib_1.__exportStar(__webpack_require__(976), exports);
            tslib_1.__exportStar(__webpack_require__(649), exports);
            tslib_1.__exportStar(__webpack_require__(926), exports);
            tslib_1.__exportStar(__webpack_require__(916), exports);
            tslib_1.__exportStar(__webpack_require__(166), exports);
            tslib_1.__exportStar(__webpack_require__(309), exports);
            tslib_1.__exportStar(__webpack_require__(224), exports);
            tslib_1.__exportStar(__webpack_require__(42), exports);
            tslib_1.__exportStar(__webpack_require__(501), exports);
            tslib_1.__exportStar(__webpack_require__(375), exports);
            tslib_1.__exportStar(__webpack_require__(754), exports);
            tslib_1.__exportStar(__webpack_require__(125), exports);
            tslib_1.__exportStar(__webpack_require__(9), exports);
            tslib_1.__exportStar(__webpack_require__(811), exports);
            tslib_1.__exportStar(__webpack_require__(970), exports);
            tslib_1.__exportStar(__webpack_require__(412), exports);


            /***/
        }),
        /* 151 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.chain = void 0;
            const ProviderError_1 = __webpack_require__(354);

            function chain(...providers) {
                return () => {
                    let promise = Promise.reject(new ProviderError_1.ProviderError("No providers in chain"));
                    for (const provider of providers) {
                        promise = promise.catch((err) => {
                            if (err === null || err === void 0 ? void 0 : err.tryNextLink) {
                                return provider();
                            }
                            throw err;
                        });
                    }
                    return promise;
                };
            }

            exports.chain = chain;


            /***/
        }),
        /* 152 */,
        /* 153 */,
        /* 154 */,
        /* 155 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SignatureV4 = void 0;
            const util_hex_encoding_1 = __webpack_require__(341);
            const util_middleware_1 = __webpack_require__(552);
            const constants_1 = __webpack_require__(70);
            const credentialDerivation_1 = __webpack_require__(606);
            const getCanonicalHeaders_1 = __webpack_require__(523);
            const getCanonicalQuery_1 = __webpack_require__(833);
            const getPayloadHash_1 = __webpack_require__(642);
            const headerUtil_1 = __webpack_require__(137);
            const moveHeadersToQuery_1 = __webpack_require__(255);
            const prepareRequest_1 = __webpack_require__(728);
            const utilDate_1 = __webpack_require__(816);

            class SignatureV4 {
                constructor({applyChecksum, credentials, region, service, sha256, uriEscapePath = true,}) {
                    this.service = service;
                    this.sha256 = sha256;
                    this.uriEscapePath = uriEscapePath;
                    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
                    this.regionProvider = (0, util_middleware_1.normalizeProvider)(region);
                    this.credentialProvider = (0, util_middleware_1.normalizeProvider)(credentials);
                }

                async presign(originalRequest, options = {}) {
                    const {
                        signingDate = new Date(),
                        expiresIn = 3600,
                        unsignableHeaders,
                        unhoistableHeaders,
                        signableHeaders,
                        signingRegion,
                        signingService,
                    } = options;
                    const credentials = await this.credentialProvider();
                    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
                    const {longDate, shortDate} = formatDate(signingDate);
                    if (expiresIn > constants_1.MAX_PRESIGNED_TTL) {
                        return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
                    }
                    const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
                    const request = (0, moveHeadersToQuery_1.moveHeadersToQuery)((0, prepareRequest_1.prepareRequest)(originalRequest), {unhoistableHeaders});
                    if (credentials.sessionToken) {
                        request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;
                    }
                    request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;
                    request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
                    request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;
                    request.query[constants_1.EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
                    const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
                    request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
                    request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await (0, getPayloadHash_1.getPayloadHash)(originalRequest, this.sha256)));
                    return request;
                }

                async sign(toSign, options) {
                    if (typeof toSign === "string") {
                        return this.signString(toSign, options);
                    } else if (toSign.headers && toSign.payload) {
                        return this.signEvent(toSign, options);
                    } else {
                        return this.signRequest(toSign, options);
                    }
                }

                async signEvent({headers, payload}, {
                    signingDate = new Date(),
                    priorSignature,
                    signingRegion,
                    signingService
                }) {
                    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
                    const {shortDate, longDate} = formatDate(signingDate);
                    const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
                    const hashedPayload = await (0, getPayloadHash_1.getPayloadHash)({
                        headers: {},
                        body: payload
                    }, this.sha256);
                    const hash = new this.sha256();
                    hash.update(headers);
                    const hashedHeaders = (0, util_hex_encoding_1.toHex)(await hash.digest());
                    const stringToSign = [
                        constants_1.EVENT_ALGORITHM_IDENTIFIER,
                        longDate,
                        scope,
                        priorSignature,
                        hashedHeaders,
                        hashedPayload,
                    ].join("\n");
                    return this.signString(stringToSign, {signingDate, signingRegion: region, signingService});
                }

                async signString(stringToSign, {signingDate = new Date(), signingRegion, signingService} = {}) {
                    const credentials = await this.credentialProvider();
                    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
                    const {shortDate} = formatDate(signingDate);
                    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
                    hash.update(stringToSign);
                    return (0, util_hex_encoding_1.toHex)(await hash.digest());
                }

                async signRequest(requestToSign, {
                    signingDate = new Date(),
                    signableHeaders,
                    unsignableHeaders,
                    signingRegion,
                    signingService,
                } = {}) {
                    const credentials = await this.credentialProvider();
                    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
                    const request = (0, prepareRequest_1.prepareRequest)(requestToSign);
                    const {longDate, shortDate} = formatDate(signingDate);
                    const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
                    request.headers[constants_1.AMZ_DATE_HEADER] = longDate;
                    if (credentials.sessionToken) {
                        request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;
                    }
                    const payloadHash = await (0, getPayloadHash_1.getPayloadHash)(request, this.sha256);
                    if (!(0, headerUtil_1.hasHeader)(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {
                        request.headers[constants_1.SHA256_HEADER] = payloadHash;
                    }
                    const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
                    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
                    request.headers[constants_1.AUTH_HEADER] =
                        `${constants_1.ALGORITHM_IDENTIFIER} ` +
                        `Credential=${credentials.accessKeyId}/${scope}, ` +
                        `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +
                        `Signature=${signature}`;
                    return request;
                }

                createCanonicalRequest(request, canonicalHeaders, payloadHash) {
                    const sortedHeaders = Object.keys(canonicalHeaders).sort();
                    return `${request.method}
${this.getCanonicalPath(request)}
${(0, getCanonicalQuery_1.getCanonicalQuery)(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
                }

                async createStringToSign(longDate, credentialScope, canonicalRequest) {
                    const hash = new this.sha256();
                    hash.update(canonicalRequest);
                    const hashedRequest = await hash.digest();
                    return `${constants_1.ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, util_hex_encoding_1.toHex)(hashedRequest)}`;
                }

                getCanonicalPath({path}) {
                    if (this.uriEscapePath) {
                        const normalizedPathSegments = [];
                        for (const pathSegment of path.split("/")) {
                            if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0)
                                continue;
                            if (pathSegment === ".")
                                continue;
                            if (pathSegment === "..") {
                                normalizedPathSegments.pop();
                            } else {
                                normalizedPathSegments.push(pathSegment);
                            }
                        }
                        const normalizedPath = `${(path === null || path === void 0 ? void 0 : path.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path === null || path === void 0 ? void 0 : path.endsWith("/")) ? "/" : ""}`;
                        const doubleEncoded = encodeURIComponent(normalizedPath);
                        return doubleEncoded.replace(/%2F/g, "/");
                    }
                    return path;
                }

                async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
                    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
                    const hash = new this.sha256(await keyPromise);
                    hash.update(stringToSign);
                    return (0, util_hex_encoding_1.toHex)(await hash.digest());
                }

                getSigningKey(credentials, region, shortDate, service) {
                    return (0, credentialDerivation_1.getSigningKey)(this.sha256, credentials, shortDate, region, service || this.service);
                }
            }

            exports.SignatureV4 = SignatureV4;
            const formatDate = (now) => {
                const longDate = (0, utilDate_1.iso8601)(now).replace(/[\-:]/g, "");
                return {
                    longDate,
                    shortDate: longDate.substr(0, 8),
                };
            };
            const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");


            /***/
        }),
        /* 156 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetSendStatisticsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetSendStatisticsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetSendStatisticsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: (input) => input,
                        outputFilterSensitiveLog: models_0_1.GetSendStatisticsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetSendStatisticsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetSendStatisticsCommand)(output, context);
                }
            }

            exports.GetSendStatisticsCommand = GetSendStatisticsCommand;


            /***/
        }),
        /* 157 */,
        /* 158 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

// For internal use, subject to change.
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                Object.defineProperty(o, k2, {
                    enumerable: true, get: function () {
                        return m[k];
                    }
                });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", {enumerable: true, value: v});
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.issueCommand = void 0;
// We use any as a valid input type
            /* eslint-disable @typescript-eslint/no-explicit-any */
            const fs = __importStar(__webpack_require__(747));
            const os = __importStar(__webpack_require__(87));
            const utils_1 = __webpack_require__(14);

            function issueCommand(command, message) {
                const filePath = process.env[`GITHUB_${command}`];
                if (!filePath) {
                    throw new Error(`Unable to find environment variable for file command ${command}`);
                }
                if (!fs.existsSync(filePath)) {
                    throw new Error(`Missing file at path: ${filePath}`);
                }
                fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
                    encoding: 'utf8'
                });
            }

            exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

            /***/
        }),
        /* 159 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.prepareRequest = exports.moveHeadersToQuery = exports.getPayloadHash = exports.getCanonicalQuery = exports.getCanonicalHeaders = void 0;
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(155), exports);
            var getCanonicalHeaders_1 = __webpack_require__(523);
            Object.defineProperty(exports, "getCanonicalHeaders", {
                enumerable: true, get: function () {
                    return getCanonicalHeaders_1.getCanonicalHeaders;
                }
            });
            var getCanonicalQuery_1 = __webpack_require__(833);
            Object.defineProperty(exports, "getCanonicalQuery", {
                enumerable: true, get: function () {
                    return getCanonicalQuery_1.getCanonicalQuery;
                }
            });
            var getPayloadHash_1 = __webpack_require__(642);
            Object.defineProperty(exports, "getPayloadHash", {
                enumerable: true, get: function () {
                    return getPayloadHash_1.getPayloadHash;
                }
            });
            var moveHeadersToQuery_1 = __webpack_require__(255);
            Object.defineProperty(exports, "moveHeadersToQuery", {
                enumerable: true, get: function () {
                    return moveHeadersToQuery_1.moveHeadersToQuery;
                }
            });
            var prepareRequest_1 = __webpack_require__(728);
            Object.defineProperty(exports, "prepareRequest", {
                enumerable: true, get: function () {
                    return prepareRequest_1.prepareRequest;
                }
            });
            tslib_1.__exportStar(__webpack_require__(606), exports);


            /***/
        }),
        /* 160 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            function _interopDefault(ex) {
                return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex;
            }

            var deprecation = __webpack_require__(44);
            var once = _interopDefault(__webpack_require__(646));

            const logOnceCode = once(deprecation => console.warn(deprecation));
            const logOnceHeaders = once(deprecation => console.warn(deprecation));

            /**
             * Error with extra properties to help with debugging
             */

            class RequestError extends Error {
                constructor(message, statusCode, options) {
                    super(message); // Maintains proper stack trace (only available on V8)

                    /* istanbul ignore next */

                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    }

                    this.name = "HttpError";
                    this.status = statusCode;
                    let headers;

                    if ("headers" in options && typeof options.headers !== "undefined") {
                        headers = options.headers;
                    }

                    if ("response" in options) {
                        this.response = options.response;
                        headers = options.response.headers;
                    } // redact request credentials without mutating original request options


                    const requestCopy = Object.assign({}, options.request);

                    if (options.request.headers.authorization) {
                        requestCopy.headers = Object.assign({}, options.request.headers, {
                            authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
                        });
                    }

                    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit
                        // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
                        .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]") // OAuth tokens can be passed as URL query parameters, although it is not recommended
                        // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
                        .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
                    this.request = requestCopy; // deprecations

                    Object.defineProperty(this, "code", {
                        get() {
                            logOnceCode(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
                            return statusCode;
                        }

                    });
                    Object.defineProperty(this, "headers", {
                        get() {
                            logOnceHeaders(new deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
                            return headers || {};
                        }

                    });
                }

            }

            exports.RequestError = RequestError;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 161 */,
        /* 162 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.escapeUri = void 0;
            const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
            exports.escapeUri = escapeUri;
            const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;


            /***/
        }),
        /* 163 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UA_ESCAPE_REGEX = exports.SPACE = exports.X_AMZ_USER_AGENT = exports.USER_AGENT = void 0;
            exports.USER_AGENT = "user-agent";
            exports.X_AMZ_USER_AGENT = "x-amz-user-agent";
            exports.SPACE = " ";
            exports.UA_ESCAPE_REGEX = /[^\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;


            /***/
        }),
        /* 164 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.normalizeConfigFile = void 0;
            const profileKeyRegex = /^profile\s(["'])?([^\1]+)\1$/;
            const normalizeConfigFile = (data) => {
                const map = {};
                for (const key of Object.keys(data)) {
                    let matches;
                    if (key === "default") {
                        map.default = data.default;
                    } else if ((matches = profileKeyRegex.exec(key))) {
                        const [_1, _2, normalizedKey] = matches;
                        if (normalizedKey) {
                            map[normalizedKey] = data[key];
                        }
                    }
                }
                return map;
            };
            exports.normalizeConfigFile = normalizeConfigFile;


            /***/
        }),
        /* 165 */,
        /* 166 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UpdateAccountSendingEnabledCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class UpdateAccountSendingEnabledCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "UpdateAccountSendingEnabledCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.UpdateAccountSendingEnabledRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryUpdateAccountSendingEnabledCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryUpdateAccountSendingEnabledCommand)(output, context);
                }
            }

            exports.UpdateAccountSendingEnabledCommand = UpdateAccountSendingEnabledCommand;


            /***/
        }),
        /* 167 */,
        /* 168 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DEFAULT_RETRY_MODE = exports.DEFAULT_MAX_ATTEMPTS = exports.RETRY_MODES = void 0;
            var RETRY_MODES;
            (function (RETRY_MODES) {
                RETRY_MODES["STANDARD"] = "standard";
                RETRY_MODES["ADAPTIVE"] = "adaptive";
            })(RETRY_MODES = exports.RETRY_MODES || (exports.RETRY_MODES = {}));
            exports.DEFAULT_MAX_ATTEMPTS = 3;
            exports.DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;


            /***/
        }),
        /* 169 */,
        /* 170 */
        /***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            function _interopDefault(ex) {
                return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex;
            }

            var Stream = _interopDefault(__webpack_require__(413));
            var http = _interopDefault(__webpack_require__(605));
            var Url = _interopDefault(__webpack_require__(835));
            var whatwgUrl = _interopDefault(__webpack_require__(335));
            var https = _interopDefault(__webpack_require__(211));
            var zlib = _interopDefault(__webpack_require__(761));

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
            const Readable = Stream.Readable;

            const BUFFER = Symbol('buffer');
            const TYPE = Symbol('type');

            class Blob {
                constructor() {
                    this[TYPE] = '';

                    const blobParts = arguments[0];
                    const options = arguments[1];

                    const buffers = [];
                    let size = 0;

                    if (blobParts) {
                        const a = blobParts;
                        const length = Number(a.length);
                        for (let i = 0; i < length; i++) {
                            const element = a[i];
                            let buffer;
                            if (element instanceof Buffer) {
                                buffer = element;
                            } else if (ArrayBuffer.isView(element)) {
                                buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                            } else if (element instanceof ArrayBuffer) {
                                buffer = Buffer.from(element);
                            } else if (element instanceof Blob) {
                                buffer = element[BUFFER];
                            } else {
                                buffer = Buffer.from(typeof element === 'string' ? element : String(element));
                            }
                            size += buffer.length;
                            buffers.push(buffer);
                        }
                    }

                    this[BUFFER] = Buffer.concat(buffers);

                    let type = options && options.type !== undefined && String(options.type).toLowerCase();
                    if (type && !/[^\u0020-\u007E]/.test(type)) {
                        this[TYPE] = type;
                    }
                }

                get size() {
                    return this[BUFFER].length;
                }

                get type() {
                    return this[TYPE];
                }

                text() {
                    return Promise.resolve(this[BUFFER].toString());
                }

                arrayBuffer() {
                    const buf = this[BUFFER];
                    const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                    return Promise.resolve(ab);
                }

                stream() {
                    const readable = new Readable();
                    readable._read = function () {
                    };
                    readable.push(this[BUFFER]);
                    readable.push(null);
                    return readable;
                }

                toString() {
                    return '[object Blob]';
                }

                slice() {
                    const size = this.size;

                    const start = arguments[0];
                    const end = arguments[1];
                    let relativeStart, relativeEnd;
                    if (start === undefined) {
                        relativeStart = 0;
                    } else if (start < 0) {
                        relativeStart = Math.max(size + start, 0);
                    } else {
                        relativeStart = Math.min(start, size);
                    }
                    if (end === undefined) {
                        relativeEnd = size;
                    } else if (end < 0) {
                        relativeEnd = Math.max(size + end, 0);
                    } else {
                        relativeEnd = Math.min(end, size);
                    }
                    const span = Math.max(relativeEnd - relativeStart, 0);

                    const buffer = this[BUFFER];
                    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
                    const blob = new Blob([], {type: arguments[2]});
                    blob[BUFFER] = slicedBuffer;
                    return blob;
                }
            }

            Object.defineProperties(Blob.prototype, {
                size: {enumerable: true},
                type: {enumerable: true},
                slice: {enumerable: true}
            });

            Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
                value: 'Blob',
                writable: false,
                enumerable: false,
                configurable: true
            });

            /**
             * fetch-error.js
             *
             * FetchError interface for operational errors
             */

            /**
             * Create FetchError instance
             *
             * @param   String      message      Error message for human
             * @param   String      type         Error type for machine
             * @param   String      systemError  For Node.js system error
             * @return  FetchError
             */
            function FetchError(message, type, systemError) {
                Error.call(this, message);

                this.message = message;
                this.type = type;

                // when err.type is `system`, err.code contains system error code
                if (systemError) {
                    this.code = this.errno = systemError.code;
                }

                // hide custom error implementation details from end-users
                Error.captureStackTrace(this, this.constructor);
            }

            FetchError.prototype = Object.create(Error.prototype);
            FetchError.prototype.constructor = FetchError;
            FetchError.prototype.name = 'FetchError';

            let convert;
            try {
                convert = __webpack_require__(613).convert;
            } catch (e) {
            }

            const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
            const PassThrough = Stream.PassThrough;

            /**
             * Body mixin
             *
             * Ref: https://fetch.spec.whatwg.org/#body
             *
             * @param   Stream  body  Readable stream
             * @param   Object  opts  Response options
             * @return  Void
             */
            function Body(body) {
                var _this = this;

                var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                    _ref$size = _ref.size;

                let size = _ref$size === undefined ? 0 : _ref$size;
                var _ref$timeout = _ref.timeout;
                let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

                if (body == null) {
                    // body is undefined or null
                    body = null;
                } else if (isURLSearchParams(body)) {
                    // body is a URLSearchParams
                    body = Buffer.from(body.toString());
                } else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
                    // body is ArrayBuffer
                    body = Buffer.from(body);
                } else if (ArrayBuffer.isView(body)) {
                    // body is ArrayBufferView
                    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
                } else if (body instanceof Stream) ; else {
                    // none of the above
                    // coerce to string then buffer
                    body = Buffer.from(String(body));
                }
                this[INTERNALS] = {
                    body,
                    disturbed: false,
                    error: null
                };
                this.size = size;
                this.timeout = timeout;

                if (body instanceof Stream) {
                    body.on('error', function (err) {
                        const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
                        _this[INTERNALS].error = error;
                    });
                }
            }

            Body.prototype = {
                get body() {
                    return this[INTERNALS].body;
                },

                get bodyUsed() {
                    return this[INTERNALS].disturbed;
                },

                /**
                 * Decode response as ArrayBuffer
                 *
                 * @return  Promise
                 */
                arrayBuffer() {
                    return consumeBody.call(this).then(function (buf) {
                        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                    });
                },

                /**
                 * Return raw response as Blob
                 *
                 * @return Promise
                 */
                blob() {
                    let ct = this.headers && this.headers.get('content-type') || '';
                    return consumeBody.call(this).then(function (buf) {
                        return Object.assign(
                            // Prevent copying
                            new Blob([], {
                                type: ct.toLowerCase()
                            }), {
                                [BUFFER]: buf
                            });
                    });
                },

                /**
                 * Decode response as json
                 *
                 * @return  Promise
                 */
                json() {
                    var _this2 = this;

                    return consumeBody.call(this).then(function (buffer) {
                        try {
                            return JSON.parse(buffer.toString());
                        } catch (err) {
                            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
                        }
                    });
                },

                /**
                 * Decode response as text
                 *
                 * @return  Promise
                 */
                text() {
                    return consumeBody.call(this).then(function (buffer) {
                        return buffer.toString();
                    });
                },

                /**
                 * Decode response as buffer (non-spec api)
                 *
                 * @return  Promise
                 */
                buffer() {
                    return consumeBody.call(this);
                },

                /**
                 * Decode response as text, while automatically detecting the encoding and
                 * trying to decode to UTF-8 (non-spec api)
                 *
                 * @return  Promise
                 */
                textConverted() {
                    var _this3 = this;

                    return consumeBody.call(this).then(function (buffer) {
                        return convertBody(buffer, _this3.headers);
                    });
                }
            };

// In browsers, all properties are enumerable.
            Object.defineProperties(Body.prototype, {
                body: {enumerable: true},
                bodyUsed: {enumerable: true},
                arrayBuffer: {enumerable: true},
                blob: {enumerable: true},
                json: {enumerable: true},
                text: {enumerable: true}
            });

            Body.mixIn = function (proto) {
                for (const name of Object.getOwnPropertyNames(Body.prototype)) {
                    // istanbul ignore else: future proof
                    if (!(name in proto)) {
                        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
                        Object.defineProperty(proto, name, desc);
                    }
                }
            };

            /**
             * Consume and convert an entire Body to a Buffer.
             *
             * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
             *
             * @return  Promise
             */
            function consumeBody() {
                var _this4 = this;

                if (this[INTERNALS].disturbed) {
                    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
                }

                this[INTERNALS].disturbed = true;

                if (this[INTERNALS].error) {
                    return Body.Promise.reject(this[INTERNALS].error);
                }

                let body = this.body;

                // body is null
                if (body === null) {
                    return Body.Promise.resolve(Buffer.alloc(0));
                }

                // body is blob
                if (isBlob(body)) {
                    body = body.stream();
                }

                // body is buffer
                if (Buffer.isBuffer(body)) {
                    return Body.Promise.resolve(body);
                }

                // istanbul ignore if: should never happen
                if (!(body instanceof Stream)) {
                    return Body.Promise.resolve(Buffer.alloc(0));
                }

                // body is stream
                // get ready to actually consume the body
                let accum = [];
                let accumBytes = 0;
                let abort = false;

                return new Body.Promise(function (resolve, reject) {
                    let resTimeout;

                    // allow timeout on slow response body
                    if (_this4.timeout) {
                        resTimeout = setTimeout(function () {
                            abort = true;
                            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
                        }, _this4.timeout);
                    }

                    // handle stream errors
                    body.on('error', function (err) {
                        if (err.name === 'AbortError') {
                            // if the request was aborted, reject with this Error
                            abort = true;
                            reject(err);
                        } else {
                            // other errors, such as incorrect content-encoding
                            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
                        }
                    });

                    body.on('data', function (chunk) {
                        if (abort || chunk === null) {
                            return;
                        }

                        if (_this4.size && accumBytes + chunk.length > _this4.size) {
                            abort = true;
                            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                            return;
                        }

                        accumBytes += chunk.length;
                        accum.push(chunk);
                    });

                    body.on('end', function () {
                        if (abort) {
                            return;
                        }

                        clearTimeout(resTimeout);

                        try {
                            resolve(Buffer.concat(accum, accumBytes));
                        } catch (err) {
                            // handle streams that have accumulated too much data (issue #414)
                            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
                        }
                    });
                });
            }

            /**
             * Detect buffer encoding and convert to target encoding
             * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
             *
             * @param   Buffer  buffer    Incoming buffer
             * @param   String  encoding  Target encoding
             * @return  String
             */
            function convertBody(buffer, headers) {
                if (typeof convert !== 'function') {
                    throw new Error('The package `encoding` must be installed to use the textConverted() function');
                }

                const ct = headers.get('content-type');
                let charset = 'utf-8';
                let res, str;

                // header
                if (ct) {
                    res = /charset=([^;]*)/i.exec(ct);
                }

                // no charset in content type, peek at response body for at most 1024 bytes
                str = buffer.slice(0, 1024).toString();

                // html5
                if (!res && str) {
                    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
                }

                // html4
                if (!res && str) {
                    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
                    if (!res) {
                        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
                        if (res) {
                            res.pop(); // drop last quote
                        }
                    }

                    if (res) {
                        res = /charset=(.*)/i.exec(res.pop());
                    }
                }

                // xml
                if (!res && str) {
                    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
                }

                // found charset
                if (res) {
                    charset = res.pop();

                    // prevent decode issues when sites use incorrect encoding
                    // ref: https://hsivonen.fi/encoding-menu/
                    if (charset === 'gb2312' || charset === 'gbk') {
                        charset = 'gb18030';
                    }
                }

                // turn raw buffers into a single utf-8 buffer
                return convert(buffer, 'UTF-8', charset).toString();
            }

            /**
             * Detect a URLSearchParams object
             * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
             *
             * @param   Object  obj     Object to detect by type or brand
             * @return  String
             */
            function isURLSearchParams(obj) {
                // Duck-typing as a necessary condition.
                if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
                    return false;
                }

                // Brand-checking and more duck-typing as optional condition.
                return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
            }

            /**
             * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
             * @param  {*} obj
             * @return {boolean}
             */
            function isBlob(obj) {
                return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
            }

            /**
             * Clone body given Res/Req instance
             *
             * @param   Mixed  instance  Response or Request instance
             * @return  Mixed
             */
            function clone(instance) {
                let p1, p2;
                let body = instance.body;

                // don't allow cloning a used body
                if (instance.bodyUsed) {
                    throw new Error('cannot clone body after it is used');
                }

                // check that body is a stream and not form-data object
                // note: we can't clone the form-data object without having it as a dependency
                if (body instanceof Stream && typeof body.getBoundary !== 'function') {
                    // tee instance body
                    p1 = new PassThrough();
                    p2 = new PassThrough();
                    body.pipe(p1);
                    body.pipe(p2);
                    // set instance body to teed body and return the other teed body
                    instance[INTERNALS].body = p1;
                    body = p2;
                }

                return body;
            }

            /**
             * Performs the operation "extract a `Content-Type` value from |object|" as
             * specified in the specification:
             * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
             *
             * This function assumes that instance.body is present.
             *
             * @param   Mixed  instance  Any options.body input
             */
            function extractContentType(body) {
                if (body === null) {
                    // body is null
                    return null;
                } else if (typeof body === 'string') {
                    // body is string
                    return 'text/plain;charset=UTF-8';
                } else if (isURLSearchParams(body)) {
                    // body is a URLSearchParams
                    return 'application/x-www-form-urlencoded;charset=UTF-8';
                } else if (isBlob(body)) {
                    // body is blob
                    return body.type || null;
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    return null;
                } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
                    // body is ArrayBuffer
                    return null;
                } else if (ArrayBuffer.isView(body)) {
                    // body is ArrayBufferView
                    return null;
                } else if (typeof body.getBoundary === 'function') {
                    // detect form data input from form-data module
                    return `multipart/form-data;boundary=${body.getBoundary()}`;
                } else if (body instanceof Stream) {
                    // body is stream
                    // can't really do much about this
                    return null;
                } else {
                    // Body constructor defaults other things to string
                    return 'text/plain;charset=UTF-8';
                }
            }

            /**
             * The Fetch Standard treats this as if "total bytes" is a property on the body.
             * For us, we have to explicitly get it with a function.
             *
             * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
             *
             * @param   Body    instance   Instance of Body
             * @return  Number?            Number of bytes, or null if not possible
             */
            function getTotalBytes(instance) {
                const body = instance.body;


                if (body === null) {
                    // body is null
                    return 0;
                } else if (isBlob(body)) {
                    return body.size;
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    return body.length;
                } else if (body && typeof body.getLengthSync === 'function') {
                    // detect form data input from form-data module
                    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
                        body.hasKnownLength && body.hasKnownLength()) {
                        // 2.x
                        return body.getLengthSync();
                    }
                    return null;
                } else {
                    // body is stream
                    return null;
                }
            }

            /**
             * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
             *
             * @param   Body    instance   Instance of Body
             * @return  Void
             */
            function writeToStream(dest, instance) {
                const body = instance.body;


                if (body === null) {
                    // body is null
                    dest.end();
                } else if (isBlob(body)) {
                    body.stream().pipe(dest);
                } else if (Buffer.isBuffer(body)) {
                    // body is buffer
                    dest.write(body);
                    dest.end();
                } else {
                    // body is stream
                    body.pipe(dest);
                }
            }

// expose Promise
            Body.Promise = global.Promise;

            /**
             * headers.js
             *
             * Headers class offers convenient helpers
             */

            const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
            const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

            function validateName(name) {
                name = `${name}`;
                if (invalidTokenRegex.test(name) || name === '') {
                    throw new TypeError(`${name} is not a legal HTTP header name`);
                }
            }

            function validateValue(value) {
                value = `${value}`;
                if (invalidHeaderCharRegex.test(value)) {
                    throw new TypeError(`${value} is not a legal HTTP header value`);
                }
            }

            /**
             * Find the key in the map object given a header name.
             *
             * Returns undefined if not found.
             *
             * @param   String  name  Header name
             * @return  String|Undefined
             */
            function find(map, name) {
                name = name.toLowerCase();
                for (const key in map) {
                    if (key.toLowerCase() === name) {
                        return key;
                    }
                }
                return undefined;
            }

            const MAP = Symbol('map');

            class Headers {
                /**
                 * Headers class
                 *
                 * @param   Object  headers  Response headers
                 * @return  Void
                 */
                constructor() {
                    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

                    this[MAP] = Object.create(null);

                    if (init instanceof Headers) {
                        const rawHeaders = init.raw();
                        const headerNames = Object.keys(rawHeaders);

                        for (const headerName of headerNames) {
                            for (const value of rawHeaders[headerName]) {
                                this.append(headerName, value);
                            }
                        }

                        return;
                    }

                    // We don't worry about converting prop to ByteString here as append()
                    // will handle it.
                    if (init == null) ; else if (typeof init === 'object') {
                        const method = init[Symbol.iterator];
                        if (method != null) {
                            if (typeof method !== 'function') {
                                throw new TypeError('Header pairs must be iterable');
                            }

                            // sequence<sequence<ByteString>>
                            // Note: per spec we have to first exhaust the lists then process them
                            const pairs = [];
                            for (const pair of init) {
                                if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
                                    throw new TypeError('Each header pair must be iterable');
                                }
                                pairs.push(Array.from(pair));
                            }

                            for (const pair of pairs) {
                                if (pair.length !== 2) {
                                    throw new TypeError('Each header pair must be a name/value tuple');
                                }
                                this.append(pair[0], pair[1]);
                            }
                        } else {
                            // record<ByteString, ByteString>
                            for (const key of Object.keys(init)) {
                                const value = init[key];
                                this.append(key, value);
                            }
                        }
                    } else {
                        throw new TypeError('Provided initializer must be an object');
                    }
                }

                /**
                 * Return combined header value given name
                 *
                 * @param   String  name  Header name
                 * @return  Mixed
                 */
                get(name) {
                    name = `${name}`;
                    validateName(name);
                    const key = find(this[MAP], name);
                    if (key === undefined) {
                        return null;
                    }

                    return this[MAP][key].join(', ');
                }

                /**
                 * Iterate over all headers
                 *
                 * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
                 * @param   Boolean   thisArg   `this` context for callback function
                 * @return  Void
                 */
                forEach(callback) {
                    let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

                    let pairs = getHeaders(this);
                    let i = 0;
                    while (i < pairs.length) {
                        var _pairs$i = pairs[i];
                        const name = _pairs$i[0],
                            value = _pairs$i[1];

                        callback.call(thisArg, value, name, this);
                        pairs = getHeaders(this);
                        i++;
                    }
                }

                /**
                 * Overwrite header values given name
                 *
                 * @param   String  name   Header name
                 * @param   String  value  Header value
                 * @return  Void
                 */
                set(name, value) {
                    name = `${name}`;
                    value = `${value}`;
                    validateName(name);
                    validateValue(value);
                    const key = find(this[MAP], name);
                    this[MAP][key !== undefined ? key : name] = [value];
                }

                /**
                 * Append a value onto existing header
                 *
                 * @param   String  name   Header name
                 * @param   String  value  Header value
                 * @return  Void
                 */
                append(name, value) {
                    name = `${name}`;
                    value = `${value}`;
                    validateName(name);
                    validateValue(value);
                    const key = find(this[MAP], name);
                    if (key !== undefined) {
                        this[MAP][key].push(value);
                    } else {
                        this[MAP][name] = [value];
                    }
                }

                /**
                 * Check for header name existence
                 *
                 * @param   String   name  Header name
                 * @return  Boolean
                 */
                has(name) {
                    name = `${name}`;
                    validateName(name);
                    return find(this[MAP], name) !== undefined;
                }

                /**
                 * Delete all header values given name
                 *
                 * @param   String  name  Header name
                 * @return  Void
                 */
                delete(name) {
                    name = `${name}`;
                    validateName(name);
                    const key = find(this[MAP], name);
                    if (key !== undefined) {
                        delete this[MAP][key];
                    }
                }

                /**
                 * Return raw headers (non-spec api)
                 *
                 * @return  Object
                 */
                raw() {
                    return this[MAP];
                }

                /**
                 * Get an iterator on keys.
                 *
                 * @return  Iterator
                 */
                keys() {
                    return createHeadersIterator(this, 'key');
                }

                /**
                 * Get an iterator on values.
                 *
                 * @return  Iterator
                 */
                values() {
                    return createHeadersIterator(this, 'value');
                }

                /**
                 * Get an iterator on entries.
                 *
                 * This is the default iterator of the Headers object.
                 *
                 * @return  Iterator
                 */
                [Symbol.iterator]() {
                    return createHeadersIterator(this, 'key+value');
                }
            }

            Headers.prototype.entries = Headers.prototype[Symbol.iterator];

            Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
                value: 'Headers',
                writable: false,
                enumerable: false,
                configurable: true
            });

            Object.defineProperties(Headers.prototype, {
                get: {enumerable: true},
                forEach: {enumerable: true},
                set: {enumerable: true},
                append: {enumerable: true},
                has: {enumerable: true},
                delete: {enumerable: true},
                keys: {enumerable: true},
                values: {enumerable: true},
                entries: {enumerable: true}
            });

            function getHeaders(headers) {
                let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

                const keys = Object.keys(headers[MAP]).sort();
                return keys.map(kind === 'key' ? function (k) {
                    return k.toLowerCase();
                } : kind === 'value' ? function (k) {
                    return headers[MAP][k].join(', ');
                } : function (k) {
                    return [k.toLowerCase(), headers[MAP][k].join(', ')];
                });
            }

            const INTERNAL = Symbol('internal');

            function createHeadersIterator(target, kind) {
                const iterator = Object.create(HeadersIteratorPrototype);
                iterator[INTERNAL] = {
                    target,
                    kind,
                    index: 0
                };
                return iterator;
            }

            const HeadersIteratorPrototype = Object.setPrototypeOf({
                next() {
                    // istanbul ignore if
                    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
                        throw new TypeError('Value of `this` is not a HeadersIterator');
                    }

                    var _INTERNAL = this[INTERNAL];
                    const target = _INTERNAL.target,
                        kind = _INTERNAL.kind,
                        index = _INTERNAL.index;

                    const values = getHeaders(target, kind);
                    const len = values.length;
                    if (index >= len) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }

                    this[INTERNAL].index = index + 1;

                    return {
                        value: values[index],
                        done: false
                    };
                }
            }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

            Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
                value: 'HeadersIterator',
                writable: false,
                enumerable: false,
                configurable: true
            });

            /**
             * Export the Headers object in a form that Node.js can consume.
             *
             * @param   Headers  headers
             * @return  Object
             */
            function exportNodeCompatibleHeaders(headers) {
                const obj = Object.assign({__proto__: null}, headers[MAP]);

                // http.request() only supports string as Host header. This hack makes
                // specifying custom Host header possible.
                const hostHeaderKey = find(headers[MAP], 'Host');
                if (hostHeaderKey !== undefined) {
                    obj[hostHeaderKey] = obj[hostHeaderKey][0];
                }

                return obj;
            }

            /**
             * Create a Headers object from an object of headers, ignoring those that do
             * not conform to HTTP grammar productions.
             *
             * @param   Object  obj  Object of headers
             * @return  Headers
             */
            function createHeadersLenient(obj) {
                const headers = new Headers();
                for (const name of Object.keys(obj)) {
                    if (invalidTokenRegex.test(name)) {
                        continue;
                    }
                    if (Array.isArray(obj[name])) {
                        for (const val of obj[name]) {
                            if (invalidHeaderCharRegex.test(val)) {
                                continue;
                            }
                            if (headers[MAP][name] === undefined) {
                                headers[MAP][name] = [val];
                            } else {
                                headers[MAP][name].push(val);
                            }
                        }
                    } else if (!invalidHeaderCharRegex.test(obj[name])) {
                        headers[MAP][name] = [obj[name]];
                    }
                }
                return headers;
            }

            const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
            const STATUS_CODES = http.STATUS_CODES;

            /**
             * Response class
             *
             * @param   Stream  body  Readable stream
             * @param   Object  opts  Response options
             * @return  Void
             */
            class Response {
                constructor() {
                    let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                    Body.call(this, body, opts);

                    const status = opts.status || 200;
                    const headers = new Headers(opts.headers);

                    if (body != null && !headers.has('Content-Type')) {
                        const contentType = extractContentType(body);
                        if (contentType) {
                            headers.append('Content-Type', contentType);
                        }
                    }

                    this[INTERNALS$1] = {
                        url: opts.url,
                        status,
                        statusText: opts.statusText || STATUS_CODES[status],
                        headers,
                        counter: opts.counter
                    };
                }

                get url() {
                    return this[INTERNALS$1].url || '';
                }

                get status() {
                    return this[INTERNALS$1].status;
                }

                /**
                 * Convenience property representing if the request ended normally
                 */
                get ok() {
                    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
                }

                get redirected() {
                    return this[INTERNALS$1].counter > 0;
                }

                get statusText() {
                    return this[INTERNALS$1].statusText;
                }

                get headers() {
                    return this[INTERNALS$1].headers;
                }

                /**
                 * Clone this response
                 *
                 * @return  Response
                 */
                clone() {
                    return new Response(clone(this), {
                        url: this.url,
                        status: this.status,
                        statusText: this.statusText,
                        headers: this.headers,
                        ok: this.ok,
                        redirected: this.redirected
                    });
                }
            }

            Body.mixIn(Response.prototype);

            Object.defineProperties(Response.prototype, {
                url: {enumerable: true},
                status: {enumerable: true},
                ok: {enumerable: true},
                redirected: {enumerable: true},
                statusText: {enumerable: true},
                headers: {enumerable: true},
                clone: {enumerable: true}
            });

            Object.defineProperty(Response.prototype, Symbol.toStringTag, {
                value: 'Response',
                writable: false,
                enumerable: false,
                configurable: true
            });

            const INTERNALS$2 = Symbol('Request internals');
            const URL = Url.URL || whatwgUrl.URL;

// fix an issue where "format", "parse" aren't a named export for node <10
            const parse_url = Url.parse;
            const format_url = Url.format;

            /**
             * Wrapper around `new URL` to handle arbitrary URLs
             *
             * @param  {string} urlStr
             * @return {void}
             */
            function parseURL(urlStr) {
                /*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */
                if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
                    urlStr = new URL(urlStr).toString();
                }

                // Fallback to old implementation for arbitrary URLs
                return parse_url(urlStr);
            }

            const streamDestructionSupported = 'destroy' in Stream.Readable.prototype;

            /**
             * Check if a value is an instance of Request.
             *
             * @param   Mixed   input
             * @return  Boolean
             */
            function isRequest(input) {
                return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
            }

            function isAbortSignal(signal) {
                const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
                return !!(proto && proto.constructor.name === 'AbortSignal');
            }

            /**
             * Request class
             *
             * @param   Mixed   input  Url or Request instance
             * @param   Object  init   Custom options
             * @return  Void
             */
            class Request {
                constructor(input) {
                    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                    let parsedURL;

                    // normalize input
                    if (!isRequest(input)) {
                        if (input && input.href) {
                            // in order to support Node.js' Url objects; though WHATWG's URL objects
                            // will fall into this branch also (since their `toString()` will return
                            // `href` property anyway)
                            parsedURL = parseURL(input.href);
                        } else {
                            // coerce input to a string before attempting to parse
                            parsedURL = parseURL(`${input}`);
                        }
                        input = {};
                    } else {
                        parsedURL = parseURL(input.url);
                    }

                    let method = init.method || input.method || 'GET';
                    method = method.toUpperCase();

                    if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
                        throw new TypeError('Request with GET/HEAD method cannot have body');
                    }

                    let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

                    Body.call(this, inputBody, {
                        timeout: init.timeout || input.timeout || 0,
                        size: init.size || input.size || 0
                    });

                    const headers = new Headers(init.headers || input.headers || {});

                    if (inputBody != null && !headers.has('Content-Type')) {
                        const contentType = extractContentType(inputBody);
                        if (contentType) {
                            headers.append('Content-Type', contentType);
                        }
                    }

                    let signal = isRequest(input) ? input.signal : null;
                    if ('signal' in init) signal = init.signal;

                    if (signal != null && !isAbortSignal(signal)) {
                        throw new TypeError('Expected signal to be an instanceof AbortSignal');
                    }

                    this[INTERNALS$2] = {
                        method,
                        redirect: init.redirect || input.redirect || 'follow',
                        headers,
                        parsedURL,
                        signal
                    };

                    // node-fetch-only options
                    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
                    this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
                    this.counter = init.counter || input.counter || 0;
                    this.agent = init.agent || input.agent;
                }

                get method() {
                    return this[INTERNALS$2].method;
                }

                get url() {
                    return format_url(this[INTERNALS$2].parsedURL);
                }

                get headers() {
                    return this[INTERNALS$2].headers;
                }

                get redirect() {
                    return this[INTERNALS$2].redirect;
                }

                get signal() {
                    return this[INTERNALS$2].signal;
                }

                /**
                 * Clone this request
                 *
                 * @return  Request
                 */
                clone() {
                    return new Request(this);
                }
            }

            Body.mixIn(Request.prototype);

            Object.defineProperty(Request.prototype, Symbol.toStringTag, {
                value: 'Request',
                writable: false,
                enumerable: false,
                configurable: true
            });

            Object.defineProperties(Request.prototype, {
                method: {enumerable: true},
                url: {enumerable: true},
                headers: {enumerable: true},
                redirect: {enumerable: true},
                clone: {enumerable: true},
                signal: {enumerable: true}
            });

            /**
             * Convert a Request to Node.js http request options.
             *
             * @param   Request  A Request instance
             * @return  Object   The options object to be passed to http.request
             */
            function getNodeRequestOptions(request) {
                const parsedURL = request[INTERNALS$2].parsedURL;
                const headers = new Headers(request[INTERNALS$2].headers);

                // fetch step 1.3
                if (!headers.has('Accept')) {
                    headers.set('Accept', '*/*');
                }

                // Basic fetch
                if (!parsedURL.protocol || !parsedURL.hostname) {
                    throw new TypeError('Only absolute URLs are supported');
                }

                if (!/^https?:$/.test(parsedURL.protocol)) {
                    throw new TypeError('Only HTTP(S) protocols are supported');
                }

                if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
                    throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
                }

                // HTTP-network-or-cache fetch steps 2.4-2.7
                let contentLengthValue = null;
                if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
                    contentLengthValue = '0';
                }
                if (request.body != null) {
                    const totalBytes = getTotalBytes(request);
                    if (typeof totalBytes === 'number') {
                        contentLengthValue = String(totalBytes);
                    }
                }
                if (contentLengthValue) {
                    headers.set('Content-Length', contentLengthValue);
                }

                // HTTP-network-or-cache fetch step 2.11
                if (!headers.has('User-Agent')) {
                    headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
                }

                // HTTP-network-or-cache fetch step 2.15
                if (request.compress && !headers.has('Accept-Encoding')) {
                    headers.set('Accept-Encoding', 'gzip,deflate');
                }

                let agent = request.agent;
                if (typeof agent === 'function') {
                    agent = agent(parsedURL);
                }

                if (!headers.has('Connection') && !agent) {
                    headers.set('Connection', 'close');
                }

                // HTTP-network fetch step 4.2
                // chunked encoding is handled by Node.js

                return Object.assign({}, parsedURL, {
                    method: request.method,
                    headers: exportNodeCompatibleHeaders(headers),
                    agent
                });
            }

            /**
             * abort-error.js
             *
             * AbortError interface for cancelled requests
             */

            /**
             * Create AbortError instance
             *
             * @param   String      message      Error message for human
             * @return  AbortError
             */
            function AbortError(message) {
                Error.call(this, message);

                this.type = 'aborted';
                this.message = message;

                // hide custom error implementation details from end-users
                Error.captureStackTrace(this, this.constructor);
            }

            AbortError.prototype = Object.create(Error.prototype);
            AbortError.prototype.constructor = AbortError;
            AbortError.prototype.name = 'AbortError';

            const URL$1 = Url.URL || whatwgUrl.URL;

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
            const PassThrough$1 = Stream.PassThrough;

            const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
                const orig = new URL$1(original).hostname;
                const dest = new URL$1(destination).hostname;

                return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
            };

            /**
             * Fetch function
             *
             * @param   Mixed    url   Absolute url or Request instance
             * @param   Object   opts  Fetch options
             * @return  Promise
             */
            function fetch(url, opts) {

                // allow custom promise
                if (!fetch.Promise) {
                    throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
                }

                Body.Promise = fetch.Promise;

                // wrap http.request into fetch
                return new fetch.Promise(function (resolve, reject) {
                    // build request object
                    const request = new Request(url, opts);
                    const options = getNodeRequestOptions(request);

                    const send = (options.protocol === 'https:' ? https : http).request;
                    const signal = request.signal;

                    let response = null;

                    const abort = function abort() {
                        let error = new AbortError('The user aborted a request.');
                        reject(error);
                        if (request.body && request.body instanceof Stream.Readable) {
                            request.body.destroy(error);
                        }
                        if (!response || !response.body) return;
                        response.body.emit('error', error);
                    };

                    if (signal && signal.aborted) {
                        abort();
                        return;
                    }

                    const abortAndFinalize = function abortAndFinalize() {
                        abort();
                        finalize();
                    };

                    // send request
                    const req = send(options);
                    let reqTimeout;

                    if (signal) {
                        signal.addEventListener('abort', abortAndFinalize);
                    }

                    function finalize() {
                        req.abort();
                        if (signal) signal.removeEventListener('abort', abortAndFinalize);
                        clearTimeout(reqTimeout);
                    }

                    if (request.timeout) {
                        req.once('socket', function (socket) {
                            reqTimeout = setTimeout(function () {
                                reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                                finalize();
                            }, request.timeout);
                        });
                    }

                    req.on('error', function (err) {
                        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
                        finalize();
                    });

                    req.on('response', function (res) {
                        clearTimeout(reqTimeout);

                        const headers = createHeadersLenient(res.headers);

                        // HTTP fetch step 5
                        if (fetch.isRedirect(res.statusCode)) {
                            // HTTP fetch step 5.2
                            const location = headers.get('Location');

                            // HTTP fetch step 5.3
                            let locationURL = null;
                            try {
                                locationURL = location === null ? null : new URL$1(location, request.url).toString();
                            } catch (err) {
                                // error here can only be invalid URL in Location: header
                                // do not throw when options.redirect == manual
                                // let the user extract the errorneous redirect URL
                                if (request.redirect !== 'manual') {
                                    reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                                    finalize();
                                    return;
                                }
                            }

                            // HTTP fetch step 5.5
                            switch (request.redirect) {
                                case 'error':
                                    reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                                    finalize();
                                    return;
                                case 'manual':
                                    // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                                    if (locationURL !== null) {
                                        // handle corrupted header
                                        try {
                                            headers.set('Location', locationURL);
                                        } catch (err) {
                                            // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                            reject(err);
                                        }
                                    }
                                    break;
                                case 'follow':
                                    // HTTP-redirect fetch step 2
                                    if (locationURL === null) {
                                        break;
                                    }

                                    // HTTP-redirect fetch step 5
                                    if (request.counter >= request.follow) {
                                        reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                                        finalize();
                                        return;
                                    }

                                    // HTTP-redirect fetch step 6 (counter increment)
                                    // Create a new Request object.
                                    const requestOpts = {
                                        headers: new Headers(request.headers),
                                        follow: request.follow,
                                        counter: request.counter + 1,
                                        agent: request.agent,
                                        compress: request.compress,
                                        method: request.method,
                                        body: request.body,
                                        signal: request.signal,
                                        timeout: request.timeout,
                                        size: request.size
                                    };

                                    if (!isDomainOrSubdomain(request.url, locationURL)) {
                                        for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
                                            requestOpts.headers.delete(name);
                                        }
                                    }

                                    // HTTP-redirect fetch step 9
                                    if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                                        reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                                        finalize();
                                        return;
                                    }

                                    // HTTP-redirect fetch step 11
                                    if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
                                        requestOpts.method = 'GET';
                                        requestOpts.body = undefined;
                                        requestOpts.headers.delete('content-length');
                                    }

                                    // HTTP-redirect fetch step 15
                                    resolve(fetch(new Request(locationURL, requestOpts)));
                                    finalize();
                                    return;
                            }
                        }

                        // prepare response
                        res.once('end', function () {
                            if (signal) signal.removeEventListener('abort', abortAndFinalize);
                        });
                        let body = res.pipe(new PassThrough$1());

                        const response_options = {
                            url: request.url,
                            status: res.statusCode,
                            statusText: res.statusMessage,
                            headers: headers,
                            size: request.size,
                            timeout: request.timeout,
                            counter: request.counter
                        };

                        // HTTP-network fetch step 12.1.1.3
                        const codings = headers.get('Content-Encoding');

                        // HTTP-network fetch step 12.1.1.4: handle content codings

                        // in following scenarios we ignore compression support
                        // 1. compression support is disabled
                        // 2. HEAD request
                        // 3. no Content-Encoding header
                        // 4. no content response (204)
                        // 5. content not modified response (304)
                        if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // For Node v6+
                        // Be less strict when decoding compressed responses, since sometimes
                        // servers send slightly invalid responses that are still accepted
                        // by common browsers.
                        // Always using Z_SYNC_FLUSH is what cURL does.
                        const zlibOptions = {
                            flush: zlib.Z_SYNC_FLUSH,
                            finishFlush: zlib.Z_SYNC_FLUSH
                        };

                        // for gzip
                        if (codings == 'gzip' || codings == 'x-gzip') {
                            body = body.pipe(zlib.createGunzip(zlibOptions));
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // for deflate
                        if (codings == 'deflate' || codings == 'x-deflate') {
                            // handle the infamous raw deflate response from old servers
                            // a hack for old IIS and Apache servers
                            const raw = res.pipe(new PassThrough$1());
                            raw.once('data', function (chunk) {
                                // see http://stackoverflow.com/questions/37519828
                                if ((chunk[0] & 0x0F) === 0x08) {
                                    body = body.pipe(zlib.createInflate());
                                } else {
                                    body = body.pipe(zlib.createInflateRaw());
                                }
                                response = new Response(body, response_options);
                                resolve(response);
                            });
                            return;
                        }

                        // for br
                        if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
                            body = body.pipe(zlib.createBrotliDecompress());
                            response = new Response(body, response_options);
                            resolve(response);
                            return;
                        }

                        // otherwise, use response as-is
                        response = new Response(body, response_options);
                        resolve(response);
                    });

                    writeToStream(req, request);
                });
            }

            /**
             * Redirect code matching
             *
             * @param   Number   code  Status code
             * @return  Boolean
             */
            fetch.isRedirect = function (code) {
                return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
            };

// expose Promise
            fetch.Promise = global.Promise;

            module.exports = exports = fetch;
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.default = exports;
            exports.Headers = Headers;
            exports.Request = Request;
            exports.Response = Response;
            exports.FetchError = FetchError;


            /***/
        }),
        /* 171 */,
        /* 172 */,
        /* 173 */,
        /* 174 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const packageData = __webpack_require__(786);
            const shared = __webpack_require__(190);

            /**
             * Generates a Transport object to generate JSON output
             *
             * @constructor
             * @param {Object} optional config parameter
             */
            class JSONTransport {
                constructor(options) {
                    options = options || {};

                    this.options = options || {};

                    this.name = 'JSONTransport';
                    this.version = packageData.version;

                    this.logger = shared.getLogger(this.options, {
                        component: this.options.component || 'json-transport'
                    });
                }

                /**
                 * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
                 *
                 * @param {Object} emailMessage MailComposer object
                 * @param {Function} callback Callback function to run when the sending is completed
                 */
                send(mail, done) {
                    // Sendmail strips this header line by itself
                    mail.message.keepBcc = true;

                    let envelope = mail.data.envelope || mail.message.getEnvelope();
                    let messageId = mail.message.messageId();

                    let recipients = [].concat(envelope.to || []);
                    if (recipients.length > 3) {
                        recipients.push('...and ' + recipients.splice(2).length + ' more');
                    }
                    this.logger.info(
                        {
                            tnx: 'send',
                            messageId
                        },
                        'Composing JSON structure of %s to <%s>',
                        messageId,
                        recipients.join(', ')
                    );

                    setImmediate(() => {
                        mail.normalize((err, data) => {
                            if (err) {
                                this.logger.error(
                                    {
                                        err,
                                        tnx: 'send',
                                        messageId
                                    },
                                    'Failed building JSON structure for %s. %s',
                                    messageId,
                                    err.message
                                );
                                return done(err);
                            }

                            delete data.envelope;
                            delete data.normalizedHeaders;

                            return done(null, {
                                envelope,
                                messageId,
                                message: this.options.skipEncoding ? data : JSON.stringify(data)
                            });
                        });
                    });
                }
            }

            module.exports = JSONTransport;


            /***/
        }),
        /* 175 */,
        /* 176 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
            const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
            const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
            const regexName = new RegExp('^' + nameRegexp + '$');

            const getAllMatches = function (string, regex) {
                const matches = [];
                let match = regex.exec(string);
                while (match) {
                    const allmatches = [];
                    const len = match.length;
                    for (let index = 0; index < len; index++) {
                        allmatches.push(match[index]);
                    }
                    matches.push(allmatches);
                    match = regex.exec(string);
                }
                return matches;
            };

            const isName = function (string) {
                const match = regexName.exec(string);
                return !(match === null || typeof match === 'undefined');
            };

            exports.isExist = function (v) {
                return typeof v !== 'undefined';
            };

            exports.isEmptyObject = function (obj) {
                return Object.keys(obj).length === 0;
            };

            /**
             * Copy all the properties of a into b.
             * @param {*} target
             * @param {*} a
             */
            exports.merge = function (target, a, arrayMode) {
                if (a) {
                    const keys = Object.keys(a); // will return an array of own properties
                    const len = keys.length; //don't make it inline
                    for (let i = 0; i < len; i++) {
                        if (arrayMode === 'strict') {
                            target[keys[i]] = [a[keys[i]]];
                        } else {
                            target[keys[i]] = a[keys[i]];
                        }
                    }
                }
            };
            /* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

            exports.getValue = function (v) {
                if (exports.isExist(v)) {
                    return v;
                } else {
                    return '';
                }
            };

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

            exports.buildOptions = function (options, defaultOptions, props) {
                var newOptions = {};
                if (!options) {
                    return defaultOptions; //if there are not options
                }

                for (let i = 0; i < props.length; i++) {
                    if (options[props[i]] !== undefined) {
                        newOptions[props[i]] = options[props[i]];
                    } else {
                        newOptions[props[i]] = defaultOptions[props[i]];
                    }
                }
                return newOptions;
            };

            /**
             * Check if a tag name should be treated as array
             *
             * @param tagName the node tagname
             * @param arrayMode the array mode option
             * @param parentTagName the parent tag name
             * @returns {boolean} true if node should be parsed as array
             */
            exports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {
                if (arrayMode === false) {
                    return false;
                } else if (arrayMode instanceof RegExp) {
                    return arrayMode.test(tagName);
                } else if (typeof arrayMode === 'function') {
                    return !!arrayMode(tagName, parentTagName);
                }

                return arrayMode === "strict";
            }

            exports.isName = isName;
            exports.getAllMatches = getAllMatches;
            exports.nameRegexp = nameRegexp;


            /***/
        }),
        /* 177 */,
        /* 178 */,
        /* 179 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.Collector = void 0;
            const stream_1 = __webpack_require__(413);

            class Collector extends stream_1.Writable {
                constructor() {
                    super(...arguments);
                    this.bufferedBytes = [];
                }

                _write(chunk, encoding, callback) {
                    this.bufferedBytes.push(chunk);
                    callback();
                }
            }

            exports.Collector = Collector;


            /***/
        }),
        /* 180 */,
        /* 181 */,
        /* 182 */,
        /* 183 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveSsoCredentials = exports.isSsoProfile = void 0;
            const credential_provider_sso_1 = __webpack_require__(321);
            var credential_provider_sso_2 = __webpack_require__(321);
            Object.defineProperty(exports, "isSsoProfile", {
                enumerable: true, get: function () {
                    return credential_provider_sso_2.isSsoProfile;
                }
            });
            const resolveSsoCredentials = (data) => {
                const {
                    sso_start_url,
                    sso_account_id,
                    sso_region,
                    sso_role_name
                } = (0, credential_provider_sso_1.validateSsoProfile)(data);
                return (0, credential_provider_sso_1.fromSSO)({
                    ssoStartUrl: sso_start_url,
                    ssoAccountId: sso_account_id,
                    ssoRegion: sso_region,
                    ssoRoleName: sso_role_name,
                })();
            };
            exports.resolveSsoCredentials = resolveSsoCredentials;


            /***/
        }),
        /* 184 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteReceiptRuleCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteReceiptRuleCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteReceiptRuleCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteReceiptRuleRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteReceiptRuleResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteReceiptRuleCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteReceiptRuleCommand)(output, context);
                }
            }

            exports.DeleteReceiptRuleCommand = DeleteReceiptRuleCommand;


            /***/
        }),
        /* 185 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.StandardRetryStrategy = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const service_error_classification_1 = __webpack_require__(868);
            const uuid_1 = __webpack_require__(111);
            const config_1 = __webpack_require__(168);
            const constants_1 = __webpack_require__(581);
            const defaultRetryQuota_1 = __webpack_require__(488);
            const delayDecider_1 = __webpack_require__(625);
            const retryDecider_1 = __webpack_require__(225);

            class StandardRetryStrategy {
                constructor(maxAttemptsProvider, options) {
                    var _a, _b, _c;
                    this.maxAttemptsProvider = maxAttemptsProvider;
                    this.mode = config_1.RETRY_MODES.STANDARD;
                    this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : retryDecider_1.defaultRetryDecider;
                    this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : delayDecider_1.defaultDelayDecider;
                    this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : (0, defaultRetryQuota_1.getDefaultRetryQuota)(constants_1.INITIAL_RETRY_TOKENS);
                }

                shouldRetry(error, attempts, maxAttempts) {
                    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
                }

                async getMaxAttempts() {
                    let maxAttempts;
                    try {
                        maxAttempts = await this.maxAttemptsProvider();
                    } catch (error) {
                        maxAttempts = config_1.DEFAULT_MAX_ATTEMPTS;
                    }
                    return maxAttempts;
                }

                async retry(next, args, options) {
                    let retryTokenAmount;
                    let attempts = 0;
                    let totalDelay = 0;
                    const maxAttempts = await this.getMaxAttempts();
                    const {request} = args;
                    if (protocol_http_1.HttpRequest.isInstance(request)) {
                        request.headers[constants_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
                    }
                    while (true) {
                        try {
                            if (protocol_http_1.HttpRequest.isInstance(request)) {
                                request.headers[constants_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                            }
                            if (options === null || options === void 0 ? void 0 : options.beforeRequest) {
                                await options.beforeRequest();
                            }
                            const {response, output} = await next(args);
                            if (options === null || options === void 0 ? void 0 : options.afterRequest) {
                                options.afterRequest(response);
                            }
                            this.retryQuota.releaseRetryTokens(retryTokenAmount);
                            output.$metadata.attempts = attempts + 1;
                            output.$metadata.totalRetryDelay = totalDelay;
                            return {response, output};
                        } catch (e) {
                            const err = asSdkError(e);
                            attempts++;
                            if (this.shouldRetry(err, attempts, maxAttempts)) {
                                retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
                                const delay = this.delayDecider((0, service_error_classification_1.isThrottlingError)(err) ? constants_1.THROTTLING_RETRY_DELAY_BASE : constants_1.DEFAULT_RETRY_DELAY_BASE, attempts);
                                totalDelay += delay;
                                await new Promise((resolve) => setTimeout(resolve, delay));
                                continue;
                            }
                            if (!err.$metadata) {
                                err.$metadata = {};
                            }
                            err.$metadata.attempts = attempts;
                            err.$metadata.totalRetryDelay = totalDelay;
                            throw err;
                        }
                    }
                }
            }

            exports.StandardRetryStrategy = StandardRetryStrategy;
            const asSdkError = (error) => {
                if (error instanceof Error)
                    return error;
                if (error instanceof Object)
                    return Object.assign(new Error(), error);
                if (typeof error === "string")
                    return new Error(error);
                return new Error(`AWS SDK error wrapper for ${error}`);
            };


            /***/
        }),
        /* 186 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteReceiptFilterCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteReceiptFilterCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteReceiptFilterCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteReceiptFilterRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteReceiptFilterResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteReceiptFilterCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteReceiptFilterCommand)(output, context);
                }
            }

            exports.DeleteReceiptFilterCommand = DeleteReceiptFilterCommand;


            /***/
        }),
        /* 187 */,
        /* 188 */,
        /* 189 */,
        /* 190 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";
            /* eslint no-console: 0 */


            const urllib = __webpack_require__(835);
            const util = __webpack_require__(669);
            const fs = __webpack_require__(747);
            const fetch = __webpack_require__(204);
            const dns = __webpack_require__(881);
            const net = __webpack_require__(631);
            const os = __webpack_require__(87);

            const DNS_TTL = 5 * 60 * 1000;

            const networkInterfaces = (module.exports.networkInterfaces = os.networkInterfaces());

            const resolver = (family, hostname, callback) => {
                const familySupported =
                    // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6
                    Object.keys(networkInterfaces)
                        .map(key => networkInterfaces[key])
                        // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)
                        .reduce((acc, val) => acc.concat(val), [])
                        .filter(i => !i.internal)
                        .filter(i => i.family === 'IPv' + family).length > 0;

                if (!familySupported) {
                    return callback(null, []);
                }

                dns['resolve' + family](hostname, (err, addresses) => {
                    if (err) {
                        switch (err.code) {
                            case dns.NODATA:
                            case dns.NOTFOUND:
                            case dns.NOTIMP:
                            case dns.SERVFAIL:
                            case dns.CONNREFUSED:
                            case 'EAI_AGAIN':
                                return callback(null, []);
                        }
                        return callback(err);
                    }
                    return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
                });
            };

            const dnsCache = (module.exports.dnsCache = new Map());

            const formatDNSValue = (value, extra) => {
                if (!value) {
                    return Object.assign({}, extra || {});
                }

                return Object.assign(
                    {
                        servername: value.servername,
                        host:
                            !value.addresses || !value.addresses.length
                                ? null
                                : value.addresses.length === 1
                                    ? value.addresses[0]
                                    : value.addresses[Math.floor(Math.random() * value.addresses.length)]
                    },
                    extra || {}
                );
            };

            module.exports.resolveHostname = (options, callback) => {
                options = options || {};

                if (!options.host && options.servername) {
                    options.host = options.servername;
                }

                if (!options.host || net.isIP(options.host)) {
                    // nothing to do here
                    let value = {
                        addresses: [options.host],
                        servername: options.servername || false
                    };
                    return callback(
                        null,
                        formatDNSValue(value, {
                            cached: false
                        })
                    );
                }

                let cached;

                if (dnsCache.has(options.host)) {
                    cached = dnsCache.get(options.host);
                    if (!cached.expires || cached.expires >= Date.now()) {
                        return callback(
                            null,
                            formatDNSValue(cached.value, {
                                cached: true
                            })
                        );
                    }
                }

                resolver(4, options.host, (err, addresses) => {
                    if (err) {
                        if (cached) {
                            // ignore error, use expired value
                            return callback(
                                null,
                                formatDNSValue(cached.value, {
                                    cached: true,
                                    error: err
                                })
                            );
                        }
                        return callback(err);
                    }

                    if (addresses && addresses.length) {
                        let value = {
                            addresses,
                            servername: options.servername || options.host
                        };

                        dnsCache.set(options.host, {
                            value,
                            expires: Date.now() + DNS_TTL
                        });

                        return callback(
                            null,
                            formatDNSValue(value, {
                                cached: false
                            })
                        );
                    }

                    resolver(6, options.host, (err, addresses) => {
                        if (err) {
                            if (cached) {
                                // ignore error, use expired value
                                return callback(
                                    null,
                                    formatDNSValue(cached.value, {
                                        cached: true,
                                        error: err
                                    })
                                );
                            }
                            return callback(err);
                        }

                        if (addresses && addresses.length) {
                            let value = {
                                addresses,
                                servername: options.servername || options.host
                            };

                            dnsCache.set(options.host, {
                                value,
                                expires: Date.now() + DNS_TTL
                            });

                            return callback(
                                null,
                                formatDNSValue(value, {
                                    cached: false
                                })
                            );
                        }

                        try {
                            dns.lookup(options.host, {}, (err, address) => {
                                if (err) {
                                    if (cached) {
                                        // ignore error, use expired value
                                        return callback(
                                            null,
                                            formatDNSValue(cached.value, {
                                                cached: true,
                                                error: err
                                            })
                                        );
                                    }
                                    return callback(err);
                                }

                                if (!address && cached) {
                                    // nothing was found, fallback to cached value
                                    return callback(
                                        null,
                                        formatDNSValue(cached.value, {
                                            cached: true
                                        })
                                    );
                                }

                                let value = {
                                    addresses: address ? [address] : [options.host],
                                    servername: options.servername || options.host
                                };

                                dnsCache.set(options.host, {
                                    value,
                                    expires: Date.now() + DNS_TTL
                                });

                                return callback(
                                    null,
                                    formatDNSValue(value, {
                                        cached: false
                                    })
                                );
                            });
                        } catch (err) {
                            if (cached) {
                                // ignore error, use expired value
                                return callback(
                                    null,
                                    formatDNSValue(cached.value, {
                                        cached: true,
                                        error: err
                                    })
                                );
                            }
                            return callback(err);
                        }
                    });
                });
            };
            /**
             * Parses connection url to a structured configuration object
             *
             * @param {String} str Connection url
             * @return {Object} Configuration object
             */
            module.exports.parseConnectionUrl = str => {
                str = str || '';
                let options = {};

                [urllib.parse(str, true)].forEach(url => {
                    let auth;

                    switch (url.protocol) {
                        case 'smtp:':
                            options.secure = false;
                            break;
                        case 'smtps:':
                            options.secure = true;
                            break;
                        case 'direct:':
                            options.direct = true;
                            break;
                    }

                    if (!isNaN(url.port) && Number(url.port)) {
                        options.port = Number(url.port);
                    }

                    if (url.hostname) {
                        options.host = url.hostname;
                    }

                    if (url.auth) {
                        auth = url.auth.split(':');

                        if (!options.auth) {
                            options.auth = {};
                        }

                        options.auth.user = auth.shift();
                        options.auth.pass = auth.join(':');
                    }

                    Object.keys(url.query || {}).forEach(key => {
                        let obj = options;
                        let lKey = key;
                        let value = url.query[key];

                        if (!isNaN(value)) {
                            value = Number(value);
                        }

                        switch (value) {
                            case 'true':
                                value = true;
                                break;
                            case 'false':
                                value = false;
                                break;
                        }

                        // tls is nested object
                        if (key.indexOf('tls.') === 0) {
                            lKey = key.substr(4);
                            if (!options.tls) {
                                options.tls = {};
                            }
                            obj = options.tls;
                        } else if (key.indexOf('.') >= 0) {
                            // ignore nested properties besides tls
                            return;
                        }

                        if (!(lKey in obj)) {
                            obj[lKey] = value;
                        }
                    });
                });

                return options;
            };

            module.exports._logFunc = (logger, level, defaults, data, message, ...args) => {
                let entry = {};

                Object.keys(defaults || {}).forEach(key => {
                    if (key !== 'level') {
                        entry[key] = defaults[key];
                    }
                });

                Object.keys(data || {}).forEach(key => {
                    if (key !== 'level') {
                        entry[key] = data[key];
                    }
                });

                logger[level](entry, message, ...args);
            };

            /**
             * Returns a bunyan-compatible logger interface. Uses either provided logger or
             * creates a default console logger
             *
             * @param {Object} [options] Options object that might include 'logger' value
             * @return {Object} bunyan compatible logger
             */
            module.exports.getLogger = (options, defaults) => {
                options = options || {};

                let response = {};
                let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];

                if (!options.logger) {
                    // use vanity logger
                    levels.forEach(level => {
                        response[level] = () => false;
                    });
                    return response;
                }

                let logger = options.logger;

                if (options.logger === true) {
                    // create console logger
                    logger = createDefaultLogger(levels);
                }

                levels.forEach(level => {
                    response[level] = (data, message, ...args) => {
                        module.exports._logFunc(logger, level, defaults, data, message, ...args);
                    };
                });

                return response;
            };

            /**
             * Wrapper for creating a callback that either resolves or rejects a promise
             * based on input
             *
             * @param {Function} resolve Function to run if callback is called
             * @param {Function} reject Function to run if callback ends with an error
             */
            module.exports.callbackPromise = (resolve, reject) =>
                function () {
                    let args = Array.from(arguments);
                    let err = args.shift();
                    if (err) {
                        reject(err);
                    } else {
                        resolve(...args);
                    }
                };

            /**
             * Resolves a String or a Buffer value for content value. Useful if the value
             * is a Stream or a file or an URL. If the value is a Stream, overwrites
             * the stream object with the resolved value (you can't stream a value twice).
             *
             * This is useful when you want to create a plugin that needs a content value,
             * for example the `html` or `text` value as a String or a Buffer but not as
             * a file path or an URL.
             *
             * @param {Object} data An object or an Array you want to resolve an element for
             * @param {String|Number} key Property name or an Array index
             * @param {Function} callback Callback function with (err, value)
             */
            module.exports.resolveContent = (data, key, callback) => {
                let promise;

                if (!callback) {
                    promise = new Promise((resolve, reject) => {
                        callback = module.exports.callbackPromise(resolve, reject);
                    });
                }

                let content = (data && data[key] && data[key].content) || data[key];
                let contentStream;
                let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')
                    .toString()
                    .toLowerCase()
                    .replace(/[-_\s]/g, '');

                if (!content) {
                    return callback(null, content);
                }

                if (typeof content === 'object') {
                    if (typeof content.pipe === 'function') {
                        return resolveStream(content, (err, value) => {
                            if (err) {
                                return callback(err);
                            }
                            // we can't stream twice the same content, so we need
                            // to replace the stream object with the streaming result
                            if (data[key].content) {
                                data[key].content = value;
                            } else {
                                data[key] = value;
                            }
                            callback(null, value);
                        });
                    } else if (/^https?:\/\//i.test(content.path || content.href)) {
                        contentStream = fetch(content.path || content.href);
                        return resolveStream(contentStream, callback);
                    } else if (/^data:/i.test(content.path || content.href)) {
                        let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);
                        if (!parts) {
                            return callback(null, Buffer.from(0));
                        }
                        return callback(null, /\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));
                    } else if (content.path) {
                        return resolveStream(fs.createReadStream(content.path), callback);
                    }
                }

                if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {
                    content = Buffer.from(data[key].content, encoding);
                }

                // default action, return as is
                setImmediate(() => callback(null, content));

                return promise;
            };

            /**
             * Copies properties from source objects to target objects
             */
            module.exports.assign = function (/* target, ... sources */) {
                let args = Array.from(arguments);
                let target = args.shift() || {};

                args.forEach(source => {
                    Object.keys(source || {}).forEach(key => {
                        if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {
                            // tls and auth are special keys that need to be enumerated separately
                            // other objects are passed as is
                            if (!target[key]) {
                                // ensure that target has this key
                                target[key] = {};
                            }
                            Object.keys(source[key]).forEach(subKey => {
                                target[key][subKey] = source[key][subKey];
                            });
                        } else {
                            target[key] = source[key];
                        }
                    });
                });
                return target;
            };

            module.exports.encodeXText = str => {
                // ! 0x21
                // + 0x2B
                // = 0x3D
                // ~ 0x7E
                if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
                    return str;
                }
                let buf = Buffer.from(str);
                let result = '';
                for (let i = 0, len = buf.length; i < len; i++) {
                    let c = buf[i];
                    if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {
                        result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();
                    } else {
                        result += String.fromCharCode(c);
                    }
                }
                return result;
            };

            /**
             * Streams a stream value into a Buffer
             *
             * @param {Object} stream Readable stream
             * @param {Function} callback Callback function with (err, value)
             */
            function resolveStream(stream, callback) {
                let responded = false;
                let chunks = [];
                let chunklen = 0;

                stream.on('error', err => {
                    if (responded) {
                        return;
                    }

                    responded = true;
                    callback(err);
                });

                stream.on('readable', () => {
                    let chunk;
                    while ((chunk = stream.read()) !== null) {
                        chunks.push(chunk);
                        chunklen += chunk.length;
                    }
                });

                stream.on('end', () => {
                    if (responded) {
                        return;
                    }
                    responded = true;

                    let value;

                    try {
                        value = Buffer.concat(chunks, chunklen);
                    } catch (E) {
                        return callback(E);
                    }
                    callback(null, value);
                });
            }

            /**
             * Generates a bunyan-like logger that prints to console
             *
             * @returns {Object} Bunyan logger instance
             */
            function createDefaultLogger(levels) {
                let levelMaxLen = 0;
                let levelNames = new Map();
                levels.forEach(level => {
                    if (level.length > levelMaxLen) {
                        levelMaxLen = level.length;
                    }
                });

                levels.forEach(level => {
                    let levelName = level.toUpperCase();
                    if (levelName.length < levelMaxLen) {
                        levelName += ' '.repeat(levelMaxLen - levelName.length);
                    }
                    levelNames.set(level, levelName);
                });

                let print = (level, entry, message, ...args) => {
                    let prefix = '';
                    if (entry) {
                        if (entry.tnx === 'server') {
                            prefix = 'S: ';
                        } else if (entry.tnx === 'client') {
                            prefix = 'C: ';
                        }

                        if (entry.sid) {
                            prefix = '[' + entry.sid + '] ' + prefix;
                        }

                        if (entry.cid) {
                            prefix = '[#' + entry.cid + '] ' + prefix;
                        }
                    }

                    message = util.format(message, ...args);
                    message.split(/\r?\n/).forEach(line => {
                        console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);
                    });
                };

                let logger = {};
                levels.forEach(level => {
                    logger[level] = print.bind(null, level);
                });

                return logger;
            }


            /***/
        }),
        /* 191 */,
        /* 192 */,
        /* 193 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getContentLengthPlugin = exports.contentLengthMiddlewareOptions = exports.contentLengthMiddleware = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const CONTENT_LENGTH_HEADER = "content-length";

            function contentLengthMiddleware(bodyLengthChecker) {
                return (next) => async (args) => {
                    const request = args.request;
                    if (protocol_http_1.HttpRequest.isInstance(request)) {
                        const {body, headers} = request;
                        if (body &&
                            Object.keys(headers)
                                .map((str) => str.toLowerCase())
                                .indexOf(CONTENT_LENGTH_HEADER) === -1) {
                            try {
                                const length = bodyLengthChecker(body);
                                request.headers = {
                                    ...request.headers,
                                    [CONTENT_LENGTH_HEADER]: String(length),
                                };
                            } catch (error) {
                            }
                        }
                    }
                    return next({
                        ...args,
                        request,
                    });
                };
            }

            exports.contentLengthMiddleware = contentLengthMiddleware;
            exports.contentLengthMiddlewareOptions = {
                step: "build",
                tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
                name: "contentLengthMiddleware",
                override: true,
            };
            const getContentLengthPlugin = (options) => ({
                applyToStack: (clientStack) => {
                    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), exports.contentLengthMiddlewareOptions);
                },
            });
            exports.getContentLengthPlugin = getContentLengthPlugin;


            /***/
        }),
        /* 194 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CreateReceiptFilterCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CreateReceiptFilterCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CreateReceiptFilterCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CreateReceiptFilterRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.CreateReceiptFilterResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCreateReceiptFilterCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCreateReceiptFilterCommand)(output, context);
                }
            }

            exports.CreateReceiptFilterCommand = CreateReceiptFilterCommand;


            /***/
        }),
        /* 195 */,
        /* 196 */,
        /* 197 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(639), exports);
            tslib_1.__exportStar(__webpack_require__(730), exports);
            tslib_1.__exportStar(__webpack_require__(104), exports);
            tslib_1.__exportStar(__webpack_require__(560), exports);


            /***/
        }),
        /* 198 */,
        /* 199 */,
        /* 200 */,
        /* 201 */,
        /* 202 */,
        /* 203 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(518), exports);


            /***/
        }),
        /* 204 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const http = __webpack_require__(605);
            const https = __webpack_require__(211);
            const urllib = __webpack_require__(835);
            const zlib = __webpack_require__(761);
            const PassThrough = __webpack_require__(413).PassThrough;
            const Cookies = __webpack_require__(459);
            const packageData = __webpack_require__(786);

            const MAX_REDIRECTS = 5;

            module.exports = function (url, options) {
                return fetch(url, options);
            };

            module.exports.Cookies = Cookies;

            function fetch(url, options) {
                options = options || {};

                options.fetchRes = options.fetchRes || new PassThrough();
                options.cookies = options.cookies || new Cookies();
                options.redirects = options.redirects || 0;
                options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;

                if (options.cookie) {
                    [].concat(options.cookie || []).forEach(cookie => {
                        options.cookies.set(cookie, url);
                    });
                    options.cookie = false;
                }

                let fetchRes = options.fetchRes;
                let parsed = urllib.parse(url);
                let method = (options.method || '').toString().trim().toUpperCase() || 'GET';
                let finished = false;
                let cookies;
                let body;

                let handler = parsed.protocol === 'https:' ? https : http;

                let headers = {
                    'accept-encoding': 'gzip,deflate',
                    'user-agent': 'nodemailer/' + packageData.version
                };

                Object.keys(options.headers || {}).forEach(key => {
                    headers[key.toLowerCase().trim()] = options.headers[key];
                });

                if (options.userAgent) {
                    headers['user-agent'] = options.userAgent;
                }

                if (parsed.auth) {
                    headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');
                }

                if ((cookies = options.cookies.get(url))) {
                    headers.cookie = cookies;
                }

                if (options.body) {
                    if (options.contentType !== false) {
                        headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';
                    }

                    if (typeof options.body.pipe === 'function') {
                        // it's a stream
                        headers['Transfer-Encoding'] = 'chunked';
                        body = options.body;
                        body.on('error', err => {
                            if (finished) {
                                return;
                            }
                            finished = true;
                            err.type = 'FETCH';
                            err.sourceUrl = url;
                            fetchRes.emit('error', err);
                        });
                    } else {
                        if (options.body instanceof Buffer) {
                            body = options.body;
                        } else if (typeof options.body === 'object') {
                            try {
                                // encodeURIComponent can fail on invalid input (partial emoji etc.)
                                body = Buffer.from(
                                    Object.keys(options.body)
                                        .map(key => {
                                            let value = options.body[key].toString().trim();
                                            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
                                        })
                                        .join('&')
                                );
                            } catch (E) {
                                if (finished) {
                                    return;
                                }
                                finished = true;
                                E.type = 'FETCH';
                                E.sourceUrl = url;
                                fetchRes.emit('error', E);
                                return;
                            }
                        } else {
                            body = Buffer.from(options.body.toString().trim());
                        }

                        headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';
                        headers['Content-Length'] = body.length;
                    }
                    // if method is not provided, use POST instead of GET
                    method = (options.method || '').toString().trim().toUpperCase() || 'POST';
                }

                let req;
                let reqOptions = {
                    method,
                    host: parsed.hostname,
                    path: parsed.path,
                    port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,
                    headers,
                    rejectUnauthorized: false,
                    agent: false
                };

                if (options.tls) {
                    Object.keys(options.tls).forEach(key => {
                        reqOptions[key] = options.tls[key];
                    });
                }

                try {
                    req = handler.request(reqOptions);
                } catch (E) {
                    finished = true;
                    setImmediate(() => {
                        E.type = 'FETCH';
                        E.sourceUrl = url;
                        fetchRes.emit('error', E);
                    });
                    return fetchRes;
                }

                if (options.timeout) {
                    req.setTimeout(options.timeout, () => {
                        if (finished) {
                            return;
                        }
                        finished = true;
                        req.abort();
                        let err = new Error('Request Timeout');
                        err.type = 'FETCH';
                        err.sourceUrl = url;
                        fetchRes.emit('error', err);
                    });
                }

                req.on('error', err => {
                    if (finished) {
                        return;
                    }
                    finished = true;
                    err.type = 'FETCH';
                    err.sourceUrl = url;
                    fetchRes.emit('error', err);
                });

                req.on('response', res => {
                    let inflate;

                    if (finished) {
                        return;
                    }

                    switch (res.headers['content-encoding']) {
                        case 'gzip':
                        case 'deflate':
                            inflate = zlib.createUnzip();
                            break;
                    }

                    if (res.headers['set-cookie']) {
                        [].concat(res.headers['set-cookie'] || []).forEach(cookie => {
                            options.cookies.set(cookie, url);
                        });
                    }

                    if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {
                        // redirect
                        options.redirects++;
                        if (options.redirects > options.maxRedirects) {
                            finished = true;
                            let err = new Error('Maximum redirect count exceeded');
                            err.type = 'FETCH';
                            err.sourceUrl = url;
                            fetchRes.emit('error', err);
                            req.abort();
                            return;
                        }
                        // redirect does not include POST body
                        options.method = 'GET';
                        options.body = false;
                        return fetch(urllib.resolve(url, res.headers.location), options);
                    }

                    fetchRes.statusCode = res.statusCode;
                    fetchRes.headers = res.headers;

                    if (res.statusCode >= 300 && !options.allowErrorResponse) {
                        finished = true;
                        let err = new Error('Invalid status code ' + res.statusCode);
                        err.type = 'FETCH';
                        err.sourceUrl = url;
                        fetchRes.emit('error', err);
                        req.abort();
                        return;
                    }

                    res.on('error', err => {
                        if (finished) {
                            return;
                        }
                        finished = true;
                        err.type = 'FETCH';
                        err.sourceUrl = url;
                        fetchRes.emit('error', err);
                        req.abort();
                    });

                    if (inflate) {
                        res.pipe(inflate).pipe(fetchRes);
                        inflate.on('error', err => {
                            if (finished) {
                                return;
                            }
                            finished = true;
                            err.type = 'FETCH';
                            err.sourceUrl = url;
                            fetchRes.emit('error', err);
                            req.abort();
                        });
                    } else {
                        res.pipe(fetchRes);
                    }
                });

                setImmediate(() => {
                    if (body) {
                        try {
                            if (typeof body.pipe === 'function') {
                                return body.pipe(req);
                            } else {
                                req.write(body);
                            }
                        } catch (err) {
                            finished = true;
                            err.type = 'FETCH';
                            err.sourceUrl = url;
                            fetchRes.emit('error', err);
                            return;
                        }
                    }
                    req.end();
                });

                return fetchRes;
            }


            /***/
        }),
        /* 205 */,
        /* 206 */,
        /* 207 */,
        /* 208 */,
        /* 209 */,
        /* 210 */,
        /* 211 */
        /***/ (function (module) {

            module.exports = require("https");

            /***/
        }),
        /* 212 */,
        /* 213 */
        /***/ (function (module) {

            module.exports = require("punycode");

            /***/
        }),
        /* 214 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.httpRequest = void 0;
            const property_provider_1 = __webpack_require__(118);
            const buffer_1 = __webpack_require__(670);
            const http_1 = __webpack_require__(605);

            function httpRequest(options) {
                return new Promise((resolve, reject) => {
                    var _a;
                    const req = (0, http_1.request)({
                        method: "GET",
                        ...options,
                        hostname: (_a = options.hostname) === null || _a === void 0 ? void 0 : _a.replace(/^\[(.+)\]$/, "$1"),
                    });
                    req.on("error", (err) => {
                        reject(Object.assign(new property_provider_1.ProviderError("Unable to connect to instance metadata service"), err));
                        req.destroy();
                    });
                    req.on("timeout", () => {
                        reject(new property_provider_1.ProviderError("TimeoutError from instance metadata service"));
                        req.destroy();
                    });
                    req.on("response", (res) => {
                        const {statusCode = 400} = res;
                        if (statusCode < 200 || 300 <= statusCode) {
                            reject(Object.assign(new property_provider_1.ProviderError("Error response received from instance metadata service"), {statusCode}));
                            req.destroy();
                        }
                        const chunks = [];
                        res.on("data", (chunk) => {
                            chunks.push(chunk);
                        });
                        res.on("end", () => {
                            resolve(buffer_1.Buffer.concat(chunks));
                            req.destroy();
                        });
                    });
                    req.end();
                });
            }

            exports.httpRequest = httpRequest;


            /***/
        }),
        /* 215 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.isSsoProfile = void 0;
            const isSsoProfile = (arg) => arg &&
                (typeof arg.sso_start_url === "string" ||
                    typeof arg.sso_account_id === "string" ||
                    typeof arg.sso_region === "string" ||
                    typeof arg.sso_role_name === "string");
            exports.isSsoProfile = isSsoProfile;


            /***/
        }),
        /* 216 */,
        /* 217 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getSkewCorrectedDate = void 0;
            const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
            exports.getSkewCorrectedDate = getSkewCorrectedDate;


            /***/
        }),
        /* 218 */,
        /* 219 */,
        /* 220 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromSharedConfigFiles = exports.ENV_PROFILE = void 0;
            const property_provider_1 = __webpack_require__(118);
            const shared_ini_file_loader_1 = __webpack_require__(706);
            const DEFAULT_PROFILE = "default";
            exports.ENV_PROFILE = "AWS_PROFILE";
            const fromSharedConfigFiles = (configSelector, {preferredFile = "config", ...init} = {}) => async () => {
                const {
                    loadedConfig = (0, shared_ini_file_loader_1.loadSharedConfigFiles)(init),
                    profile = process.env[exports.ENV_PROFILE] || DEFAULT_PROFILE
                } = init;
                const {configFile, credentialsFile} = await loadedConfig;
                const profileFromCredentials = credentialsFile[profile] || {};
                const profileFromConfig = configFile[profile] || {};
                const mergedProfile = preferredFile === "config"
                    ? {...profileFromCredentials, ...profileFromConfig}
                    : {...profileFromConfig, ...profileFromCredentials};
                try {
                    const configValue = configSelector(mergedProfile);
                    if (configValue === undefined) {
                        throw new Error();
                    }
                    return configValue;
                } catch (e) {
                    throw new property_provider_1.CredentialsProviderError(e.message ||
                        `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
                }
            };
            exports.fromSharedConfigFiles = fromSharedConfigFiles;


            /***/
        }),
        /* 221 */,
        /* 222 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CustomVerificationEmailInvalidContentException = exports.CreateCustomVerificationEmailTemplateRequest = exports.TrackingOptionsAlreadyExistsException = exports.InvalidTrackingOptionsException = exports.CreateConfigurationSetTrackingOptionsResponse = exports.CreateConfigurationSetTrackingOptionsRequest = exports.TrackingOptions = exports.InvalidSNSDestinationException = exports.InvalidFirehoseDestinationException = exports.InvalidCloudWatchDestinationException = exports.EventDestinationAlreadyExistsException = exports.CreateConfigurationSetEventDestinationResponse = exports.CreateConfigurationSetEventDestinationRequest = exports.EventDestination = exports.SNSDestination = exports.EventType = exports.KinesisFirehoseDestination = exports.InvalidConfigurationSetException = exports.CreateConfigurationSetResponse = exports.CreateConfigurationSetRequest = exports.ConfigurationSetSendingPausedException = exports.ConfigurationSetDoesNotExistException = exports.ConfigurationSetAttribute = exports.ConfigurationSetAlreadyExistsException = exports.ConfigurationSet = exports.CloudWatchDestination = exports.CloudWatchDimensionConfiguration = exports.DimensionValueSource = exports.RuleSetDoesNotExistException = exports.LimitExceededException = exports.CloneReceiptRuleSetResponse = exports.CloneReceiptRuleSetRequest = exports.CannotDeleteException = exports.BulkEmailDestinationStatus = exports.BulkEmailStatus = exports.BulkEmailDestination = exports.MessageTag = exports.Destination = exports.BouncedRecipientInfo = exports.RecipientDsnFields = exports.ExtensionField = exports.DsnAction = exports.BounceType = exports.BounceAction = exports.Body = exports.Content = exports.BehaviorOnMXFailure = exports.AlreadyExistsException = exports.AddHeaderAction = exports.AccountSendingPausedException = void 0;
            exports.DeleteReceiptRuleSetRequest = exports.DeleteReceiptRuleResponse = exports.DeleteReceiptRuleRequest = exports.DeleteReceiptFilterResponse = exports.DeleteReceiptFilterRequest = exports.DeleteIdentityPolicyResponse = exports.DeleteIdentityPolicyRequest = exports.DeleteIdentityResponse = exports.DeleteIdentityRequest = exports.DeleteCustomVerificationEmailTemplateRequest = exports.TrackingOptionsDoesNotExistException = exports.DeleteConfigurationSetTrackingOptionsResponse = exports.DeleteConfigurationSetTrackingOptionsRequest = exports.EventDestinationDoesNotExistException = exports.DeleteConfigurationSetEventDestinationResponse = exports.DeleteConfigurationSetEventDestinationRequest = exports.DeleteConfigurationSetResponse = exports.DeleteConfigurationSetRequest = exports.CustomVerificationEmailTemplateDoesNotExistException = exports.CustomVerificationEmailTemplate = exports.CustomMailFromStatus = exports.InvalidTemplateException = exports.CreateTemplateResponse = exports.CreateTemplateRequest = exports.Template = exports.CreateReceiptRuleSetResponse = exports.CreateReceiptRuleSetRequest = exports.RuleDoesNotExistException = exports.InvalidSnsTopicException = exports.InvalidS3ConfigurationException = exports.InvalidLambdaFunctionException = exports.CreateReceiptRuleResponse = exports.CreateReceiptRuleRequest = exports.ReceiptRule = exports.TlsPolicy = exports.ReceiptAction = exports.WorkmailAction = exports.StopAction = exports.StopScope = exports.SNSAction = exports.SNSActionEncoding = exports.S3Action = exports.LambdaAction = exports.CreateReceiptFilterResponse = exports.CreateReceiptFilterRequest = exports.ReceiptFilter = exports.ReceiptIpFilter = exports.ReceiptFilterPolicy = exports.FromEmailAddressNotVerifiedException = exports.CustomVerificationEmailTemplateAlreadyExistsException = void 0;
            exports.ListReceiptFiltersRequest = exports.ListIdentityPoliciesResponse = exports.ListIdentityPoliciesRequest = exports.ListIdentitiesResponse = exports.ListIdentitiesRequest = exports.ListCustomVerificationEmailTemplatesResponse = exports.ListCustomVerificationEmailTemplatesRequest = exports.ListConfigurationSetsResponse = exports.ListConfigurationSetsRequest = exports.InvalidRenderingParameterException = exports.InvalidPolicyException = exports.InvalidDeliveryOptionsException = exports.TemplateDoesNotExistException = exports.GetTemplateResponse = exports.GetTemplateRequest = exports.GetSendStatisticsResponse = exports.SendDataPoint = exports.GetSendQuotaResponse = exports.GetIdentityVerificationAttributesResponse = exports.IdentityVerificationAttributes = exports.GetIdentityVerificationAttributesRequest = exports.GetIdentityPoliciesResponse = exports.GetIdentityPoliciesRequest = exports.GetIdentityNotificationAttributesResponse = exports.IdentityNotificationAttributes = exports.GetIdentityNotificationAttributesRequest = exports.GetIdentityMailFromDomainAttributesResponse = exports.IdentityMailFromDomainAttributes = exports.GetIdentityMailFromDomainAttributesRequest = exports.GetIdentityDkimAttributesResponse = exports.GetIdentityDkimAttributesRequest = exports.GetCustomVerificationEmailTemplateResponse = exports.GetCustomVerificationEmailTemplateRequest = exports.GetAccountSendingEnabledResponse = exports.IdentityDkimAttributes = exports.DescribeReceiptRuleSetResponse = exports.DescribeReceiptRuleSetRequest = exports.DescribeReceiptRuleResponse = exports.DescribeReceiptRuleRequest = exports.DescribeConfigurationSetResponse = exports.ReputationOptions = exports.DescribeConfigurationSetRequest = exports.DescribeActiveReceiptRuleSetResponse = exports.ReceiptRuleSetMetadata = exports.DescribeActiveReceiptRuleSetRequest = exports.DeliveryOptions = exports.DeleteVerifiedEmailAddressRequest = exports.DeleteTemplateResponse = exports.DeleteTemplateRequest = exports.DeleteReceiptRuleSetResponse = void 0;
            exports.UpdateConfigurationSetEventDestinationRequest = exports.UpdateAccountSendingEnabledRequest = exports.TestRenderTemplateResponse = exports.TestRenderTemplateRequest = exports.SetReceiptRulePositionResponse = exports.SetReceiptRulePositionRequest = exports.SetIdentityNotificationTopicResponse = exports.SetIdentityNotificationTopicRequest = exports.SetIdentityMailFromDomainResponse = exports.SetIdentityMailFromDomainRequest = exports.SetIdentityHeadersInNotificationsEnabledResponse = exports.SetIdentityHeadersInNotificationsEnabledRequest = exports.SetIdentityFeedbackForwardingEnabledResponse = exports.SetIdentityFeedbackForwardingEnabledRequest = exports.SetIdentityDkimEnabledResponse = exports.SetIdentityDkimEnabledRequest = exports.SetActiveReceiptRuleSetResponse = exports.SetActiveReceiptRuleSetRequest = exports.SendTemplatedEmailResponse = exports.SendTemplatedEmailRequest = exports.SendRawEmailResponse = exports.SendRawEmailRequest = exports.SendEmailResponse = exports.SendEmailRequest = exports.SendCustomVerificationEmailResponse = exports.SendCustomVerificationEmailRequest = exports.SendBulkTemplatedEmailResponse = exports.SendBulkTemplatedEmailRequest = exports.SendBounceResponse = exports.SendBounceRequest = exports.ReorderReceiptRuleSetResponse = exports.ReorderReceiptRuleSetRequest = exports.RawMessage = exports.PutIdentityPolicyResponse = exports.PutIdentityPolicyRequest = exports.PutConfigurationSetDeliveryOptionsResponse = exports.PutConfigurationSetDeliveryOptionsRequest = exports.ProductionAccessNotGrantedException = exports.MissingRenderingAttributeException = exports.MessageRejected = exports.MessageDsn = exports.Message = exports.MailFromDomainNotVerifiedException = exports.ListVerifiedEmailAddressesResponse = exports.ListTemplatesResponse = exports.TemplateMetadata = exports.ListTemplatesRequest = exports.ListReceiptRuleSetsResponse = exports.ListReceiptRuleSetsRequest = exports.ListReceiptFiltersResponse = void 0;
            exports.VerifyEmailIdentityResponse = exports.VerifyEmailIdentityRequest = exports.VerifyEmailAddressRequest = exports.VerifyDomainIdentityResponse = exports.VerifyDomainIdentityRequest = exports.VerifyDomainDkimResponse = exports.VerifyDomainDkimRequest = exports.UpdateTemplateResponse = exports.UpdateTemplateRequest = exports.UpdateReceiptRuleResponse = exports.UpdateReceiptRuleRequest = exports.UpdateCustomVerificationEmailTemplateRequest = exports.UpdateConfigurationSetTrackingOptionsResponse = exports.UpdateConfigurationSetTrackingOptionsRequest = exports.UpdateConfigurationSetSendingEnabledRequest = exports.UpdateConfigurationSetReputationMetricsEnabledRequest = exports.UpdateConfigurationSetEventDestinationResponse = void 0;
            const SESServiceException_1 = __webpack_require__(353);

            class AccountSendingPausedException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "AccountSendingPausedException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "AccountSendingPausedException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, AccountSendingPausedException.prototype);
                }
            }

            exports.AccountSendingPausedException = AccountSendingPausedException;
            var AddHeaderAction;
            (function (AddHeaderAction) {
                AddHeaderAction.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AddHeaderAction = exports.AddHeaderAction || (exports.AddHeaderAction = {}));

            class AlreadyExistsException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "AlreadyExistsException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "AlreadyExistsException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, AlreadyExistsException.prototype);
                    this.Name = opts.Name;
                }
            }

            exports.AlreadyExistsException = AlreadyExistsException;
            var BehaviorOnMXFailure;
            (function (BehaviorOnMXFailure) {
                BehaviorOnMXFailure["RejectMessage"] = "RejectMessage";
                BehaviorOnMXFailure["UseDefaultValue"] = "UseDefaultValue";
            })(BehaviorOnMXFailure = exports.BehaviorOnMXFailure || (exports.BehaviorOnMXFailure = {}));
            var Content;
            (function (Content) {
                Content.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(Content = exports.Content || (exports.Content = {}));
            var Body;
            (function (Body) {
                Body.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(Body = exports.Body || (exports.Body = {}));
            var BounceAction;
            (function (BounceAction) {
                BounceAction.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(BounceAction = exports.BounceAction || (exports.BounceAction = {}));
            var BounceType;
            (function (BounceType) {
                BounceType["ContentRejected"] = "ContentRejected";
                BounceType["DoesNotExist"] = "DoesNotExist";
                BounceType["ExceededQuota"] = "ExceededQuota";
                BounceType["MessageTooLarge"] = "MessageTooLarge";
                BounceType["TemporaryFailure"] = "TemporaryFailure";
                BounceType["Undefined"] = "Undefined";
            })(BounceType = exports.BounceType || (exports.BounceType = {}));
            var DsnAction;
            (function (DsnAction) {
                DsnAction["DELAYED"] = "delayed";
                DsnAction["DELIVERED"] = "delivered";
                DsnAction["EXPANDED"] = "expanded";
                DsnAction["FAILED"] = "failed";
                DsnAction["RELAYED"] = "relayed";
            })(DsnAction = exports.DsnAction || (exports.DsnAction = {}));
            var ExtensionField;
            (function (ExtensionField) {
                ExtensionField.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ExtensionField = exports.ExtensionField || (exports.ExtensionField = {}));
            var RecipientDsnFields;
            (function (RecipientDsnFields) {
                RecipientDsnFields.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(RecipientDsnFields = exports.RecipientDsnFields || (exports.RecipientDsnFields = {}));
            var BouncedRecipientInfo;
            (function (BouncedRecipientInfo) {
                BouncedRecipientInfo.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(BouncedRecipientInfo = exports.BouncedRecipientInfo || (exports.BouncedRecipientInfo = {}));
            var Destination;
            (function (Destination) {
                Destination.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(Destination = exports.Destination || (exports.Destination = {}));
            var MessageTag;
            (function (MessageTag) {
                MessageTag.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(MessageTag = exports.MessageTag || (exports.MessageTag = {}));
            var BulkEmailDestination;
            (function (BulkEmailDestination) {
                BulkEmailDestination.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(BulkEmailDestination = exports.BulkEmailDestination || (exports.BulkEmailDestination = {}));
            var BulkEmailStatus;
            (function (BulkEmailStatus) {
                BulkEmailStatus["AccountDailyQuotaExceeded"] = "AccountDailyQuotaExceeded";
                BulkEmailStatus["AccountSendingPaused"] = "AccountSendingPaused";
                BulkEmailStatus["AccountSuspended"] = "AccountSuspended";
                BulkEmailStatus["AccountThrottled"] = "AccountThrottled";
                BulkEmailStatus["ConfigurationSetDoesNotExist"] = "ConfigurationSetDoesNotExist";
                BulkEmailStatus["ConfigurationSetSendingPaused"] = "ConfigurationSetSendingPaused";
                BulkEmailStatus["Failed"] = "Failed";
                BulkEmailStatus["InvalidParameterValue"] = "InvalidParameterValue";
                BulkEmailStatus["InvalidSendingPoolName"] = "InvalidSendingPoolName";
                BulkEmailStatus["MailFromDomainNotVerified"] = "MailFromDomainNotVerified";
                BulkEmailStatus["MessageRejected"] = "MessageRejected";
                BulkEmailStatus["Success"] = "Success";
                BulkEmailStatus["TemplateDoesNotExist"] = "TemplateDoesNotExist";
                BulkEmailStatus["TransientFailure"] = "TransientFailure";
            })(BulkEmailStatus = exports.BulkEmailStatus || (exports.BulkEmailStatus = {}));
            var BulkEmailDestinationStatus;
            (function (BulkEmailDestinationStatus) {
                BulkEmailDestinationStatus.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(BulkEmailDestinationStatus = exports.BulkEmailDestinationStatus || (exports.BulkEmailDestinationStatus = {}));

            class CannotDeleteException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "CannotDeleteException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "CannotDeleteException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, CannotDeleteException.prototype);
                    this.Name = opts.Name;
                }
            }

            exports.CannotDeleteException = CannotDeleteException;
            var CloneReceiptRuleSetRequest;
            (function (CloneReceiptRuleSetRequest) {
                CloneReceiptRuleSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CloneReceiptRuleSetRequest = exports.CloneReceiptRuleSetRequest || (exports.CloneReceiptRuleSetRequest = {}));
            var CloneReceiptRuleSetResponse;
            (function (CloneReceiptRuleSetResponse) {
                CloneReceiptRuleSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CloneReceiptRuleSetResponse = exports.CloneReceiptRuleSetResponse || (exports.CloneReceiptRuleSetResponse = {}));

            class LimitExceededException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "LimitExceededException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "LimitExceededException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, LimitExceededException.prototype);
                }
            }

            exports.LimitExceededException = LimitExceededException;

            class RuleSetDoesNotExistException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "RuleSetDoesNotExistException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "RuleSetDoesNotExistException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, RuleSetDoesNotExistException.prototype);
                    this.Name = opts.Name;
                }
            }

            exports.RuleSetDoesNotExistException = RuleSetDoesNotExistException;
            var DimensionValueSource;
            (function (DimensionValueSource) {
                DimensionValueSource["EMAIL_HEADER"] = "emailHeader";
                DimensionValueSource["LINK_TAG"] = "linkTag";
                DimensionValueSource["MESSAGE_TAG"] = "messageTag";
            })(DimensionValueSource = exports.DimensionValueSource || (exports.DimensionValueSource = {}));
            var CloudWatchDimensionConfiguration;
            (function (CloudWatchDimensionConfiguration) {
                CloudWatchDimensionConfiguration.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CloudWatchDimensionConfiguration = exports.CloudWatchDimensionConfiguration || (exports.CloudWatchDimensionConfiguration = {}));
            var CloudWatchDestination;
            (function (CloudWatchDestination) {
                CloudWatchDestination.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CloudWatchDestination = exports.CloudWatchDestination || (exports.CloudWatchDestination = {}));
            var ConfigurationSet;
            (function (ConfigurationSet) {
                ConfigurationSet.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ConfigurationSet = exports.ConfigurationSet || (exports.ConfigurationSet = {}));

            class ConfigurationSetAlreadyExistsException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "ConfigurationSetAlreadyExistsException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "ConfigurationSetAlreadyExistsException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, ConfigurationSetAlreadyExistsException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                }
            }

            exports.ConfigurationSetAlreadyExistsException = ConfigurationSetAlreadyExistsException;
            var ConfigurationSetAttribute;
            (function (ConfigurationSetAttribute) {
                ConfigurationSetAttribute["DELIVERY_OPTIONS"] = "deliveryOptions";
                ConfigurationSetAttribute["EVENT_DESTINATIONS"] = "eventDestinations";
                ConfigurationSetAttribute["REPUTATION_OPTIONS"] = "reputationOptions";
                ConfigurationSetAttribute["TRACKING_OPTIONS"] = "trackingOptions";
            })(ConfigurationSetAttribute = exports.ConfigurationSetAttribute || (exports.ConfigurationSetAttribute = {}));

            class ConfigurationSetDoesNotExistException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "ConfigurationSetDoesNotExistException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "ConfigurationSetDoesNotExistException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, ConfigurationSetDoesNotExistException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                }
            }

            exports.ConfigurationSetDoesNotExistException = ConfigurationSetDoesNotExistException;

            class ConfigurationSetSendingPausedException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "ConfigurationSetSendingPausedException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "ConfigurationSetSendingPausedException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, ConfigurationSetSendingPausedException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                }
            }

            exports.ConfigurationSetSendingPausedException = ConfigurationSetSendingPausedException;
            var CreateConfigurationSetRequest;
            (function (CreateConfigurationSetRequest) {
                CreateConfigurationSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateConfigurationSetRequest = exports.CreateConfigurationSetRequest || (exports.CreateConfigurationSetRequest = {}));
            var CreateConfigurationSetResponse;
            (function (CreateConfigurationSetResponse) {
                CreateConfigurationSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateConfigurationSetResponse = exports.CreateConfigurationSetResponse || (exports.CreateConfigurationSetResponse = {}));

            class InvalidConfigurationSetException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidConfigurationSetException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidConfigurationSetException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidConfigurationSetException.prototype);
                }
            }

            exports.InvalidConfigurationSetException = InvalidConfigurationSetException;
            var KinesisFirehoseDestination;
            (function (KinesisFirehoseDestination) {
                KinesisFirehoseDestination.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(KinesisFirehoseDestination = exports.KinesisFirehoseDestination || (exports.KinesisFirehoseDestination = {}));
            var EventType;
            (function (EventType) {
                EventType["BOUNCE"] = "bounce";
                EventType["CLICK"] = "click";
                EventType["COMPLAINT"] = "complaint";
                EventType["DELIVERY"] = "delivery";
                EventType["OPEN"] = "open";
                EventType["REJECT"] = "reject";
                EventType["RENDERING_FAILURE"] = "renderingFailure";
                EventType["SEND"] = "send";
            })(EventType = exports.EventType || (exports.EventType = {}));
            var SNSDestination;
            (function (SNSDestination) {
                SNSDestination.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SNSDestination = exports.SNSDestination || (exports.SNSDestination = {}));
            var EventDestination;
            (function (EventDestination) {
                EventDestination.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(EventDestination = exports.EventDestination || (exports.EventDestination = {}));
            var CreateConfigurationSetEventDestinationRequest;
            (function (CreateConfigurationSetEventDestinationRequest) {
                CreateConfigurationSetEventDestinationRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateConfigurationSetEventDestinationRequest = exports.CreateConfigurationSetEventDestinationRequest || (exports.CreateConfigurationSetEventDestinationRequest = {}));
            var CreateConfigurationSetEventDestinationResponse;
            (function (CreateConfigurationSetEventDestinationResponse) {
                CreateConfigurationSetEventDestinationResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateConfigurationSetEventDestinationResponse = exports.CreateConfigurationSetEventDestinationResponse || (exports.CreateConfigurationSetEventDestinationResponse = {}));

            class EventDestinationAlreadyExistsException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "EventDestinationAlreadyExistsException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "EventDestinationAlreadyExistsException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, EventDestinationAlreadyExistsException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                    this.EventDestinationName = opts.EventDestinationName;
                }
            }

            exports.EventDestinationAlreadyExistsException = EventDestinationAlreadyExistsException;

            class InvalidCloudWatchDestinationException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidCloudWatchDestinationException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidCloudWatchDestinationException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidCloudWatchDestinationException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                    this.EventDestinationName = opts.EventDestinationName;
                }
            }

            exports.InvalidCloudWatchDestinationException = InvalidCloudWatchDestinationException;

            class InvalidFirehoseDestinationException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidFirehoseDestinationException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidFirehoseDestinationException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidFirehoseDestinationException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                    this.EventDestinationName = opts.EventDestinationName;
                }
            }

            exports.InvalidFirehoseDestinationException = InvalidFirehoseDestinationException;

            class InvalidSNSDestinationException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidSNSDestinationException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidSNSDestinationException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidSNSDestinationException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                    this.EventDestinationName = opts.EventDestinationName;
                }
            }

            exports.InvalidSNSDestinationException = InvalidSNSDestinationException;
            var TrackingOptions;
            (function (TrackingOptions) {
                TrackingOptions.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(TrackingOptions = exports.TrackingOptions || (exports.TrackingOptions = {}));
            var CreateConfigurationSetTrackingOptionsRequest;
            (function (CreateConfigurationSetTrackingOptionsRequest) {
                CreateConfigurationSetTrackingOptionsRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateConfigurationSetTrackingOptionsRequest = exports.CreateConfigurationSetTrackingOptionsRequest || (exports.CreateConfigurationSetTrackingOptionsRequest = {}));
            var CreateConfigurationSetTrackingOptionsResponse;
            (function (CreateConfigurationSetTrackingOptionsResponse) {
                CreateConfigurationSetTrackingOptionsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateConfigurationSetTrackingOptionsResponse = exports.CreateConfigurationSetTrackingOptionsResponse || (exports.CreateConfigurationSetTrackingOptionsResponse = {}));

            class InvalidTrackingOptionsException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidTrackingOptionsException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidTrackingOptionsException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidTrackingOptionsException.prototype);
                }
            }

            exports.InvalidTrackingOptionsException = InvalidTrackingOptionsException;

            class TrackingOptionsAlreadyExistsException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "TrackingOptionsAlreadyExistsException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "TrackingOptionsAlreadyExistsException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, TrackingOptionsAlreadyExistsException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                }
            }

            exports.TrackingOptionsAlreadyExistsException = TrackingOptionsAlreadyExistsException;
            var CreateCustomVerificationEmailTemplateRequest;
            (function (CreateCustomVerificationEmailTemplateRequest) {
                CreateCustomVerificationEmailTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateCustomVerificationEmailTemplateRequest = exports.CreateCustomVerificationEmailTemplateRequest || (exports.CreateCustomVerificationEmailTemplateRequest = {}));

            class CustomVerificationEmailInvalidContentException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "CustomVerificationEmailInvalidContentException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "CustomVerificationEmailInvalidContentException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, CustomVerificationEmailInvalidContentException.prototype);
                }
            }

            exports.CustomVerificationEmailInvalidContentException = CustomVerificationEmailInvalidContentException;

            class CustomVerificationEmailTemplateAlreadyExistsException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "CustomVerificationEmailTemplateAlreadyExistsException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "CustomVerificationEmailTemplateAlreadyExistsException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, CustomVerificationEmailTemplateAlreadyExistsException.prototype);
                    this.CustomVerificationEmailTemplateName = opts.CustomVerificationEmailTemplateName;
                }
            }

            exports.CustomVerificationEmailTemplateAlreadyExistsException = CustomVerificationEmailTemplateAlreadyExistsException;

            class FromEmailAddressNotVerifiedException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "FromEmailAddressNotVerifiedException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "FromEmailAddressNotVerifiedException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, FromEmailAddressNotVerifiedException.prototype);
                    this.FromEmailAddress = opts.FromEmailAddress;
                }
            }

            exports.FromEmailAddressNotVerifiedException = FromEmailAddressNotVerifiedException;
            var ReceiptFilterPolicy;
            (function (ReceiptFilterPolicy) {
                ReceiptFilterPolicy["Allow"] = "Allow";
                ReceiptFilterPolicy["Block"] = "Block";
            })(ReceiptFilterPolicy = exports.ReceiptFilterPolicy || (exports.ReceiptFilterPolicy = {}));
            var ReceiptIpFilter;
            (function (ReceiptIpFilter) {
                ReceiptIpFilter.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ReceiptIpFilter = exports.ReceiptIpFilter || (exports.ReceiptIpFilter = {}));
            var ReceiptFilter;
            (function (ReceiptFilter) {
                ReceiptFilter.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ReceiptFilter = exports.ReceiptFilter || (exports.ReceiptFilter = {}));
            var CreateReceiptFilterRequest;
            (function (CreateReceiptFilterRequest) {
                CreateReceiptFilterRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateReceiptFilterRequest = exports.CreateReceiptFilterRequest || (exports.CreateReceiptFilterRequest = {}));
            var CreateReceiptFilterResponse;
            (function (CreateReceiptFilterResponse) {
                CreateReceiptFilterResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateReceiptFilterResponse = exports.CreateReceiptFilterResponse || (exports.CreateReceiptFilterResponse = {}));
            var LambdaAction;
            (function (LambdaAction) {
                LambdaAction.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(LambdaAction = exports.LambdaAction || (exports.LambdaAction = {}));
            var S3Action;
            (function (S3Action) {
                S3Action.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(S3Action = exports.S3Action || (exports.S3Action = {}));
            var SNSActionEncoding;
            (function (SNSActionEncoding) {
                SNSActionEncoding["Base64"] = "Base64";
                SNSActionEncoding["UTF8"] = "UTF-8";
            })(SNSActionEncoding = exports.SNSActionEncoding || (exports.SNSActionEncoding = {}));
            var SNSAction;
            (function (SNSAction) {
                SNSAction.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SNSAction = exports.SNSAction || (exports.SNSAction = {}));
            var StopScope;
            (function (StopScope) {
                StopScope["RULE_SET"] = "RuleSet";
            })(StopScope = exports.StopScope || (exports.StopScope = {}));
            var StopAction;
            (function (StopAction) {
                StopAction.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(StopAction = exports.StopAction || (exports.StopAction = {}));
            var WorkmailAction;
            (function (WorkmailAction) {
                WorkmailAction.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(WorkmailAction = exports.WorkmailAction || (exports.WorkmailAction = {}));
            var ReceiptAction;
            (function (ReceiptAction) {
                ReceiptAction.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ReceiptAction = exports.ReceiptAction || (exports.ReceiptAction = {}));
            var TlsPolicy;
            (function (TlsPolicy) {
                TlsPolicy["Optional"] = "Optional";
                TlsPolicy["Require"] = "Require";
            })(TlsPolicy = exports.TlsPolicy || (exports.TlsPolicy = {}));
            var ReceiptRule;
            (function (ReceiptRule) {
                ReceiptRule.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ReceiptRule = exports.ReceiptRule || (exports.ReceiptRule = {}));
            var CreateReceiptRuleRequest;
            (function (CreateReceiptRuleRequest) {
                CreateReceiptRuleRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateReceiptRuleRequest = exports.CreateReceiptRuleRequest || (exports.CreateReceiptRuleRequest = {}));
            var CreateReceiptRuleResponse;
            (function (CreateReceiptRuleResponse) {
                CreateReceiptRuleResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateReceiptRuleResponse = exports.CreateReceiptRuleResponse || (exports.CreateReceiptRuleResponse = {}));

            class InvalidLambdaFunctionException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidLambdaFunctionException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidLambdaFunctionException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidLambdaFunctionException.prototype);
                    this.FunctionArn = opts.FunctionArn;
                }
            }

            exports.InvalidLambdaFunctionException = InvalidLambdaFunctionException;

            class InvalidS3ConfigurationException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidS3ConfigurationException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidS3ConfigurationException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidS3ConfigurationException.prototype);
                    this.Bucket = opts.Bucket;
                }
            }

            exports.InvalidS3ConfigurationException = InvalidS3ConfigurationException;

            class InvalidSnsTopicException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidSnsTopicException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidSnsTopicException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidSnsTopicException.prototype);
                    this.Topic = opts.Topic;
                }
            }

            exports.InvalidSnsTopicException = InvalidSnsTopicException;

            class RuleDoesNotExistException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "RuleDoesNotExistException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "RuleDoesNotExistException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, RuleDoesNotExistException.prototype);
                    this.Name = opts.Name;
                }
            }

            exports.RuleDoesNotExistException = RuleDoesNotExistException;
            var CreateReceiptRuleSetRequest;
            (function (CreateReceiptRuleSetRequest) {
                CreateReceiptRuleSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateReceiptRuleSetRequest = exports.CreateReceiptRuleSetRequest || (exports.CreateReceiptRuleSetRequest = {}));
            var CreateReceiptRuleSetResponse;
            (function (CreateReceiptRuleSetResponse) {
                CreateReceiptRuleSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateReceiptRuleSetResponse = exports.CreateReceiptRuleSetResponse || (exports.CreateReceiptRuleSetResponse = {}));
            var Template;
            (function (Template) {
                Template.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(Template = exports.Template || (exports.Template = {}));
            var CreateTemplateRequest;
            (function (CreateTemplateRequest) {
                CreateTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateTemplateRequest = exports.CreateTemplateRequest || (exports.CreateTemplateRequest = {}));
            var CreateTemplateResponse;
            (function (CreateTemplateResponse) {
                CreateTemplateResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CreateTemplateResponse = exports.CreateTemplateResponse || (exports.CreateTemplateResponse = {}));

            class InvalidTemplateException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidTemplateException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidTemplateException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidTemplateException.prototype);
                    this.TemplateName = opts.TemplateName;
                }
            }

            exports.InvalidTemplateException = InvalidTemplateException;
            var CustomMailFromStatus;
            (function (CustomMailFromStatus) {
                CustomMailFromStatus["Failed"] = "Failed";
                CustomMailFromStatus["Pending"] = "Pending";
                CustomMailFromStatus["Success"] = "Success";
                CustomMailFromStatus["TemporaryFailure"] = "TemporaryFailure";
            })(CustomMailFromStatus = exports.CustomMailFromStatus || (exports.CustomMailFromStatus = {}));
            var CustomVerificationEmailTemplate;
            (function (CustomVerificationEmailTemplate) {
                CustomVerificationEmailTemplate.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(CustomVerificationEmailTemplate = exports.CustomVerificationEmailTemplate || (exports.CustomVerificationEmailTemplate = {}));

            class CustomVerificationEmailTemplateDoesNotExistException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "CustomVerificationEmailTemplateDoesNotExistException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "CustomVerificationEmailTemplateDoesNotExistException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, CustomVerificationEmailTemplateDoesNotExistException.prototype);
                    this.CustomVerificationEmailTemplateName = opts.CustomVerificationEmailTemplateName;
                }
            }

            exports.CustomVerificationEmailTemplateDoesNotExistException = CustomVerificationEmailTemplateDoesNotExistException;
            var DeleteConfigurationSetRequest;
            (function (DeleteConfigurationSetRequest) {
                DeleteConfigurationSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteConfigurationSetRequest = exports.DeleteConfigurationSetRequest || (exports.DeleteConfigurationSetRequest = {}));
            var DeleteConfigurationSetResponse;
            (function (DeleteConfigurationSetResponse) {
                DeleteConfigurationSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteConfigurationSetResponse = exports.DeleteConfigurationSetResponse || (exports.DeleteConfigurationSetResponse = {}));
            var DeleteConfigurationSetEventDestinationRequest;
            (function (DeleteConfigurationSetEventDestinationRequest) {
                DeleteConfigurationSetEventDestinationRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteConfigurationSetEventDestinationRequest = exports.DeleteConfigurationSetEventDestinationRequest || (exports.DeleteConfigurationSetEventDestinationRequest = {}));
            var DeleteConfigurationSetEventDestinationResponse;
            (function (DeleteConfigurationSetEventDestinationResponse) {
                DeleteConfigurationSetEventDestinationResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteConfigurationSetEventDestinationResponse = exports.DeleteConfigurationSetEventDestinationResponse || (exports.DeleteConfigurationSetEventDestinationResponse = {}));

            class EventDestinationDoesNotExistException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "EventDestinationDoesNotExistException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "EventDestinationDoesNotExistException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, EventDestinationDoesNotExistException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                    this.EventDestinationName = opts.EventDestinationName;
                }
            }

            exports.EventDestinationDoesNotExistException = EventDestinationDoesNotExistException;
            var DeleteConfigurationSetTrackingOptionsRequest;
            (function (DeleteConfigurationSetTrackingOptionsRequest) {
                DeleteConfigurationSetTrackingOptionsRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteConfigurationSetTrackingOptionsRequest = exports.DeleteConfigurationSetTrackingOptionsRequest || (exports.DeleteConfigurationSetTrackingOptionsRequest = {}));
            var DeleteConfigurationSetTrackingOptionsResponse;
            (function (DeleteConfigurationSetTrackingOptionsResponse) {
                DeleteConfigurationSetTrackingOptionsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteConfigurationSetTrackingOptionsResponse = exports.DeleteConfigurationSetTrackingOptionsResponse || (exports.DeleteConfigurationSetTrackingOptionsResponse = {}));

            class TrackingOptionsDoesNotExistException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "TrackingOptionsDoesNotExistException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "TrackingOptionsDoesNotExistException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, TrackingOptionsDoesNotExistException.prototype);
                    this.ConfigurationSetName = opts.ConfigurationSetName;
                }
            }

            exports.TrackingOptionsDoesNotExistException = TrackingOptionsDoesNotExistException;
            var DeleteCustomVerificationEmailTemplateRequest;
            (function (DeleteCustomVerificationEmailTemplateRequest) {
                DeleteCustomVerificationEmailTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteCustomVerificationEmailTemplateRequest = exports.DeleteCustomVerificationEmailTemplateRequest || (exports.DeleteCustomVerificationEmailTemplateRequest = {}));
            var DeleteIdentityRequest;
            (function (DeleteIdentityRequest) {
                DeleteIdentityRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteIdentityRequest = exports.DeleteIdentityRequest || (exports.DeleteIdentityRequest = {}));
            var DeleteIdentityResponse;
            (function (DeleteIdentityResponse) {
                DeleteIdentityResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteIdentityResponse = exports.DeleteIdentityResponse || (exports.DeleteIdentityResponse = {}));
            var DeleteIdentityPolicyRequest;
            (function (DeleteIdentityPolicyRequest) {
                DeleteIdentityPolicyRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteIdentityPolicyRequest = exports.DeleteIdentityPolicyRequest || (exports.DeleteIdentityPolicyRequest = {}));
            var DeleteIdentityPolicyResponse;
            (function (DeleteIdentityPolicyResponse) {
                DeleteIdentityPolicyResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteIdentityPolicyResponse = exports.DeleteIdentityPolicyResponse || (exports.DeleteIdentityPolicyResponse = {}));
            var DeleteReceiptFilterRequest;
            (function (DeleteReceiptFilterRequest) {
                DeleteReceiptFilterRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteReceiptFilterRequest = exports.DeleteReceiptFilterRequest || (exports.DeleteReceiptFilterRequest = {}));
            var DeleteReceiptFilterResponse;
            (function (DeleteReceiptFilterResponse) {
                DeleteReceiptFilterResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteReceiptFilterResponse = exports.DeleteReceiptFilterResponse || (exports.DeleteReceiptFilterResponse = {}));
            var DeleteReceiptRuleRequest;
            (function (DeleteReceiptRuleRequest) {
                DeleteReceiptRuleRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteReceiptRuleRequest = exports.DeleteReceiptRuleRequest || (exports.DeleteReceiptRuleRequest = {}));
            var DeleteReceiptRuleResponse;
            (function (DeleteReceiptRuleResponse) {
                DeleteReceiptRuleResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteReceiptRuleResponse = exports.DeleteReceiptRuleResponse || (exports.DeleteReceiptRuleResponse = {}));
            var DeleteReceiptRuleSetRequest;
            (function (DeleteReceiptRuleSetRequest) {
                DeleteReceiptRuleSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteReceiptRuleSetRequest = exports.DeleteReceiptRuleSetRequest || (exports.DeleteReceiptRuleSetRequest = {}));
            var DeleteReceiptRuleSetResponse;
            (function (DeleteReceiptRuleSetResponse) {
                DeleteReceiptRuleSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteReceiptRuleSetResponse = exports.DeleteReceiptRuleSetResponse || (exports.DeleteReceiptRuleSetResponse = {}));
            var DeleteTemplateRequest;
            (function (DeleteTemplateRequest) {
                DeleteTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteTemplateRequest = exports.DeleteTemplateRequest || (exports.DeleteTemplateRequest = {}));
            var DeleteTemplateResponse;
            (function (DeleteTemplateResponse) {
                DeleteTemplateResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteTemplateResponse = exports.DeleteTemplateResponse || (exports.DeleteTemplateResponse = {}));
            var DeleteVerifiedEmailAddressRequest;
            (function (DeleteVerifiedEmailAddressRequest) {
                DeleteVerifiedEmailAddressRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeleteVerifiedEmailAddressRequest = exports.DeleteVerifiedEmailAddressRequest || (exports.DeleteVerifiedEmailAddressRequest = {}));
            var DeliveryOptions;
            (function (DeliveryOptions) {
                DeliveryOptions.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DeliveryOptions = exports.DeliveryOptions || (exports.DeliveryOptions = {}));
            var DescribeActiveReceiptRuleSetRequest;
            (function (DescribeActiveReceiptRuleSetRequest) {
                DescribeActiveReceiptRuleSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DescribeActiveReceiptRuleSetRequest = exports.DescribeActiveReceiptRuleSetRequest || (exports.DescribeActiveReceiptRuleSetRequest = {}));
            var ReceiptRuleSetMetadata;
            (function (ReceiptRuleSetMetadata) {
                ReceiptRuleSetMetadata.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ReceiptRuleSetMetadata = exports.ReceiptRuleSetMetadata || (exports.ReceiptRuleSetMetadata = {}));
            var DescribeActiveReceiptRuleSetResponse;
            (function (DescribeActiveReceiptRuleSetResponse) {
                DescribeActiveReceiptRuleSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DescribeActiveReceiptRuleSetResponse = exports.DescribeActiveReceiptRuleSetResponse || (exports.DescribeActiveReceiptRuleSetResponse = {}));
            var DescribeConfigurationSetRequest;
            (function (DescribeConfigurationSetRequest) {
                DescribeConfigurationSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DescribeConfigurationSetRequest = exports.DescribeConfigurationSetRequest || (exports.DescribeConfigurationSetRequest = {}));
            var ReputationOptions;
            (function (ReputationOptions) {
                ReputationOptions.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ReputationOptions = exports.ReputationOptions || (exports.ReputationOptions = {}));
            var DescribeConfigurationSetResponse;
            (function (DescribeConfigurationSetResponse) {
                DescribeConfigurationSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DescribeConfigurationSetResponse = exports.DescribeConfigurationSetResponse || (exports.DescribeConfigurationSetResponse = {}));
            var DescribeReceiptRuleRequest;
            (function (DescribeReceiptRuleRequest) {
                DescribeReceiptRuleRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DescribeReceiptRuleRequest = exports.DescribeReceiptRuleRequest || (exports.DescribeReceiptRuleRequest = {}));
            var DescribeReceiptRuleResponse;
            (function (DescribeReceiptRuleResponse) {
                DescribeReceiptRuleResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DescribeReceiptRuleResponse = exports.DescribeReceiptRuleResponse || (exports.DescribeReceiptRuleResponse = {}));
            var DescribeReceiptRuleSetRequest;
            (function (DescribeReceiptRuleSetRequest) {
                DescribeReceiptRuleSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DescribeReceiptRuleSetRequest = exports.DescribeReceiptRuleSetRequest || (exports.DescribeReceiptRuleSetRequest = {}));
            var DescribeReceiptRuleSetResponse;
            (function (DescribeReceiptRuleSetResponse) {
                DescribeReceiptRuleSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DescribeReceiptRuleSetResponse = exports.DescribeReceiptRuleSetResponse || (exports.DescribeReceiptRuleSetResponse = {}));
            var IdentityDkimAttributes;
            (function (IdentityDkimAttributes) {
                IdentityDkimAttributes.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(IdentityDkimAttributes = exports.IdentityDkimAttributes || (exports.IdentityDkimAttributes = {}));
            var GetAccountSendingEnabledResponse;
            (function (GetAccountSendingEnabledResponse) {
                GetAccountSendingEnabledResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetAccountSendingEnabledResponse = exports.GetAccountSendingEnabledResponse || (exports.GetAccountSendingEnabledResponse = {}));
            var GetCustomVerificationEmailTemplateRequest;
            (function (GetCustomVerificationEmailTemplateRequest) {
                GetCustomVerificationEmailTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetCustomVerificationEmailTemplateRequest = exports.GetCustomVerificationEmailTemplateRequest || (exports.GetCustomVerificationEmailTemplateRequest = {}));
            var GetCustomVerificationEmailTemplateResponse;
            (function (GetCustomVerificationEmailTemplateResponse) {
                GetCustomVerificationEmailTemplateResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetCustomVerificationEmailTemplateResponse = exports.GetCustomVerificationEmailTemplateResponse || (exports.GetCustomVerificationEmailTemplateResponse = {}));
            var GetIdentityDkimAttributesRequest;
            (function (GetIdentityDkimAttributesRequest) {
                GetIdentityDkimAttributesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityDkimAttributesRequest = exports.GetIdentityDkimAttributesRequest || (exports.GetIdentityDkimAttributesRequest = {}));
            var GetIdentityDkimAttributesResponse;
            (function (GetIdentityDkimAttributesResponse) {
                GetIdentityDkimAttributesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityDkimAttributesResponse = exports.GetIdentityDkimAttributesResponse || (exports.GetIdentityDkimAttributesResponse = {}));
            var GetIdentityMailFromDomainAttributesRequest;
            (function (GetIdentityMailFromDomainAttributesRequest) {
                GetIdentityMailFromDomainAttributesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityMailFromDomainAttributesRequest = exports.GetIdentityMailFromDomainAttributesRequest || (exports.GetIdentityMailFromDomainAttributesRequest = {}));
            var IdentityMailFromDomainAttributes;
            (function (IdentityMailFromDomainAttributes) {
                IdentityMailFromDomainAttributes.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(IdentityMailFromDomainAttributes = exports.IdentityMailFromDomainAttributes || (exports.IdentityMailFromDomainAttributes = {}));
            var GetIdentityMailFromDomainAttributesResponse;
            (function (GetIdentityMailFromDomainAttributesResponse) {
                GetIdentityMailFromDomainAttributesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityMailFromDomainAttributesResponse = exports.GetIdentityMailFromDomainAttributesResponse || (exports.GetIdentityMailFromDomainAttributesResponse = {}));
            var GetIdentityNotificationAttributesRequest;
            (function (GetIdentityNotificationAttributesRequest) {
                GetIdentityNotificationAttributesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityNotificationAttributesRequest = exports.GetIdentityNotificationAttributesRequest || (exports.GetIdentityNotificationAttributesRequest = {}));
            var IdentityNotificationAttributes;
            (function (IdentityNotificationAttributes) {
                IdentityNotificationAttributes.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(IdentityNotificationAttributes = exports.IdentityNotificationAttributes || (exports.IdentityNotificationAttributes = {}));
            var GetIdentityNotificationAttributesResponse;
            (function (GetIdentityNotificationAttributesResponse) {
                GetIdentityNotificationAttributesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityNotificationAttributesResponse = exports.GetIdentityNotificationAttributesResponse || (exports.GetIdentityNotificationAttributesResponse = {}));
            var GetIdentityPoliciesRequest;
            (function (GetIdentityPoliciesRequest) {
                GetIdentityPoliciesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityPoliciesRequest = exports.GetIdentityPoliciesRequest || (exports.GetIdentityPoliciesRequest = {}));
            var GetIdentityPoliciesResponse;
            (function (GetIdentityPoliciesResponse) {
                GetIdentityPoliciesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityPoliciesResponse = exports.GetIdentityPoliciesResponse || (exports.GetIdentityPoliciesResponse = {}));
            var GetIdentityVerificationAttributesRequest;
            (function (GetIdentityVerificationAttributesRequest) {
                GetIdentityVerificationAttributesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityVerificationAttributesRequest = exports.GetIdentityVerificationAttributesRequest || (exports.GetIdentityVerificationAttributesRequest = {}));
            var IdentityVerificationAttributes;
            (function (IdentityVerificationAttributes) {
                IdentityVerificationAttributes.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(IdentityVerificationAttributes = exports.IdentityVerificationAttributes || (exports.IdentityVerificationAttributes = {}));
            var GetIdentityVerificationAttributesResponse;
            (function (GetIdentityVerificationAttributesResponse) {
                GetIdentityVerificationAttributesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetIdentityVerificationAttributesResponse = exports.GetIdentityVerificationAttributesResponse || (exports.GetIdentityVerificationAttributesResponse = {}));
            var GetSendQuotaResponse;
            (function (GetSendQuotaResponse) {
                GetSendQuotaResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetSendQuotaResponse = exports.GetSendQuotaResponse || (exports.GetSendQuotaResponse = {}));
            var SendDataPoint;
            (function (SendDataPoint) {
                SendDataPoint.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendDataPoint = exports.SendDataPoint || (exports.SendDataPoint = {}));
            var GetSendStatisticsResponse;
            (function (GetSendStatisticsResponse) {
                GetSendStatisticsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetSendStatisticsResponse = exports.GetSendStatisticsResponse || (exports.GetSendStatisticsResponse = {}));
            var GetTemplateRequest;
            (function (GetTemplateRequest) {
                GetTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetTemplateRequest = exports.GetTemplateRequest || (exports.GetTemplateRequest = {}));
            var GetTemplateResponse;
            (function (GetTemplateResponse) {
                GetTemplateResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetTemplateResponse = exports.GetTemplateResponse || (exports.GetTemplateResponse = {}));

            class TemplateDoesNotExistException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "TemplateDoesNotExistException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "TemplateDoesNotExistException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, TemplateDoesNotExistException.prototype);
                    this.TemplateName = opts.TemplateName;
                }
            }

            exports.TemplateDoesNotExistException = TemplateDoesNotExistException;

            class InvalidDeliveryOptionsException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidDeliveryOptionsException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidDeliveryOptionsException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidDeliveryOptionsException.prototype);
                }
            }

            exports.InvalidDeliveryOptionsException = InvalidDeliveryOptionsException;

            class InvalidPolicyException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidPolicyException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidPolicyException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidPolicyException.prototype);
                }
            }

            exports.InvalidPolicyException = InvalidPolicyException;

            class InvalidRenderingParameterException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidRenderingParameterException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidRenderingParameterException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidRenderingParameterException.prototype);
                    this.TemplateName = opts.TemplateName;
                }
            }

            exports.InvalidRenderingParameterException = InvalidRenderingParameterException;
            var ListConfigurationSetsRequest;
            (function (ListConfigurationSetsRequest) {
                ListConfigurationSetsRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListConfigurationSetsRequest = exports.ListConfigurationSetsRequest || (exports.ListConfigurationSetsRequest = {}));
            var ListConfigurationSetsResponse;
            (function (ListConfigurationSetsResponse) {
                ListConfigurationSetsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListConfigurationSetsResponse = exports.ListConfigurationSetsResponse || (exports.ListConfigurationSetsResponse = {}));
            var ListCustomVerificationEmailTemplatesRequest;
            (function (ListCustomVerificationEmailTemplatesRequest) {
                ListCustomVerificationEmailTemplatesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListCustomVerificationEmailTemplatesRequest = exports.ListCustomVerificationEmailTemplatesRequest || (exports.ListCustomVerificationEmailTemplatesRequest = {}));
            var ListCustomVerificationEmailTemplatesResponse;
            (function (ListCustomVerificationEmailTemplatesResponse) {
                ListCustomVerificationEmailTemplatesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListCustomVerificationEmailTemplatesResponse = exports.ListCustomVerificationEmailTemplatesResponse || (exports.ListCustomVerificationEmailTemplatesResponse = {}));
            var ListIdentitiesRequest;
            (function (ListIdentitiesRequest) {
                ListIdentitiesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListIdentitiesRequest = exports.ListIdentitiesRequest || (exports.ListIdentitiesRequest = {}));
            var ListIdentitiesResponse;
            (function (ListIdentitiesResponse) {
                ListIdentitiesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListIdentitiesResponse = exports.ListIdentitiesResponse || (exports.ListIdentitiesResponse = {}));
            var ListIdentityPoliciesRequest;
            (function (ListIdentityPoliciesRequest) {
                ListIdentityPoliciesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListIdentityPoliciesRequest = exports.ListIdentityPoliciesRequest || (exports.ListIdentityPoliciesRequest = {}));
            var ListIdentityPoliciesResponse;
            (function (ListIdentityPoliciesResponse) {
                ListIdentityPoliciesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListIdentityPoliciesResponse = exports.ListIdentityPoliciesResponse || (exports.ListIdentityPoliciesResponse = {}));
            var ListReceiptFiltersRequest;
            (function (ListReceiptFiltersRequest) {
                ListReceiptFiltersRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListReceiptFiltersRequest = exports.ListReceiptFiltersRequest || (exports.ListReceiptFiltersRequest = {}));
            var ListReceiptFiltersResponse;
            (function (ListReceiptFiltersResponse) {
                ListReceiptFiltersResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListReceiptFiltersResponse = exports.ListReceiptFiltersResponse || (exports.ListReceiptFiltersResponse = {}));
            var ListReceiptRuleSetsRequest;
            (function (ListReceiptRuleSetsRequest) {
                ListReceiptRuleSetsRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListReceiptRuleSetsRequest = exports.ListReceiptRuleSetsRequest || (exports.ListReceiptRuleSetsRequest = {}));
            var ListReceiptRuleSetsResponse;
            (function (ListReceiptRuleSetsResponse) {
                ListReceiptRuleSetsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListReceiptRuleSetsResponse = exports.ListReceiptRuleSetsResponse || (exports.ListReceiptRuleSetsResponse = {}));
            var ListTemplatesRequest;
            (function (ListTemplatesRequest) {
                ListTemplatesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListTemplatesRequest = exports.ListTemplatesRequest || (exports.ListTemplatesRequest = {}));
            var TemplateMetadata;
            (function (TemplateMetadata) {
                TemplateMetadata.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(TemplateMetadata = exports.TemplateMetadata || (exports.TemplateMetadata = {}));
            var ListTemplatesResponse;
            (function (ListTemplatesResponse) {
                ListTemplatesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListTemplatesResponse = exports.ListTemplatesResponse || (exports.ListTemplatesResponse = {}));
            var ListVerifiedEmailAddressesResponse;
            (function (ListVerifiedEmailAddressesResponse) {
                ListVerifiedEmailAddressesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListVerifiedEmailAddressesResponse = exports.ListVerifiedEmailAddressesResponse || (exports.ListVerifiedEmailAddressesResponse = {}));

            class MailFromDomainNotVerifiedException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "MailFromDomainNotVerifiedException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "MailFromDomainNotVerifiedException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, MailFromDomainNotVerifiedException.prototype);
                }
            }

            exports.MailFromDomainNotVerifiedException = MailFromDomainNotVerifiedException;
            var Message;
            (function (Message) {
                Message.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(Message = exports.Message || (exports.Message = {}));
            var MessageDsn;
            (function (MessageDsn) {
                MessageDsn.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(MessageDsn = exports.MessageDsn || (exports.MessageDsn = {}));

            class MessageRejected extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "MessageRejected",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "MessageRejected";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, MessageRejected.prototype);
                }
            }

            exports.MessageRejected = MessageRejected;

            class MissingRenderingAttributeException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "MissingRenderingAttributeException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "MissingRenderingAttributeException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, MissingRenderingAttributeException.prototype);
                    this.TemplateName = opts.TemplateName;
                }
            }

            exports.MissingRenderingAttributeException = MissingRenderingAttributeException;

            class ProductionAccessNotGrantedException extends SESServiceException_1.SESServiceException {
                constructor(opts) {
                    super({
                        name: "ProductionAccessNotGrantedException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "ProductionAccessNotGrantedException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, ProductionAccessNotGrantedException.prototype);
                }
            }

            exports.ProductionAccessNotGrantedException = ProductionAccessNotGrantedException;
            var PutConfigurationSetDeliveryOptionsRequest;
            (function (PutConfigurationSetDeliveryOptionsRequest) {
                PutConfigurationSetDeliveryOptionsRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(PutConfigurationSetDeliveryOptionsRequest = exports.PutConfigurationSetDeliveryOptionsRequest || (exports.PutConfigurationSetDeliveryOptionsRequest = {}));
            var PutConfigurationSetDeliveryOptionsResponse;
            (function (PutConfigurationSetDeliveryOptionsResponse) {
                PutConfigurationSetDeliveryOptionsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(PutConfigurationSetDeliveryOptionsResponse = exports.PutConfigurationSetDeliveryOptionsResponse || (exports.PutConfigurationSetDeliveryOptionsResponse = {}));
            var PutIdentityPolicyRequest;
            (function (PutIdentityPolicyRequest) {
                PutIdentityPolicyRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(PutIdentityPolicyRequest = exports.PutIdentityPolicyRequest || (exports.PutIdentityPolicyRequest = {}));
            var PutIdentityPolicyResponse;
            (function (PutIdentityPolicyResponse) {
                PutIdentityPolicyResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(PutIdentityPolicyResponse = exports.PutIdentityPolicyResponse || (exports.PutIdentityPolicyResponse = {}));
            var RawMessage;
            (function (RawMessage) {
                RawMessage.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(RawMessage = exports.RawMessage || (exports.RawMessage = {}));
            var ReorderReceiptRuleSetRequest;
            (function (ReorderReceiptRuleSetRequest) {
                ReorderReceiptRuleSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ReorderReceiptRuleSetRequest = exports.ReorderReceiptRuleSetRequest || (exports.ReorderReceiptRuleSetRequest = {}));
            var ReorderReceiptRuleSetResponse;
            (function (ReorderReceiptRuleSetResponse) {
                ReorderReceiptRuleSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ReorderReceiptRuleSetResponse = exports.ReorderReceiptRuleSetResponse || (exports.ReorderReceiptRuleSetResponse = {}));
            var SendBounceRequest;
            (function (SendBounceRequest) {
                SendBounceRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendBounceRequest = exports.SendBounceRequest || (exports.SendBounceRequest = {}));
            var SendBounceResponse;
            (function (SendBounceResponse) {
                SendBounceResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendBounceResponse = exports.SendBounceResponse || (exports.SendBounceResponse = {}));
            var SendBulkTemplatedEmailRequest;
            (function (SendBulkTemplatedEmailRequest) {
                SendBulkTemplatedEmailRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendBulkTemplatedEmailRequest = exports.SendBulkTemplatedEmailRequest || (exports.SendBulkTemplatedEmailRequest = {}));
            var SendBulkTemplatedEmailResponse;
            (function (SendBulkTemplatedEmailResponse) {
                SendBulkTemplatedEmailResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendBulkTemplatedEmailResponse = exports.SendBulkTemplatedEmailResponse || (exports.SendBulkTemplatedEmailResponse = {}));
            var SendCustomVerificationEmailRequest;
            (function (SendCustomVerificationEmailRequest) {
                SendCustomVerificationEmailRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendCustomVerificationEmailRequest = exports.SendCustomVerificationEmailRequest || (exports.SendCustomVerificationEmailRequest = {}));
            var SendCustomVerificationEmailResponse;
            (function (SendCustomVerificationEmailResponse) {
                SendCustomVerificationEmailResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendCustomVerificationEmailResponse = exports.SendCustomVerificationEmailResponse || (exports.SendCustomVerificationEmailResponse = {}));
            var SendEmailRequest;
            (function (SendEmailRequest) {
                SendEmailRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendEmailRequest = exports.SendEmailRequest || (exports.SendEmailRequest = {}));
            var SendEmailResponse;
            (function (SendEmailResponse) {
                SendEmailResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendEmailResponse = exports.SendEmailResponse || (exports.SendEmailResponse = {}));
            var SendRawEmailRequest;
            (function (SendRawEmailRequest) {
                SendRawEmailRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendRawEmailRequest = exports.SendRawEmailRequest || (exports.SendRawEmailRequest = {}));
            var SendRawEmailResponse;
            (function (SendRawEmailResponse) {
                SendRawEmailResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendRawEmailResponse = exports.SendRawEmailResponse || (exports.SendRawEmailResponse = {}));
            var SendTemplatedEmailRequest;
            (function (SendTemplatedEmailRequest) {
                SendTemplatedEmailRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendTemplatedEmailRequest = exports.SendTemplatedEmailRequest || (exports.SendTemplatedEmailRequest = {}));
            var SendTemplatedEmailResponse;
            (function (SendTemplatedEmailResponse) {
                SendTemplatedEmailResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SendTemplatedEmailResponse = exports.SendTemplatedEmailResponse || (exports.SendTemplatedEmailResponse = {}));
            var SetActiveReceiptRuleSetRequest;
            (function (SetActiveReceiptRuleSetRequest) {
                SetActiveReceiptRuleSetRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetActiveReceiptRuleSetRequest = exports.SetActiveReceiptRuleSetRequest || (exports.SetActiveReceiptRuleSetRequest = {}));
            var SetActiveReceiptRuleSetResponse;
            (function (SetActiveReceiptRuleSetResponse) {
                SetActiveReceiptRuleSetResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetActiveReceiptRuleSetResponse = exports.SetActiveReceiptRuleSetResponse || (exports.SetActiveReceiptRuleSetResponse = {}));
            var SetIdentityDkimEnabledRequest;
            (function (SetIdentityDkimEnabledRequest) {
                SetIdentityDkimEnabledRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityDkimEnabledRequest = exports.SetIdentityDkimEnabledRequest || (exports.SetIdentityDkimEnabledRequest = {}));
            var SetIdentityDkimEnabledResponse;
            (function (SetIdentityDkimEnabledResponse) {
                SetIdentityDkimEnabledResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityDkimEnabledResponse = exports.SetIdentityDkimEnabledResponse || (exports.SetIdentityDkimEnabledResponse = {}));
            var SetIdentityFeedbackForwardingEnabledRequest;
            (function (SetIdentityFeedbackForwardingEnabledRequest) {
                SetIdentityFeedbackForwardingEnabledRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityFeedbackForwardingEnabledRequest = exports.SetIdentityFeedbackForwardingEnabledRequest || (exports.SetIdentityFeedbackForwardingEnabledRequest = {}));
            var SetIdentityFeedbackForwardingEnabledResponse;
            (function (SetIdentityFeedbackForwardingEnabledResponse) {
                SetIdentityFeedbackForwardingEnabledResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityFeedbackForwardingEnabledResponse = exports.SetIdentityFeedbackForwardingEnabledResponse || (exports.SetIdentityFeedbackForwardingEnabledResponse = {}));
            var SetIdentityHeadersInNotificationsEnabledRequest;
            (function (SetIdentityHeadersInNotificationsEnabledRequest) {
                SetIdentityHeadersInNotificationsEnabledRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityHeadersInNotificationsEnabledRequest = exports.SetIdentityHeadersInNotificationsEnabledRequest || (exports.SetIdentityHeadersInNotificationsEnabledRequest = {}));
            var SetIdentityHeadersInNotificationsEnabledResponse;
            (function (SetIdentityHeadersInNotificationsEnabledResponse) {
                SetIdentityHeadersInNotificationsEnabledResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityHeadersInNotificationsEnabledResponse = exports.SetIdentityHeadersInNotificationsEnabledResponse || (exports.SetIdentityHeadersInNotificationsEnabledResponse = {}));
            var SetIdentityMailFromDomainRequest;
            (function (SetIdentityMailFromDomainRequest) {
                SetIdentityMailFromDomainRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityMailFromDomainRequest = exports.SetIdentityMailFromDomainRequest || (exports.SetIdentityMailFromDomainRequest = {}));
            var SetIdentityMailFromDomainResponse;
            (function (SetIdentityMailFromDomainResponse) {
                SetIdentityMailFromDomainResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityMailFromDomainResponse = exports.SetIdentityMailFromDomainResponse || (exports.SetIdentityMailFromDomainResponse = {}));
            var SetIdentityNotificationTopicRequest;
            (function (SetIdentityNotificationTopicRequest) {
                SetIdentityNotificationTopicRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityNotificationTopicRequest = exports.SetIdentityNotificationTopicRequest || (exports.SetIdentityNotificationTopicRequest = {}));
            var SetIdentityNotificationTopicResponse;
            (function (SetIdentityNotificationTopicResponse) {
                SetIdentityNotificationTopicResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetIdentityNotificationTopicResponse = exports.SetIdentityNotificationTopicResponse || (exports.SetIdentityNotificationTopicResponse = {}));
            var SetReceiptRulePositionRequest;
            (function (SetReceiptRulePositionRequest) {
                SetReceiptRulePositionRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetReceiptRulePositionRequest = exports.SetReceiptRulePositionRequest || (exports.SetReceiptRulePositionRequest = {}));
            var SetReceiptRulePositionResponse;
            (function (SetReceiptRulePositionResponse) {
                SetReceiptRulePositionResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(SetReceiptRulePositionResponse = exports.SetReceiptRulePositionResponse || (exports.SetReceiptRulePositionResponse = {}));
            var TestRenderTemplateRequest;
            (function (TestRenderTemplateRequest) {
                TestRenderTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(TestRenderTemplateRequest = exports.TestRenderTemplateRequest || (exports.TestRenderTemplateRequest = {}));
            var TestRenderTemplateResponse;
            (function (TestRenderTemplateResponse) {
                TestRenderTemplateResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(TestRenderTemplateResponse = exports.TestRenderTemplateResponse || (exports.TestRenderTemplateResponse = {}));
            var UpdateAccountSendingEnabledRequest;
            (function (UpdateAccountSendingEnabledRequest) {
                UpdateAccountSendingEnabledRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateAccountSendingEnabledRequest = exports.UpdateAccountSendingEnabledRequest || (exports.UpdateAccountSendingEnabledRequest = {}));
            var UpdateConfigurationSetEventDestinationRequest;
            (function (UpdateConfigurationSetEventDestinationRequest) {
                UpdateConfigurationSetEventDestinationRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateConfigurationSetEventDestinationRequest = exports.UpdateConfigurationSetEventDestinationRequest || (exports.UpdateConfigurationSetEventDestinationRequest = {}));
            var UpdateConfigurationSetEventDestinationResponse;
            (function (UpdateConfigurationSetEventDestinationResponse) {
                UpdateConfigurationSetEventDestinationResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateConfigurationSetEventDestinationResponse = exports.UpdateConfigurationSetEventDestinationResponse || (exports.UpdateConfigurationSetEventDestinationResponse = {}));
            var UpdateConfigurationSetReputationMetricsEnabledRequest;
            (function (UpdateConfigurationSetReputationMetricsEnabledRequest) {
                UpdateConfigurationSetReputationMetricsEnabledRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateConfigurationSetReputationMetricsEnabledRequest = exports.UpdateConfigurationSetReputationMetricsEnabledRequest || (exports.UpdateConfigurationSetReputationMetricsEnabledRequest = {}));
            var UpdateConfigurationSetSendingEnabledRequest;
            (function (UpdateConfigurationSetSendingEnabledRequest) {
                UpdateConfigurationSetSendingEnabledRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateConfigurationSetSendingEnabledRequest = exports.UpdateConfigurationSetSendingEnabledRequest || (exports.UpdateConfigurationSetSendingEnabledRequest = {}));
            var UpdateConfigurationSetTrackingOptionsRequest;
            (function (UpdateConfigurationSetTrackingOptionsRequest) {
                UpdateConfigurationSetTrackingOptionsRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateConfigurationSetTrackingOptionsRequest = exports.UpdateConfigurationSetTrackingOptionsRequest || (exports.UpdateConfigurationSetTrackingOptionsRequest = {}));
            var UpdateConfigurationSetTrackingOptionsResponse;
            (function (UpdateConfigurationSetTrackingOptionsResponse) {
                UpdateConfigurationSetTrackingOptionsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateConfigurationSetTrackingOptionsResponse = exports.UpdateConfigurationSetTrackingOptionsResponse || (exports.UpdateConfigurationSetTrackingOptionsResponse = {}));
            var UpdateCustomVerificationEmailTemplateRequest;
            (function (UpdateCustomVerificationEmailTemplateRequest) {
                UpdateCustomVerificationEmailTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateCustomVerificationEmailTemplateRequest = exports.UpdateCustomVerificationEmailTemplateRequest || (exports.UpdateCustomVerificationEmailTemplateRequest = {}));
            var UpdateReceiptRuleRequest;
            (function (UpdateReceiptRuleRequest) {
                UpdateReceiptRuleRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateReceiptRuleRequest = exports.UpdateReceiptRuleRequest || (exports.UpdateReceiptRuleRequest = {}));
            var UpdateReceiptRuleResponse;
            (function (UpdateReceiptRuleResponse) {
                UpdateReceiptRuleResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateReceiptRuleResponse = exports.UpdateReceiptRuleResponse || (exports.UpdateReceiptRuleResponse = {}));
            var UpdateTemplateRequest;
            (function (UpdateTemplateRequest) {
                UpdateTemplateRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateTemplateRequest = exports.UpdateTemplateRequest || (exports.UpdateTemplateRequest = {}));
            var UpdateTemplateResponse;
            (function (UpdateTemplateResponse) {
                UpdateTemplateResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(UpdateTemplateResponse = exports.UpdateTemplateResponse || (exports.UpdateTemplateResponse = {}));
            var VerifyDomainDkimRequest;
            (function (VerifyDomainDkimRequest) {
                VerifyDomainDkimRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(VerifyDomainDkimRequest = exports.VerifyDomainDkimRequest || (exports.VerifyDomainDkimRequest = {}));
            var VerifyDomainDkimResponse;
            (function (VerifyDomainDkimResponse) {
                VerifyDomainDkimResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(VerifyDomainDkimResponse = exports.VerifyDomainDkimResponse || (exports.VerifyDomainDkimResponse = {}));
            var VerifyDomainIdentityRequest;
            (function (VerifyDomainIdentityRequest) {
                VerifyDomainIdentityRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(VerifyDomainIdentityRequest = exports.VerifyDomainIdentityRequest || (exports.VerifyDomainIdentityRequest = {}));
            var VerifyDomainIdentityResponse;
            (function (VerifyDomainIdentityResponse) {
                VerifyDomainIdentityResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(VerifyDomainIdentityResponse = exports.VerifyDomainIdentityResponse || (exports.VerifyDomainIdentityResponse = {}));
            var VerifyEmailAddressRequest;
            (function (VerifyEmailAddressRequest) {
                VerifyEmailAddressRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(VerifyEmailAddressRequest = exports.VerifyEmailAddressRequest || (exports.VerifyEmailAddressRequest = {}));
            var VerifyEmailIdentityRequest;
            (function (VerifyEmailIdentityRequest) {
                VerifyEmailIdentityRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(VerifyEmailIdentityRequest = exports.VerifyEmailIdentityRequest || (exports.VerifyEmailIdentityRequest = {}));
            var VerifyEmailIdentityResponse;
            (function (VerifyEmailIdentityResponse) {
                VerifyEmailIdentityResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(VerifyEmailIdentityResponse = exports.VerifyEmailIdentityResponse || (exports.VerifyEmailIdentityResponse = {}));


            /***/
        }),
        /* 223 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListAccountRolesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(518);
            const Aws_restJson1_1 = __webpack_require__(492);

            class ListAccountRolesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SSOClient";
                    const commandName = "ListAccountRolesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListAccountRolesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListAccountRolesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_restJson1_1.serializeAws_restJson1ListAccountRolesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_restJson1_1.deserializeAws_restJson1ListAccountRolesCommand)(output, context);
                }
            }

            exports.ListAccountRolesCommand = ListAccountRolesCommand;


            /***/
        }),
        /* 224 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UpdateConfigurationSetReputationMetricsEnabledCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class UpdateConfigurationSetReputationMetricsEnabledCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "UpdateConfigurationSetReputationMetricsEnabledCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.UpdateConfigurationSetReputationMetricsEnabledRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand)(output, context);
                }
            }

            exports.UpdateConfigurationSetReputationMetricsEnabledCommand = UpdateConfigurationSetReputationMetricsEnabledCommand;


            /***/
        }),
        /* 225 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.defaultRetryDecider = void 0;
            const service_error_classification_1 = __webpack_require__(868);
            const defaultRetryDecider = (error) => {
                if (!error) {
                    return false;
                }
                return (0, service_error_classification_1.isRetryableByTrait)(error) || (0, service_error_classification_1.isClockSkewError)(error) || (0, service_error_classification_1.isThrottlingError)(error) || (0, service_error_classification_1.isTransientError)(error);
            };
            exports.defaultRetryDecider = defaultRetryDecider;


            /***/
        }),
        /* 226 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getValidatedProcessCredentials = void 0;
            const getValidatedProcessCredentials = (profileName, data) => {
                if (data.Version !== 1) {
                    throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
                }
                if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
                    throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
                }
                if (data.Expiration) {
                    const currentTime = new Date();
                    const expireTime = new Date(data.Expiration);
                    if (expireTime < currentTime) {
                        throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
                    }
                }
                return {
                    accessKeyId: data.AccessKeyId,
                    secretAccessKey: data.SecretAccessKey,
                    ...(data.SessionToken && {sessionToken: data.SessionToken}),
                    ...(data.Expiration && {expiration: new Date(data.Expiration)}),
                };
            };
            exports.getValidatedProcessCredentials = getValidatedProcessCredentials;


            /***/
        }),
        /* 227 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DescribeReceiptRuleCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DescribeReceiptRuleCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DescribeReceiptRuleCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DescribeReceiptRuleRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DescribeReceiptRuleResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDescribeReceiptRuleCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDescribeReceiptRuleCommand)(output, context);
                }
            }

            exports.DescribeReceiptRuleCommand = DescribeReceiptRuleCommand;


            /***/
        }),
        /* 228 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _crypto = _interopRequireDefault(__webpack_require__(417));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            function sha1(bytes) {
                if (Array.isArray(bytes)) {
                    bytes = Buffer.from(bytes);
                } else if (typeof bytes === 'string') {
                    bytes = Buffer.from(bytes, 'utf8');
                }

                return _crypto.default.createHash('sha1').update(bytes).digest();
            }

            var _default = sha1;
            exports.default = _default;

            /***/
        }),
        /* 229 */,
        /* 230 */,
        /* 231 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.STSServiceException = void 0;
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(37), exports);
            tslib_1.__exportStar(__webpack_require__(687), exports);
            tslib_1.__exportStar(__webpack_require__(138), exports);
            tslib_1.__exportStar(__webpack_require__(700), exports);
            tslib_1.__exportStar(__webpack_require__(963), exports);
            var STSServiceException_1 = __webpack_require__(838);
            Object.defineProperty(exports, "STSServiceException", {
                enumerable: true, get: function () {
                    return STSServiceException_1.STSServiceException;
                }
            });


            /***/
        }),
        /* 232 */,
        /* 233 */,
        /* 234 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getHostnameFromVariants = void 0;
            const getHostnameFromVariants = (variants = [], {useFipsEndpoint, useDualstackEndpoint}) => {
                var _a;
                return (_a = variants.find(({tags}) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))) === null || _a === void 0 ? void 0 : _a.hostname;
            };
            exports.getHostnameFromVariants = getHostnameFromVariants;


            /***/
        }),
        /* 235 */,
        /* 236 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 237 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(78), exports);


            /***/
        }),
        /* 238 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SSOServiceException = void 0;
            const smithy_client_1 = __webpack_require__(449);

            class SSOServiceException extends smithy_client_1.ServiceException {
                constructor(options) {
                    super(options);
                    Object.setPrototypeOf(this, SSOServiceException.prototype);
                }
            }

            exports.SSOServiceException = SSOServiceException;


            /***/
        }),
        /* 239 */
        /***/ (function (module) {

            "use strict";


            module.exports = function (tagname, parent, val) {
                this.tagname = tagname;
                this.parent = parent;
                this.child = {}; //child tags
                this.attrsMap = {}; //attributes map
                this.val = val; //text only
                this.addChild = function (child) {
                    if (Array.isArray(this.child[child.tagname])) {
                        //already presents
                        this.child[child.tagname].push(child);
                    } else {
                        this.child[child.tagname] = [child];
                    }
                };
            };


            /***/
        }),
        /* 240 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(385), exports);


            /***/
        }),
        /* 241 */,
        /* 242 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.buildQueryString = void 0;
            const util_uri_escape_1 = __webpack_require__(927);

            function buildQueryString(query) {
                const parts = [];
                for (let key of Object.keys(query).sort()) {
                    const value = query[key];
                    key = (0, util_uri_escape_1.escapeUri)(key);
                    if (Array.isArray(value)) {
                        for (let i = 0, iLen = value.length; i < iLen; i++) {
                            parts.push(`${key}=${(0, util_uri_escape_1.escapeUri)(value[i])}`);
                        }
                    } else {
                        let qsEntry = key;
                        if (value || typeof value === "string") {
                            qsEntry += `=${(0, util_uri_escape_1.escapeUri)(value)}`;
                        }
                        parts.push(qsEntry);
                    }
                }
                return parts.join("&");
            }

            exports.buildQueryString = buildQueryString;


            /***/
        }),
        /* 243 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.NODEJS_TIMEOUT_ERROR_CODES = void 0;
            exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];


            /***/
        }),
        /* 244 */,
        /* 245 */,
        /* 246 */,
        /* 247 */,
        /* 248 */,
        /* 249 */,
        /* 250 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRuntimeConfig = void 0;
            const tslib_1 = __webpack_require__(84);
            const package_json_1 = tslib_1.__importDefault(__webpack_require__(52));
            const defaultStsRoleAssumers_1 = __webpack_require__(34);
            const config_resolver_1 = __webpack_require__(772);
            const credential_provider_node_1 = __webpack_require__(277);
            const hash_node_1 = __webpack_require__(974);
            const middleware_retry_1 = __webpack_require__(806);
            const node_config_provider_1 = __webpack_require__(588);
            const node_http_handler_1 = __webpack_require__(720);
            const util_base64_node_1 = __webpack_require__(295);
            const util_body_length_node_1 = __webpack_require__(237);
            const util_user_agent_node_1 = __webpack_require__(623);
            const util_utf8_node_1 = __webpack_require__(495);
            const runtimeConfig_shared_1 = __webpack_require__(738);
            const smithy_client_1 = __webpack_require__(449);
            const util_defaults_mode_node_1 = __webpack_require__(770);
            const getRuntimeConfig = (config) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
                const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
                const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
                const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
                return {
                    ...clientSharedValues,
                    ...config,
                    runtime: "node",
                    defaultsMode,
                    base64Decoder: (_a = config === null || config === void 0 ? void 0 : config.base64Decoder) !== null && _a !== void 0 ? _a : util_base64_node_1.fromBase64,
                    base64Encoder: (_b = config === null || config === void 0 ? void 0 : config.base64Encoder) !== null && _b !== void 0 ? _b : util_base64_node_1.toBase64,
                    bodyLengthChecker: (_c = config === null || config === void 0 ? void 0 : config.bodyLengthChecker) !== null && _c !== void 0 ? _c : util_body_length_node_1.calculateBodyLength,
                    credentialDefaultProvider: (_d = config === null || config === void 0 ? void 0 : config.credentialDefaultProvider) !== null && _d !== void 0 ? _d : (0, defaultStsRoleAssumers_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
                    defaultUserAgentProvider: (_e = config === null || config === void 0 ? void 0 : config.defaultUserAgentProvider) !== null && _e !== void 0 ? _e : (0, util_user_agent_node_1.defaultUserAgent)({
                        serviceId: clientSharedValues.serviceId,
                        clientVersion: package_json_1.default.version
                    }),
                    maxAttempts: (_f = config === null || config === void 0 ? void 0 : config.maxAttempts) !== null && _f !== void 0 ? _f : (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
                    region: (_g = config === null || config === void 0 ? void 0 : config.region) !== null && _g !== void 0 ? _g : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
                    requestHandler: (_h = config === null || config === void 0 ? void 0 : config.requestHandler) !== null && _h !== void 0 ? _h : new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
                    retryMode: (_j = config === null || config === void 0 ? void 0 : config.retryMode) !== null && _j !== void 0 ? _j : (0, node_config_provider_1.loadConfig)({
                        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                        default: async () => (await defaultConfigProvider()).retryMode || middleware_retry_1.DEFAULT_RETRY_MODE,
                    }),
                    sha256: (_k = config === null || config === void 0 ? void 0 : config.sha256) !== null && _k !== void 0 ? _k : hash_node_1.Hash.bind(null, "sha256"),
                    streamCollector: (_l = config === null || config === void 0 ? void 0 : config.streamCollector) !== null && _l !== void 0 ? _l : node_http_handler_1.streamCollector,
                    useDualstackEndpoint: (_m = config === null || config === void 0 ? void 0 : config.useDualstackEndpoint) !== null && _m !== void 0 ? _m : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
                    useFipsEndpoint: (_o = config === null || config === void 0 ? void 0 : config.useFipsEndpoint) !== null && _o !== void 0 ? _o : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
                    utf8Decoder: (_p = config === null || config === void 0 ? void 0 : config.utf8Decoder) !== null && _p !== void 0 ? _p : util_utf8_node_1.fromUtf8,
                    utf8Encoder: (_q = config === null || config === void 0 ? void 0 : config.utf8Encoder) !== null && _q !== void 0 ? _q : util_utf8_node_1.toUtf8,
                };
            };
            exports.getRuntimeConfig = getRuntimeConfig;


            /***/
        }),
        /* 251 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteIdentityCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteIdentityCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteIdentityCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteIdentityRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteIdentityResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteIdentityCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteIdentityCommand)(output, context);
                }
            }

            exports.DeleteIdentityCommand = DeleteIdentityCommand;


            /***/
        }),
        /* 252 */,
        /* 253 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CreateReceiptRuleSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CreateReceiptRuleSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CreateReceiptRuleSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CreateReceiptRuleSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.CreateReceiptRuleSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCreateReceiptRuleSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCreateReceiptRuleSetCommand)(output, context);
                }
            }

            exports.CreateReceiptRuleSetCommand = CreateReceiptRuleSetCommand;


            /***/
        }),
        /* 254 */,
        /* 255 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.moveHeadersToQuery = void 0;
            const cloneRequest_1 = __webpack_require__(445);
            const moveHeadersToQuery = (request, options = {}) => {
                var _a;
                const {
                    headers,
                    query = {}
                } = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
                for (const name of Object.keys(headers)) {
                    const lname = name.toLowerCase();
                    if (lname.substr(0, 6) === "x-amz-" && !((_a = options.unhoistableHeaders) === null || _a === void 0 ? void 0 : _a.has(lname))) {
                        query[name] = headers[name];
                        delete headers[name];
                    }
                }
                return {
                    ...request,
                    headers,
                    query,
                };
            };
            exports.moveHeadersToQuery = moveHeadersToQuery;


            /***/
        }),
        /* 256 */,
        /* 257 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getEndpointFromRegion = void 0;
            const getEndpointFromRegion = async (input) => {
                var _a;
                const {tls = true} = input;
                const region = await input.region();
                const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
                if (!dnsHostRegex.test(region)) {
                    throw new Error("Invalid region in client config");
                }
                const useDualstackEndpoint = await input.useDualstackEndpoint();
                const useFipsEndpoint = await input.useFipsEndpoint();
                const {hostname} = (_a = (await input.regionInfoProvider(region, {
                    useDualstackEndpoint,
                    useFipsEndpoint
                }))) !== null && _a !== void 0 ? _a : {};
                if (!hostname) {
                    throw new Error("Cannot resolve hostname from client config");
                }
                return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
            };
            exports.getEndpointFromRegion = getEndpointFromRegion;


            /***/
        }),
        /* 258 */,
        /* 259 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            const util = __webpack_require__(176);
            const buildOptions = __webpack_require__(176).buildOptions;
            const xmlNode = __webpack_require__(239);
            const regx =
                '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
                    .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

//polyfill
            if (!Number.parseInt && window.parseInt) {
                Number.parseInt = window.parseInt;
            }
            if (!Number.parseFloat && window.parseFloat) {
                Number.parseFloat = window.parseFloat;
            }

            const defaultOptions = {
                attributeNamePrefix: '@_',
                attrNodeName: false,
                textNodeName: '#text',
                ignoreAttributes: true,
                ignoreNameSpace: false,
                allowBooleanAttributes: false, //a tag can have attributes without any value
                //ignoreRootElement : false,
                parseNodeValue: true,
                parseAttributeValue: false,
                arrayMode: false,
                trimValues: true, //Trim string values of tag and attributes
                cdataTagName: false,
                cdataPositionChar: '\\c',
                tagValueProcessor: function (a, tagName) {
                    return a;
                },
                attrValueProcessor: function (a, attrName) {
                    return a;
                },
                stopNodes: []
                //decodeStrict: false,
            };

            exports.defaultOptions = defaultOptions;

            const props = [
                'attributeNamePrefix',
                'attrNodeName',
                'textNodeName',
                'ignoreAttributes',
                'ignoreNameSpace',
                'allowBooleanAttributes',
                'parseNodeValue',
                'parseAttributeValue',
                'arrayMode',
                'trimValues',
                'cdataTagName',
                'cdataPositionChar',
                'tagValueProcessor',
                'attrValueProcessor',
                'parseTrueNumberOnly',
                'stopNodes'
            ];
            exports.props = props;

            /**
             * Trim -> valueProcessor -> parse value
             * @param {string} tagName
             * @param {string} val
             * @param {object} options
             */
            function processTagValue(tagName, val, options) {
                if (val) {
                    if (options.trimValues) {
                        val = val.trim();
                    }
                    val = options.tagValueProcessor(val, tagName);
                    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);
                }

                return val;
            }

            function resolveNameSpace(tagname, options) {
                if (options.ignoreNameSpace) {
                    const tags = tagname.split(':');
                    const prefix = tagname.charAt(0) === '/' ? '/' : '';
                    if (tags[0] === 'xmlns') {
                        return '';
                    }
                    if (tags.length === 2) {
                        tagname = prefix + tags[1];
                    }
                }
                return tagname;
            }

            function parseValue(val, shouldParse, parseTrueNumberOnly) {
                if (shouldParse && typeof val === 'string') {
                    let parsed;
                    if (val.trim() === '' || isNaN(val)) {
                        parsed = val === 'true' ? true : val === 'false' ? false : val;
                    } else {
                        if (val.indexOf('0x') !== -1) {
                            //support hexa decimal
                            parsed = Number.parseInt(val, 16);
                        } else if (val.indexOf('.') !== -1) {
                            parsed = Number.parseFloat(val);
                            val = val.replace(/\.?0+$/, "");
                        } else {
                            parsed = Number.parseInt(val, 10);
                        }
                        if (parseTrueNumberOnly) {
                            parsed = String(parsed) === val ? parsed : val;
                        }
                    }
                    return parsed;
                } else {
                    if (util.isExist(val)) {
                        return val;
                    } else {
                        return '';
                    }
                }
            }

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
            const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])(.*?)\\3)?', 'g');

            function buildAttributesMap(attrStr, options) {
                if (!options.ignoreAttributes && typeof attrStr === 'string') {
                    attrStr = attrStr.replace(/\r?\n/g, ' ');
                    //attrStr = attrStr || attrStr.trim();

                    const matches = util.getAllMatches(attrStr, attrsRegx);
                    const len = matches.length; //don't make it inline
                    const attrs = {};
                    for (let i = 0; i < len; i++) {
                        const attrName = resolveNameSpace(matches[i][1], options);
                        if (attrName.length) {
                            if (matches[i][4] !== undefined) {
                                if (options.trimValues) {
                                    matches[i][4] = matches[i][4].trim();
                                }
                                matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);
                                attrs[options.attributeNamePrefix + attrName] = parseValue(
                                    matches[i][4],
                                    options.parseAttributeValue,
                                    options.parseTrueNumberOnly
                                );
                            } else if (options.allowBooleanAttributes) {
                                attrs[options.attributeNamePrefix + attrName] = true;
                            }
                        }
                    }
                    if (!Object.keys(attrs).length) {
                        return;
                    }
                    if (options.attrNodeName) {
                        const attrCollection = {};
                        attrCollection[options.attrNodeName] = attrs;
                        return attrCollection;
                    }
                    return attrs;
                }
            }

            const getTraversalObj = function (xmlData, options) {
                xmlData = xmlData.replace(/\r\n?/g, "\n");
                options = buildOptions(options, defaultOptions, props);
                const xmlObj = new xmlNode('!xml');
                let currentNode = xmlObj;
                let textData = "";

//function match(xmlData){
                for (let i = 0; i < xmlData.length; i++) {
                    const ch = xmlData[i];
                    if (ch === '<') {
                        if (xmlData[i + 1] === '/') {//Closing Tag
                            const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
                            let tagName = xmlData.substring(i + 2, closeIndex).trim();

                            if (options.ignoreNameSpace) {
                                const colonIndex = tagName.indexOf(":");
                                if (colonIndex !== -1) {
                                    tagName = tagName.substr(colonIndex + 1);
                                }
                            }

                            /* if (currentNode.parent) {
          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);
        } */
                            if (currentNode) {
                                if (currentNode.val) {
                                    currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData, options);
                                } else {
                                    currentNode.val = processTagValue(tagName, textData, options);
                                }
                            }

                            if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {
                                currentNode.child = []
                                if (currentNode.attrsMap == undefined) {
                                    currentNode.attrsMap = {}
                                }
                                currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1)
                            }
                            currentNode = currentNode.parent;
                            textData = "";
                            i = closeIndex;
                        } else if (xmlData[i + 1] === '?') {
                            i = findClosingIndex(xmlData, "?>", i, "Pi Tag is not closed.")
                        } else if (xmlData.substr(i + 1, 3) === '!--') {
                            i = findClosingIndex(xmlData, "-->", i, "Comment is not closed.")
                        } else if (xmlData.substr(i + 1, 2) === '!D') {
                            const closeIndex = findClosingIndex(xmlData, ">", i, "DOCTYPE is not closed.")
                            const tagExp = xmlData.substring(i, closeIndex);
                            if (tagExp.indexOf("[") >= 0) {
                                i = xmlData.indexOf("]>", i) + 1;
                            } else {
                                i = closeIndex;
                            }
                        } else if (xmlData.substr(i + 1, 2) === '![') {
                            const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2
                            const tagExp = xmlData.substring(i + 9, closeIndex);

                            //considerations
                            //1. CDATA will always have parent node
                            //2. A tag with CDATA is not a leaf node so it's value would be string type.
                            if (textData) {
                                currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);
                                textData = "";
                            }

                            if (options.cdataTagName) {
                                //add cdata node
                                const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);
                                currentNode.addChild(childNode);
                                //for backtracking
                                currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;
                                //add rest value to parent node
                                if (tagExp) {
                                    childNode.val = tagExp;
                                }
                            } else {
                                currentNode.val = (currentNode.val || '') + (tagExp || '');
                            }

                            i = closeIndex + 2;
                        } else {//Opening tag
                            const result = closingIndexForOpeningTag(xmlData, i + 1)
                            let tagExp = result.data;
                            const closeIndex = result.index;
                            const separatorIndex = tagExp.indexOf(" ");
                            let tagName = tagExp;
                            let shouldBuildAttributesMap = true;
                            if (separatorIndex !== -1) {
                                tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
                                tagExp = tagExp.substr(separatorIndex + 1);
                            }

                            if (options.ignoreNameSpace) {
                                const colonIndex = tagName.indexOf(":");
                                if (colonIndex !== -1) {
                                    tagName = tagName.substr(colonIndex + 1);
                                    shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);
                                }
                            }

                            //save text to parent node
                            if (currentNode && textData) {
                                if (currentNode.tagname !== '!xml') {
                                    currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);
                                }
                            }

                            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {//selfClosing tag

                                if (tagName[tagName.length - 1] === "/") { //remove trailing '/'
                                    tagName = tagName.substr(0, tagName.length - 1);
                                    tagExp = tagName;
                                } else {
                                    tagExp = tagExp.substr(0, tagExp.length - 1);
                                }

                                const childNode = new xmlNode(tagName, currentNode, '');
                                if (tagName !== tagExp) {
                                    childNode.attrsMap = buildAttributesMap(tagExp, options);
                                }
                                currentNode.addChild(childNode);
                            } else {//opening tag

                                const childNode = new xmlNode(tagName, currentNode);
                                if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {
                                    childNode.startIndex = closeIndex;
                                }
                                if (tagName !== tagExp && shouldBuildAttributesMap) {
                                    childNode.attrsMap = buildAttributesMap(tagExp, options);
                                }
                                currentNode.addChild(childNode);
                                currentNode = childNode;
                            }
                            textData = "";
                            i = closeIndex;
                        }
                    } else {
                        textData += xmlData[i];
                    }
                }
                return xmlObj;
            }

            function closingIndexForOpeningTag(data, i) {
                let attrBoundary;
                let tagExp = "";
                for (let index = i; index < data.length; index++) {
                    let ch = data[index];
                    if (attrBoundary) {
                        if (ch === attrBoundary) attrBoundary = "";//reset
                    } else if (ch === '"' || ch === "'") {
                        attrBoundary = ch;
                    } else if (ch === '>') {
                        return {
                            data: tagExp,
                            index: index
                        }
                    } else if (ch === '\t') {
                        ch = " "
                    }
                    tagExp += ch;
                }
            }

            function findClosingIndex(xmlData, str, i, errMsg) {
                const closingIndex = xmlData.indexOf(str, i);
                if (closingIndex === -1) {
                    throw new Error(errMsg)
                } else {
                    return closingIndex + str.length - 1;
                }
            }

            exports.getTraversalObj = getTraversalObj;


            /***/
        }),
        /* 260 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


// FIXME:
// replace this Transform mess with a method that pipes input argument to output argument

            const MessageParser = __webpack_require__(436);
            const RelaxedBody = __webpack_require__(441);
            const sign = __webpack_require__(733);
            const PassThrough = __webpack_require__(413).PassThrough;
            const fs = __webpack_require__(747);
            const path = __webpack_require__(622);
            const crypto = __webpack_require__(417);

            const DKIM_ALGO = 'sha256';
            const MAX_MESSAGE_SIZE = 128 * 1024; // buffer messages larger than this to disk

            /*
// Usage:

let dkim = new DKIM({
    domainName: 'example.com',
    keySelector: 'key-selector',
    privateKey,
    cacheDir: '/tmp'
});
dkim.sign(input).pipe(process.stdout);

// Where inputStream is a rfc822 message (either a stream, string or Buffer)
// and outputStream is a DKIM signed rfc822 message
*/

            class DKIMSigner {
                constructor(options, keys, input, output) {
                    this.options = options || {};
                    this.keys = keys;

                    this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
                    this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;

                    this.cacheDir = this.options.cacheDir || false;

                    this.chunks = [];
                    this.chunklen = 0;
                    this.readPos = 0;
                    this.cachePath = this.cacheDir ? path.join(this.cacheDir, 'message.' + Date.now() + '-' + crypto.randomBytes(14).toString('hex')) : false;
                    this.cache = false;

                    this.headers = false;
                    this.bodyHash = false;
                    this.parser = false;
                    this.relaxedBody = false;

                    this.input = input;
                    this.output = output;
                    this.output.usingCache = false;

                    this.errored = false;

                    this.input.on('error', err => {
                        this.errored = true;
                        this.cleanup();
                        output.emit('error', err);
                    });
                }

                cleanup() {
                    if (!this.cache || !this.cachePath) {
                        return;
                    }
                    fs.unlink(this.cachePath, () => false);
                }

                createReadCache() {
                    // pipe remainings to cache file
                    this.cache = fs.createReadStream(this.cachePath);
                    this.cache.once('error', err => {
                        this.cleanup();
                        this.output.emit('error', err);
                    });
                    this.cache.once('close', () => {
                        this.cleanup();
                    });
                    this.cache.pipe(this.output);
                }

                sendNextChunk() {
                    if (this.errored) {
                        return;
                    }

                    if (this.readPos >= this.chunks.length) {
                        if (!this.cache) {
                            return this.output.end();
                        }
                        return this.createReadCache();
                    }
                    let chunk = this.chunks[this.readPos++];
                    if (this.output.write(chunk) === false) {
                        return this.output.once('drain', () => {
                            this.sendNextChunk();
                        });
                    }
                    setImmediate(() => this.sendNextChunk());
                }

                sendSignedOutput() {
                    let keyPos = 0;
                    let signNextKey = () => {
                        if (keyPos >= this.keys.length) {
                            this.output.write(this.parser.rawHeaders);
                            return setImmediate(() => this.sendNextChunk());
                        }
                        let key = this.keys[keyPos++];
                        let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {
                            domainName: key.domainName,
                            keySelector: key.keySelector,
                            privateKey: key.privateKey,
                            headerFieldNames: this.options.headerFieldNames,
                            skipFields: this.options.skipFields
                        });
                        if (dkimField) {
                            this.output.write(Buffer.from(dkimField + '\r\n'));
                        }
                        return setImmediate(signNextKey);
                    };

                    if (this.bodyHash && this.headers) {
                        return signNextKey();
                    }

                    this.output.write(this.parser.rawHeaders);
                    this.sendNextChunk();
                }

                createWriteCache() {
                    this.output.usingCache = true;
                    // pipe remainings to cache file
                    this.cache = fs.createWriteStream(this.cachePath);
                    this.cache.once('error', err => {
                        this.cleanup();
                        // drain input
                        this.relaxedBody.unpipe(this.cache);
                        this.relaxedBody.on('readable', () => {
                            while (this.relaxedBody.read() !== null) {
                                // do nothing
                            }
                        });
                        this.errored = true;
                        // emit error
                        this.output.emit('error', err);
                    });
                    this.cache.once('close', () => {
                        this.sendSignedOutput();
                    });
                    this.relaxedBody.removeAllListeners('readable');
                    this.relaxedBody.pipe(this.cache);
                }

                signStream() {
                    this.parser = new MessageParser();
                    this.relaxedBody = new RelaxedBody({
                        hashAlgo: this.hashAlgo
                    });

                    this.parser.on('headers', value => {
                        this.headers = value;
                    });

                    this.relaxedBody.on('hash', value => {
                        this.bodyHash = value;
                    });

                    this.relaxedBody.on('readable', () => {
                        let chunk;
                        if (this.cache) {
                            return;
                        }
                        while ((chunk = this.relaxedBody.read()) !== null) {
                            this.chunks.push(chunk);
                            this.chunklen += chunk.length;
                            if (this.chunklen >= this.cacheTreshold && this.cachePath) {
                                return this.createWriteCache();
                            }
                        }
                    });

                    this.relaxedBody.on('end', () => {
                        if (this.cache) {
                            return;
                        }
                        this.sendSignedOutput();
                    });

                    this.parser.pipe(this.relaxedBody);
                    setImmediate(() => this.input.pipe(this.parser));
                }
            }

            class DKIM {
                constructor(options) {
                    this.options = options || {};
                    this.keys = [].concat(
                        this.options.keys || {
                            domainName: options.domainName,
                            keySelector: options.keySelector,
                            privateKey: options.privateKey
                        }
                    );
                }

                sign(input, extraOptions) {
                    let output = new PassThrough();
                    let inputStream = input;
                    let writeValue = false;

                    if (Buffer.isBuffer(input)) {
                        writeValue = input;
                        inputStream = new PassThrough();
                    } else if (typeof input === 'string') {
                        writeValue = Buffer.from(input);
                        inputStream = new PassThrough();
                    }

                    let options = this.options;
                    if (extraOptions && Object.keys(extraOptions).length) {
                        options = {};
                        Object.keys(this.options || {}).forEach(key => {
                            options[key] = this.options[key];
                        });
                        Object.keys(extraOptions || {}).forEach(key => {
                            if (!(key in options)) {
                                options[key] = extraOptions[key];
                            }
                        });
                    }

                    let signer = new DKIMSigner(options, this.keys, inputStream, output);
                    setImmediate(() => {
                        signer.signStream();
                        if (writeValue) {
                            setImmediate(() => {
                                inputStream.end(writeValue);
                            });
                        }
                    });

                    return output;
                }
            }

            module.exports = DKIM;


            /***/
        }),
        /* 261 */,
        /* 262 */,
        /* 263 */,
        /* 264 */,
        /* 265 */
        /***/ (function (module) {

            module.exports = {
                "Aacute": "",
                "aacute": "",
                "Abreve": "",
                "abreve": "",
                "ac": "",
                "acd": "",
                "acE": "",
                "Acirc": "",
                "acirc": "",
                "acute": "",
                "Acy": "",
                "acy": "",
                "AElig": "",
                "aelig": "",
                "af": "",
                "Afr": "",
                "afr": "",
                "Agrave": "",
                "agrave": "",
                "alefsym": "",
                "aleph": "",
                "Alpha": "",
                "alpha": "",
                "Amacr": "",
                "amacr": "",
                "amalg": "",
                "amp": "&",
                "AMP": "&",
                "andand": "",
                "And": "",
                "and": "",
                "andd": "",
                "andslope": "",
                "andv": "",
                "ang": "",
                "ange": "",
                "angle": "",
                "angmsdaa": "",
                "angmsdab": "",
                "angmsdac": "",
                "angmsdad": "",
                "angmsdae": "",
                "angmsdaf": "",
                "angmsdag": "",
                "angmsdah": "",
                "angmsd": "",
                "angrt": "",
                "angrtvb": "",
                "angrtvbd": "",
                "angsph": "",
                "angst": "",
                "angzarr": "",
                "Aogon": "",
                "aogon": "",
                "Aopf": "",
                "aopf": "",
                "apacir": "",
                "ap": "",
                "apE": "",
                "ape": "",
                "apid": "",
                "apos": "'",
                "ApplyFunction": "",
                "approx": "",
                "approxeq": "",
                "Aring": "",
                "aring": "",
                "Ascr": "",
                "ascr": "",
                "Assign": "",
                "ast": "*",
                "asymp": "",
                "asympeq": "",
                "Atilde": "",
                "atilde": "",
                "Auml": "",
                "auml": "",
                "awconint": "",
                "awint": "",
                "backcong": "",
                "backepsilon": "",
                "backprime": "",
                "backsim": "",
                "backsimeq": "",
                "Backslash": "",
                "Barv": "",
                "barvee": "",
                "barwed": "",
                "Barwed": "",
                "barwedge": "",
                "bbrk": "",
                "bbrktbrk": "",
                "bcong": "",
                "Bcy": "",
                "bcy": "",
                "bdquo": "",
                "becaus": "",
                "because": "",
                "Because": "",
                "bemptyv": "",
                "bepsi": "",
                "bernou": "",
                "Bernoullis": "",
                "Beta": "",
                "beta": "",
                "beth": "",
                "between": "",
                "Bfr": "",
                "bfr": "",
                "bigcap": "",
                "bigcirc": "",
                "bigcup": "",
                "bigodot": "",
                "bigoplus": "",
                "bigotimes": "",
                "bigsqcup": "",
                "bigstar": "",
                "bigtriangledown": "",
                "bigtriangleup": "",
                "biguplus": "",
                "bigvee": "",
                "bigwedge": "",
                "bkarow": "",
                "blacklozenge": "",
                "blacksquare": "",
                "blacktriangle": "",
                "blacktriangledown": "",
                "blacktriangleleft": "",
                "blacktriangleright": "",
                "blank": "",
                "blk12": "",
                "blk14": "",
                "blk34": "",
                "block": "",
                "bne": "=",
                "bnequiv": "",
                "bNot": "",
                "bnot": "",
                "Bopf": "",
                "bopf": "",
                "bot": "",
                "bottom": "",
                "bowtie": "",
                "boxbox": "",
                "boxdl": "",
                "boxdL": "",
                "boxDl": "",
                "boxDL": "",
                "boxdr": "",
                "boxdR": "",
                "boxDr": "",
                "boxDR": "",
                "boxh": "",
                "boxH": "",
                "boxhd": "",
                "boxHd": "",
                "boxhD": "",
                "boxHD": "",
                "boxhu": "",
                "boxHu": "",
                "boxhU": "",
                "boxHU": "",
                "boxminus": "",
                "boxplus": "",
                "boxtimes": "",
                "boxul": "",
                "boxuL": "",
                "boxUl": "",
                "boxUL": "",
                "boxur": "",
                "boxuR": "",
                "boxUr": "",
                "boxUR": "",
                "boxv": "",
                "boxV": "",
                "boxvh": "",
                "boxvH": "",
                "boxVh": "",
                "boxVH": "",
                "boxvl": "",
                "boxvL": "",
                "boxVl": "",
                "boxVL": "",
                "boxvr": "",
                "boxvR": "",
                "boxVr": "",
                "boxVR": "",
                "bprime": "",
                "breve": "",
                "Breve": "",
                "brvbar": "",
                "bscr": "",
                "Bscr": "",
                "bsemi": "",
                "bsim": "",
                "bsime": "",
                "bsolb": "",
                "bsol": "\\",
                "bsolhsub": "",
                "bull": "",
                "bullet": "",
                "bump": "",
                "bumpE": "",
                "bumpe": "",
                "Bumpeq": "",
                "bumpeq": "",
                "Cacute": "",
                "cacute": "",
                "capand": "",
                "capbrcup": "",
                "capcap": "",
                "cap": "",
                "Cap": "",
                "capcup": "",
                "capdot": "",
                "CapitalDifferentialD": "",
                "caps": "",
                "caret": "",
                "caron": "",
                "Cayleys": "",
                "ccaps": "",
                "Ccaron": "",
                "ccaron": "",
                "Ccedil": "",
                "ccedil": "",
                "Ccirc": "",
                "ccirc": "",
                "Cconint": "",
                "ccups": "",
                "ccupssm": "",
                "Cdot": "",
                "cdot": "",
                "cedil": "",
                "Cedilla": "",
                "cemptyv": "",
                "cent": "",
                "centerdot": "",
                "CenterDot": "",
                "cfr": "",
                "Cfr": "",
                "CHcy": "",
                "chcy": "",
                "check": "",
                "checkmark": "",
                "Chi": "",
                "chi": "",
                "circ": "",
                "circeq": "",
                "circlearrowleft": "",
                "circlearrowright": "",
                "circledast": "",
                "circledcirc": "",
                "circleddash": "",
                "CircleDot": "",
                "circledR": "",
                "circledS": "",
                "CircleMinus": "",
                "CirclePlus": "",
                "CircleTimes": "",
                "cir": "",
                "cirE": "",
                "cire": "",
                "cirfnint": "",
                "cirmid": "",
                "cirscir": "",
                "ClockwiseContourIntegral": "",
                "CloseCurlyDoubleQuote": "",
                "CloseCurlyQuote": "",
                "clubs": "",
                "clubsuit": "",
                "colon": ":",
                "Colon": "",
                "Colone": "",
                "colone": "",
                "coloneq": "",
                "comma": ",",
                "commat": "@",
                "comp": "",
                "compfn": "",
                "complement": "",
                "complexes": "",
                "cong": "",
                "congdot": "",
                "Congruent": "",
                "conint": "",
                "Conint": "",
                "ContourIntegral": "",
                "copf": "",
                "Copf": "",
                "coprod": "",
                "Coproduct": "",
                "copy": "",
                "COPY": "",
                "copysr": "",
                "CounterClockwiseContourIntegral": "",
                "crarr": "",
                "cross": "",
                "Cross": "",
                "Cscr": "",
                "cscr": "",
                "csub": "",
                "csube": "",
                "csup": "",
                "csupe": "",
                "ctdot": "",
                "cudarrl": "",
                "cudarrr": "",
                "cuepr": "",
                "cuesc": "",
                "cularr": "",
                "cularrp": "",
                "cupbrcap": "",
                "cupcap": "",
                "CupCap": "",
                "cup": "",
                "Cup": "",
                "cupcup": "",
                "cupdot": "",
                "cupor": "",
                "cups": "",
                "curarr": "",
                "curarrm": "",
                "curlyeqprec": "",
                "curlyeqsucc": "",
                "curlyvee": "",
                "curlywedge": "",
                "curren": "",
                "curvearrowleft": "",
                "curvearrowright": "",
                "cuvee": "",
                "cuwed": "",
                "cwconint": "",
                "cwint": "",
                "cylcty": "",
                "dagger": "",
                "Dagger": "",
                "daleth": "",
                "darr": "",
                "Darr": "",
                "dArr": "",
                "dash": "",
                "Dashv": "",
                "dashv": "",
                "dbkarow": "",
                "dblac": "",
                "Dcaron": "",
                "dcaron": "",
                "Dcy": "",
                "dcy": "",
                "ddagger": "",
                "ddarr": "",
                "DD": "",
                "dd": "",
                "DDotrahd": "",
                "ddotseq": "",
                "deg": "",
                "Del": "",
                "Delta": "",
                "delta": "",
                "demptyv": "",
                "dfisht": "",
                "Dfr": "",
                "dfr": "",
                "dHar": "",
                "dharl": "",
                "dharr": "",
                "DiacriticalAcute": "",
                "DiacriticalDot": "",
                "DiacriticalDoubleAcute": "",
                "DiacriticalGrave": "`",
                "DiacriticalTilde": "",
                "diam": "",
                "diamond": "",
                "Diamond": "",
                "diamondsuit": "",
                "diams": "",
                "die": "",
                "DifferentialD": "",
                "digamma": "",
                "disin": "",
                "div": "",
                "divide": "",
                "divideontimes": "",
                "divonx": "",
                "DJcy": "",
                "djcy": "",
                "dlcorn": "",
                "dlcrop": "",
                "dollar": "$",
                "Dopf": "",
                "dopf": "",
                "Dot": "",
                "dot": "",
                "DotDot": "",
                "doteq": "",
                "doteqdot": "",
                "DotEqual": "",
                "dotminus": "",
                "dotplus": "",
                "dotsquare": "",
                "doublebarwedge": "",
                "DoubleContourIntegral": "",
                "DoubleDot": "",
                "DoubleDownArrow": "",
                "DoubleLeftArrow": "",
                "DoubleLeftRightArrow": "",
                "DoubleLeftTee": "",
                "DoubleLongLeftArrow": "",
                "DoubleLongLeftRightArrow": "",
                "DoubleLongRightArrow": "",
                "DoubleRightArrow": "",
                "DoubleRightTee": "",
                "DoubleUpArrow": "",
                "DoubleUpDownArrow": "",
                "DoubleVerticalBar": "",
                "DownArrowBar": "",
                "downarrow": "",
                "DownArrow": "",
                "Downarrow": "",
                "DownArrowUpArrow": "",
                "DownBreve": "",
                "downdownarrows": "",
                "downharpoonleft": "",
                "downharpoonright": "",
                "DownLeftRightVector": "",
                "DownLeftTeeVector": "",
                "DownLeftVectorBar": "",
                "DownLeftVector": "",
                "DownRightTeeVector": "",
                "DownRightVectorBar": "",
                "DownRightVector": "",
                "DownTeeArrow": "",
                "DownTee": "",
                "drbkarow": "",
                "drcorn": "",
                "drcrop": "",
                "Dscr": "",
                "dscr": "",
                "DScy": "",
                "dscy": "",
                "dsol": "",
                "Dstrok": "",
                "dstrok": "",
                "dtdot": "",
                "dtri": "",
                "dtrif": "",
                "duarr": "",
                "duhar": "",
                "dwangle": "",
                "DZcy": "",
                "dzcy": "",
                "dzigrarr": "",
                "Eacute": "",
                "eacute": "",
                "easter": "",
                "Ecaron": "",
                "ecaron": "",
                "Ecirc": "",
                "ecirc": "",
                "ecir": "",
                "ecolon": "",
                "Ecy": "",
                "ecy": "",
                "eDDot": "",
                "Edot": "",
                "edot": "",
                "eDot": "",
                "ee": "",
                "efDot": "",
                "Efr": "",
                "efr": "",
                "eg": "",
                "Egrave": "",
                "egrave": "",
                "egs": "",
                "egsdot": "",
                "el": "",
                "Element": "",
                "elinters": "",
                "ell": "",
                "els": "",
                "elsdot": "",
                "Emacr": "",
                "emacr": "",
                "empty": "",
                "emptyset": "",
                "EmptySmallSquare": "",
                "emptyv": "",
                "EmptyVerySmallSquare": "",
                "emsp13": "",
                "emsp14": "",
                "emsp": "",
                "ENG": "",
                "eng": "",
                "ensp": "",
                "Eogon": "",
                "eogon": "",
                "Eopf": "",
                "eopf": "",
                "epar": "",
                "eparsl": "",
                "eplus": "",
                "epsi": "",
                "Epsilon": "",
                "epsilon": "",
                "epsiv": "",
                "eqcirc": "",
                "eqcolon": "",
                "eqsim": "",
                "eqslantgtr": "",
                "eqslantless": "",
                "Equal": "",
                "equals": "=",
                "EqualTilde": "",
                "equest": "",
                "Equilibrium": "",
                "equiv": "",
                "equivDD": "",
                "eqvparsl": "",
                "erarr": "",
                "erDot": "",
                "escr": "",
                "Escr": "",
                "esdot": "",
                "Esim": "",
                "esim": "",
                "Eta": "",
                "eta": "",
                "ETH": "",
                "eth": "",
                "Euml": "",
                "euml": "",
                "euro": "",
                "excl": "!",
                "exist": "",
                "Exists": "",
                "expectation": "",
                "exponentiale": "",
                "ExponentialE": "",
                "fallingdotseq": "",
                "Fcy": "",
                "fcy": "",
                "female": "",
                "ffilig": "",
                "fflig": "",
                "ffllig": "",
                "Ffr": "",
                "ffr": "",
                "filig": "",
                "FilledSmallSquare": "",
                "FilledVerySmallSquare": "",
                "fjlig": "fj",
                "flat": "",
                "fllig": "",
                "fltns": "",
                "fnof": "",
                "Fopf": "",
                "fopf": "",
                "forall": "",
                "ForAll": "",
                "fork": "",
                "forkv": "",
                "Fouriertrf": "",
                "fpartint": "",
                "frac12": "",
                "frac13": "",
                "frac14": "",
                "frac15": "",
                "frac16": "",
                "frac18": "",
                "frac23": "",
                "frac25": "",
                "frac34": "",
                "frac35": "",
                "frac38": "",
                "frac45": "",
                "frac56": "",
                "frac58": "",
                "frac78": "",
                "frasl": "",
                "frown": "",
                "fscr": "",
                "Fscr": "",
                "gacute": "",
                "Gamma": "",
                "gamma": "",
                "Gammad": "",
                "gammad": "",
                "gap": "",
                "Gbreve": "",
                "gbreve": "",
                "Gcedil": "",
                "Gcirc": "",
                "gcirc": "",
                "Gcy": "",
                "gcy": "",
                "Gdot": "",
                "gdot": "",
                "ge": "",
                "gE": "",
                "gEl": "",
                "gel": "",
                "geq": "",
                "geqq": "",
                "geqslant": "",
                "gescc": "",
                "ges": "",
                "gesdot": "",
                "gesdoto": "",
                "gesdotol": "",
                "gesl": "",
                "gesles": "",
                "Gfr": "",
                "gfr": "",
                "gg": "",
                "Gg": "",
                "ggg": "",
                "gimel": "",
                "GJcy": "",
                "gjcy": "",
                "gla": "",
                "gl": "",
                "glE": "",
                "glj": "",
                "gnap": "",
                "gnapprox": "",
                "gne": "",
                "gnE": "",
                "gneq": "",
                "gneqq": "",
                "gnsim": "",
                "Gopf": "",
                "gopf": "",
                "grave": "`",
                "GreaterEqual": "",
                "GreaterEqualLess": "",
                "GreaterFullEqual": "",
                "GreaterGreater": "",
                "GreaterLess": "",
                "GreaterSlantEqual": "",
                "GreaterTilde": "",
                "Gscr": "",
                "gscr": "",
                "gsim": "",
                "gsime": "",
                "gsiml": "",
                "gtcc": "",
                "gtcir": "",
                "gt": ">",
                "GT": ">",
                "Gt": "",
                "gtdot": "",
                "gtlPar": "",
                "gtquest": "",
                "gtrapprox": "",
                "gtrarr": "",
                "gtrdot": "",
                "gtreqless": "",
                "gtreqqless": "",
                "gtrless": "",
                "gtrsim": "",
                "gvertneqq": "",
                "gvnE": "",
                "Hacek": "",
                "hairsp": "",
                "half": "",
                "hamilt": "",
                "HARDcy": "",
                "hardcy": "",
                "harrcir": "",
                "harr": "",
                "hArr": "",
                "harrw": "",
                "Hat": "^",
                "hbar": "",
                "Hcirc": "",
                "hcirc": "",
                "hearts": "",
                "heartsuit": "",
                "hellip": "",
                "hercon": "",
                "hfr": "",
                "Hfr": "",
                "HilbertSpace": "",
                "hksearow": "",
                "hkswarow": "",
                "hoarr": "",
                "homtht": "",
                "hookleftarrow": "",
                "hookrightarrow": "",
                "hopf": "",
                "Hopf": "",
                "horbar": "",
                "HorizontalLine": "",
                "hscr": "",
                "Hscr": "",
                "hslash": "",
                "Hstrok": "",
                "hstrok": "",
                "HumpDownHump": "",
                "HumpEqual": "",
                "hybull": "",
                "hyphen": "",
                "Iacute": "",
                "iacute": "",
                "ic": "",
                "Icirc": "",
                "icirc": "",
                "Icy": "",
                "icy": "",
                "Idot": "",
                "IEcy": "",
                "iecy": "",
                "iexcl": "",
                "iff": "",
                "ifr": "",
                "Ifr": "",
                "Igrave": "",
                "igrave": "",
                "ii": "",
                "iiiint": "",
                "iiint": "",
                "iinfin": "",
                "iiota": "",
                "IJlig": "",
                "ijlig": "",
                "Imacr": "",
                "imacr": "",
                "image": "",
                "ImaginaryI": "",
                "imagline": "",
                "imagpart": "",
                "imath": "",
                "Im": "",
                "imof": "",
                "imped": "",
                "Implies": "",
                "incare": "",
                "in": "",
                "infin": "",
                "infintie": "",
                "inodot": "",
                "intcal": "",
                "int": "",
                "Int": "",
                "integers": "",
                "Integral": "",
                "intercal": "",
                "Intersection": "",
                "intlarhk": "",
                "intprod": "",
                "InvisibleComma": "",
                "InvisibleTimes": "",
                "IOcy": "",
                "iocy": "",
                "Iogon": "",
                "iogon": "",
                "Iopf": "",
                "iopf": "",
                "Iota": "",
                "iota": "",
                "iprod": "",
                "iquest": "",
                "iscr": "",
                "Iscr": "",
                "isin": "",
                "isindot": "",
                "isinE": "",
                "isins": "",
                "isinsv": "",
                "isinv": "",
                "it": "",
                "Itilde": "",
                "itilde": "",
                "Iukcy": "",
                "iukcy": "",
                "Iuml": "",
                "iuml": "",
                "Jcirc": "",
                "jcirc": "",
                "Jcy": "",
                "jcy": "",
                "Jfr": "",
                "jfr": "",
                "jmath": "",
                "Jopf": "",
                "jopf": "",
                "Jscr": "",
                "jscr": "",
                "Jsercy": "",
                "jsercy": "",
                "Jukcy": "",
                "jukcy": "",
                "Kappa": "",
                "kappa": "",
                "kappav": "",
                "Kcedil": "",
                "kcedil": "",
                "Kcy": "",
                "kcy": "",
                "Kfr": "",
                "kfr": "",
                "kgreen": "",
                "KHcy": "",
                "khcy": "",
                "KJcy": "",
                "kjcy": "",
                "Kopf": "",
                "kopf": "",
                "Kscr": "",
                "kscr": "",
                "lAarr": "",
                "Lacute": "",
                "lacute": "",
                "laemptyv": "",
                "lagran": "",
                "Lambda": "",
                "lambda": "",
                "lang": "",
                "Lang": "",
                "langd": "",
                "langle": "",
                "lap": "",
                "Laplacetrf": "",
                "laquo": "",
                "larrb": "",
                "larrbfs": "",
                "larr": "",
                "Larr": "",
                "lArr": "",
                "larrfs": "",
                "larrhk": "",
                "larrlp": "",
                "larrpl": "",
                "larrsim": "",
                "larrtl": "",
                "latail": "",
                "lAtail": "",
                "lat": "",
                "late": "",
                "lates": "",
                "lbarr": "",
                "lBarr": "",
                "lbbrk": "",
                "lbrace": "{",
                "lbrack": "[",
                "lbrke": "",
                "lbrksld": "",
                "lbrkslu": "",
                "Lcaron": "",
                "lcaron": "",
                "Lcedil": "",
                "lcedil": "",
                "lceil": "",
                "lcub": "{",
                "Lcy": "",
                "lcy": "",
                "ldca": "",
                "ldquo": "",
                "ldquor": "",
                "ldrdhar": "",
                "ldrushar": "",
                "ldsh": "",
                "le": "",
                "lE": "",
                "LeftAngleBracket": "",
                "LeftArrowBar": "",
                "leftarrow": "",
                "LeftArrow": "",
                "Leftarrow": "",
                "LeftArrowRightArrow": "",
                "leftarrowtail": "",
                "LeftCeiling": "",
                "LeftDoubleBracket": "",
                "LeftDownTeeVector": "",
                "LeftDownVectorBar": "",
                "LeftDownVector": "",
                "LeftFloor": "",
                "leftharpoondown": "",
                "leftharpoonup": "",
                "leftleftarrows": "",
                "leftrightarrow": "",
                "LeftRightArrow": "",
                "Leftrightarrow": "",
                "leftrightarrows": "",
                "leftrightharpoons": "",
                "leftrightsquigarrow": "",
                "LeftRightVector": "",
                "LeftTeeArrow": "",
                "LeftTee": "",
                "LeftTeeVector": "",
                "leftthreetimes": "",
                "LeftTriangleBar": "",
                "LeftTriangle": "",
                "LeftTriangleEqual": "",
                "LeftUpDownVector": "",
                "LeftUpTeeVector": "",
                "LeftUpVectorBar": "",
                "LeftUpVector": "",
                "LeftVectorBar": "",
                "LeftVector": "",
                "lEg": "",
                "leg": "",
                "leq": "",
                "leqq": "",
                "leqslant": "",
                "lescc": "",
                "les": "",
                "lesdot": "",
                "lesdoto": "",
                "lesdotor": "",
                "lesg": "",
                "lesges": "",
                "lessapprox": "",
                "lessdot": "",
                "lesseqgtr": "",
                "lesseqqgtr": "",
                "LessEqualGreater": "",
                "LessFullEqual": "",
                "LessGreater": "",
                "lessgtr": "",
                "LessLess": "",
                "lesssim": "",
                "LessSlantEqual": "",
                "LessTilde": "",
                "lfisht": "",
                "lfloor": "",
                "Lfr": "",
                "lfr": "",
                "lg": "",
                "lgE": "",
                "lHar": "",
                "lhard": "",
                "lharu": "",
                "lharul": "",
                "lhblk": "",
                "LJcy": "",
                "ljcy": "",
                "llarr": "",
                "ll": "",
                "Ll": "",
                "llcorner": "",
                "Lleftarrow": "",
                "llhard": "",
                "lltri": "",
                "Lmidot": "",
                "lmidot": "",
                "lmoustache": "",
                "lmoust": "",
                "lnap": "",
                "lnapprox": "",
                "lne": "",
                "lnE": "",
                "lneq": "",
                "lneqq": "",
                "lnsim": "",
                "loang": "",
                "loarr": "",
                "lobrk": "",
                "longleftarrow": "",
                "LongLeftArrow": "",
                "Longleftarrow": "",
                "longleftrightarrow": "",
                "LongLeftRightArrow": "",
                "Longleftrightarrow": "",
                "longmapsto": "",
                "longrightarrow": "",
                "LongRightArrow": "",
                "Longrightarrow": "",
                "looparrowleft": "",
                "looparrowright": "",
                "lopar": "",
                "Lopf": "",
                "lopf": "",
                "loplus": "",
                "lotimes": "",
                "lowast": "",
                "lowbar": "_",
                "LowerLeftArrow": "",
                "LowerRightArrow": "",
                "loz": "",
                "lozenge": "",
                "lozf": "",
                "lpar": "(",
                "lparlt": "",
                "lrarr": "",
                "lrcorner": "",
                "lrhar": "",
                "lrhard": "",
                "lrm": "",
                "lrtri": "",
                "lsaquo": "",
                "lscr": "",
                "Lscr": "",
                "lsh": "",
                "Lsh": "",
                "lsim": "",
                "lsime": "",
                "lsimg": "",
                "lsqb": "[",
                "lsquo": "",
                "lsquor": "",
                "Lstrok": "",
                "lstrok": "",
                "ltcc": "",
                "ltcir": "",
                "lt": "<",
                "LT": "<",
                "Lt": "",
                "ltdot": "",
                "lthree": "",
                "ltimes": "",
                "ltlarr": "",
                "ltquest": "",
                "ltri": "",
                "ltrie": "",
                "ltrif": "",
                "ltrPar": "",
                "lurdshar": "",
                "luruhar": "",
                "lvertneqq": "",
                "lvnE": "",
                "macr": "",
                "male": "",
                "malt": "",
                "maltese": "",
                "Map": "",
                "map": "",
                "mapsto": "",
                "mapstodown": "",
                "mapstoleft": "",
                "mapstoup": "",
                "marker": "",
                "mcomma": "",
                "Mcy": "",
                "mcy": "",
                "mdash": "",
                "mDDot": "",
                "measuredangle": "",
                "MediumSpace": "",
                "Mellintrf": "",
                "Mfr": "",
                "mfr": "",
                "mho": "",
                "micro": "",
                "midast": "*",
                "midcir": "",
                "mid": "",
                "middot": "",
                "minusb": "",
                "minus": "",
                "minusd": "",
                "minusdu": "",
                "MinusPlus": "",
                "mlcp": "",
                "mldr": "",
                "mnplus": "",
                "models": "",
                "Mopf": "",
                "mopf": "",
                "mp": "",
                "mscr": "",
                "Mscr": "",
                "mstpos": "",
                "Mu": "",
                "mu": "",
                "multimap": "",
                "mumap": "",
                "nabla": "",
                "Nacute": "",
                "nacute": "",
                "nang": "",
                "nap": "",
                "napE": "",
                "napid": "",
                "napos": "",
                "napprox": "",
                "natural": "",
                "naturals": "",
                "natur": "",
                "nbsp": "",
                "nbump": "",
                "nbumpe": "",
                "ncap": "",
                "Ncaron": "",
                "ncaron": "",
                "Ncedil": "",
                "ncedil": "",
                "ncong": "",
                "ncongdot": "",
                "ncup": "",
                "Ncy": "",
                "ncy": "",
                "ndash": "",
                "nearhk": "",
                "nearr": "",
                "neArr": "",
                "nearrow": "",
                "ne": "",
                "nedot": "",
                "NegativeMediumSpace": "",
                "NegativeThickSpace": "",
                "NegativeThinSpace": "",
                "NegativeVeryThinSpace": "",
                "nequiv": "",
                "nesear": "",
                "nesim": "",
                "NestedGreaterGreater": "",
                "NestedLessLess": "",
                "NewLine": "\n",
                "nexist": "",
                "nexists": "",
                "Nfr": "",
                "nfr": "",
                "ngE": "",
                "nge": "",
                "ngeq": "",
                "ngeqq": "",
                "ngeqslant": "",
                "nges": "",
                "nGg": "",
                "ngsim": "",
                "nGt": "",
                "ngt": "",
                "ngtr": "",
                "nGtv": "",
                "nharr": "",
                "nhArr": "",
                "nhpar": "",
                "ni": "",
                "nis": "",
                "nisd": "",
                "niv": "",
                "NJcy": "",
                "njcy": "",
                "nlarr": "",
                "nlArr": "",
                "nldr": "",
                "nlE": "",
                "nle": "",
                "nleftarrow": "",
                "nLeftarrow": "",
                "nleftrightarrow": "",
                "nLeftrightarrow": "",
                "nleq": "",
                "nleqq": "",
                "nleqslant": "",
                "nles": "",
                "nless": "",
                "nLl": "",
                "nlsim": "",
                "nLt": "",
                "nlt": "",
                "nltri": "",
                "nltrie": "",
                "nLtv": "",
                "nmid": "",
                "NoBreak": "",
                "NonBreakingSpace": "",
                "nopf": "",
                "Nopf": "",
                "Not": "",
                "not": "",
                "NotCongruent": "",
                "NotCupCap": "",
                "NotDoubleVerticalBar": "",
                "NotElement": "",
                "NotEqual": "",
                "NotEqualTilde": "",
                "NotExists": "",
                "NotGreater": "",
                "NotGreaterEqual": "",
                "NotGreaterFullEqual": "",
                "NotGreaterGreater": "",
                "NotGreaterLess": "",
                "NotGreaterSlantEqual": "",
                "NotGreaterTilde": "",
                "NotHumpDownHump": "",
                "NotHumpEqual": "",
                "notin": "",
                "notindot": "",
                "notinE": "",
                "notinva": "",
                "notinvb": "",
                "notinvc": "",
                "NotLeftTriangleBar": "",
                "NotLeftTriangle": "",
                "NotLeftTriangleEqual": "",
                "NotLess": "",
                "NotLessEqual": "",
                "NotLessGreater": "",
                "NotLessLess": "",
                "NotLessSlantEqual": "",
                "NotLessTilde": "",
                "NotNestedGreaterGreater": "",
                "NotNestedLessLess": "",
                "notni": "",
                "notniva": "",
                "notnivb": "",
                "notnivc": "",
                "NotPrecedes": "",
                "NotPrecedesEqual": "",
                "NotPrecedesSlantEqual": "",
                "NotReverseElement": "",
                "NotRightTriangleBar": "",
                "NotRightTriangle": "",
                "NotRightTriangleEqual": "",
                "NotSquareSubset": "",
                "NotSquareSubsetEqual": "",
                "NotSquareSuperset": "",
                "NotSquareSupersetEqual": "",
                "NotSubset": "",
                "NotSubsetEqual": "",
                "NotSucceeds": "",
                "NotSucceedsEqual": "",
                "NotSucceedsSlantEqual": "",
                "NotSucceedsTilde": "",
                "NotSuperset": "",
                "NotSupersetEqual": "",
                "NotTilde": "",
                "NotTildeEqual": "",
                "NotTildeFullEqual": "",
                "NotTildeTilde": "",
                "NotVerticalBar": "",
                "nparallel": "",
                "npar": "",
                "nparsl": "",
                "npart": "",
                "npolint": "",
                "npr": "",
                "nprcue": "",
                "nprec": "",
                "npreceq": "",
                "npre": "",
                "nrarrc": "",
                "nrarr": "",
                "nrArr": "",
                "nrarrw": "",
                "nrightarrow": "",
                "nRightarrow": "",
                "nrtri": "",
                "nrtrie": "",
                "nsc": "",
                "nsccue": "",
                "nsce": "",
                "Nscr": "",
                "nscr": "",
                "nshortmid": "",
                "nshortparallel": "",
                "nsim": "",
                "nsime": "",
                "nsimeq": "",
                "nsmid": "",
                "nspar": "",
                "nsqsube": "",
                "nsqsupe": "",
                "nsub": "",
                "nsubE": "",
                "nsube": "",
                "nsubset": "",
                "nsubseteq": "",
                "nsubseteqq": "",
                "nsucc": "",
                "nsucceq": "",
                "nsup": "",
                "nsupE": "",
                "nsupe": "",
                "nsupset": "",
                "nsupseteq": "",
                "nsupseteqq": "",
                "ntgl": "",
                "Ntilde": "",
                "ntilde": "",
                "ntlg": "",
                "ntriangleleft": "",
                "ntrianglelefteq": "",
                "ntriangleright": "",
                "ntrianglerighteq": "",
                "Nu": "",
                "nu": "",
                "num": "#",
                "numero": "",
                "numsp": "",
                "nvap": "",
                "nvdash": "",
                "nvDash": "",
                "nVdash": "",
                "nVDash": "",
                "nvge": "",
                "nvgt": ">",
                "nvHarr": "",
                "nvinfin": "",
                "nvlArr": "",
                "nvle": "",
                "nvlt": "<",
                "nvltrie": "",
                "nvrArr": "",
                "nvrtrie": "",
                "nvsim": "",
                "nwarhk": "",
                "nwarr": "",
                "nwArr": "",
                "nwarrow": "",
                "nwnear": "",
                "Oacute": "",
                "oacute": "",
                "oast": "",
                "Ocirc": "",
                "ocirc": "",
                "ocir": "",
                "Ocy": "",
                "ocy": "",
                "odash": "",
                "Odblac": "",
                "odblac": "",
                "odiv": "",
                "odot": "",
                "odsold": "",
                "OElig": "",
                "oelig": "",
                "ofcir": "",
                "Ofr": "",
                "ofr": "",
                "ogon": "",
                "Ograve": "",
                "ograve": "",
                "ogt": "",
                "ohbar": "",
                "ohm": "",
                "oint": "",
                "olarr": "",
                "olcir": "",
                "olcross": "",
                "oline": "",
                "olt": "",
                "Omacr": "",
                "omacr": "",
                "Omega": "",
                "omega": "",
                "Omicron": "",
                "omicron": "",
                "omid": "",
                "ominus": "",
                "Oopf": "",
                "oopf": "",
                "opar": "",
                "OpenCurlyDoubleQuote": "",
                "OpenCurlyQuote": "",
                "operp": "",
                "oplus": "",
                "orarr": "",
                "Or": "",
                "or": "",
                "ord": "",
                "order": "",
                "orderof": "",
                "ordf": "",
                "ordm": "",
                "origof": "",
                "oror": "",
                "orslope": "",
                "orv": "",
                "oS": "",
                "Oscr": "",
                "oscr": "",
                "Oslash": "",
                "oslash": "",
                "osol": "",
                "Otilde": "",
                "otilde": "",
                "otimesas": "",
                "Otimes": "",
                "otimes": "",
                "Ouml": "",
                "ouml": "",
                "ovbar": "",
                "OverBar": "",
                "OverBrace": "",
                "OverBracket": "",
                "OverParenthesis": "",
                "para": "",
                "parallel": "",
                "par": "",
                "parsim": "",
                "parsl": "",
                "part": "",
                "PartialD": "",
                "Pcy": "",
                "pcy": "",
                "percnt": "%",
                "period": ".",
                "permil": "",
                "perp": "",
                "pertenk": "",
                "Pfr": "",
                "pfr": "",
                "Phi": "",
                "phi": "",
                "phiv": "",
                "phmmat": "",
                "phone": "",
                "Pi": "",
                "pi": "",
                "pitchfork": "",
                "piv": "",
                "planck": "",
                "planckh": "",
                "plankv": "",
                "plusacir": "",
                "plusb": "",
                "pluscir": "",
                "plus": "+",
                "plusdo": "",
                "plusdu": "",
                "pluse": "",
                "PlusMinus": "",
                "plusmn": "",
                "plussim": "",
                "plustwo": "",
                "pm": "",
                "Poincareplane": "",
                "pointint": "",
                "popf": "",
                "Popf": "",
                "pound": "",
                "prap": "",
                "Pr": "",
                "pr": "",
                "prcue": "",
                "precapprox": "",
                "prec": "",
                "preccurlyeq": "",
                "Precedes": "",
                "PrecedesEqual": "",
                "PrecedesSlantEqual": "",
                "PrecedesTilde": "",
                "preceq": "",
                "precnapprox": "",
                "precneqq": "",
                "precnsim": "",
                "pre": "",
                "prE": "",
                "precsim": "",
                "prime": "",
                "Prime": "",
                "primes": "",
                "prnap": "",
                "prnE": "",
                "prnsim": "",
                "prod": "",
                "Product": "",
                "profalar": "",
                "profline": "",
                "profsurf": "",
                "prop": "",
                "Proportional": "",
                "Proportion": "",
                "propto": "",
                "prsim": "",
                "prurel": "",
                "Pscr": "",
                "pscr": "",
                "Psi": "",
                "psi": "",
                "puncsp": "",
                "Qfr": "",
                "qfr": "",
                "qint": "",
                "qopf": "",
                "Qopf": "",
                "qprime": "",
                "Qscr": "",
                "qscr": "",
                "quaternions": "",
                "quatint": "",
                "quest": "?",
                "questeq": "",
                "quot": "\"",
                "QUOT": "\"",
                "rAarr": "",
                "race": "",
                "Racute": "",
                "racute": "",
                "radic": "",
                "raemptyv": "",
                "rang": "",
                "Rang": "",
                "rangd": "",
                "range": "",
                "rangle": "",
                "raquo": "",
                "rarrap": "",
                "rarrb": "",
                "rarrbfs": "",
                "rarrc": "",
                "rarr": "",
                "Rarr": "",
                "rArr": "",
                "rarrfs": "",
                "rarrhk": "",
                "rarrlp": "",
                "rarrpl": "",
                "rarrsim": "",
                "Rarrtl": "",
                "rarrtl": "",
                "rarrw": "",
                "ratail": "",
                "rAtail": "",
                "ratio": "",
                "rationals": "",
                "rbarr": "",
                "rBarr": "",
                "RBarr": "",
                "rbbrk": "",
                "rbrace": "}",
                "rbrack": "]",
                "rbrke": "",
                "rbrksld": "",
                "rbrkslu": "",
                "Rcaron": "",
                "rcaron": "",
                "Rcedil": "",
                "rcedil": "",
                "rceil": "",
                "rcub": "}",
                "Rcy": "",
                "rcy": "",
                "rdca": "",
                "rdldhar": "",
                "rdquo": "",
                "rdquor": "",
                "rdsh": "",
                "real": "",
                "realine": "",
                "realpart": "",
                "reals": "",
                "Re": "",
                "rect": "",
                "reg": "",
                "REG": "",
                "ReverseElement": "",
                "ReverseEquilibrium": "",
                "ReverseUpEquilibrium": "",
                "rfisht": "",
                "rfloor": "",
                "rfr": "",
                "Rfr": "",
                "rHar": "",
                "rhard": "",
                "rharu": "",
                "rharul": "",
                "Rho": "",
                "rho": "",
                "rhov": "",
                "RightAngleBracket": "",
                "RightArrowBar": "",
                "rightarrow": "",
                "RightArrow": "",
                "Rightarrow": "",
                "RightArrowLeftArrow": "",
                "rightarrowtail": "",
                "RightCeiling": "",
                "RightDoubleBracket": "",
                "RightDownTeeVector": "",
                "RightDownVectorBar": "",
                "RightDownVector": "",
                "RightFloor": "",
                "rightharpoondown": "",
                "rightharpoonup": "",
                "rightleftarrows": "",
                "rightleftharpoons": "",
                "rightrightarrows": "",
                "rightsquigarrow": "",
                "RightTeeArrow": "",
                "RightTee": "",
                "RightTeeVector": "",
                "rightthreetimes": "",
                "RightTriangleBar": "",
                "RightTriangle": "",
                "RightTriangleEqual": "",
                "RightUpDownVector": "",
                "RightUpTeeVector": "",
                "RightUpVectorBar": "",
                "RightUpVector": "",
                "RightVectorBar": "",
                "RightVector": "",
                "ring": "",
                "risingdotseq": "",
                "rlarr": "",
                "rlhar": "",
                "rlm": "",
                "rmoustache": "",
                "rmoust": "",
                "rnmid": "",
                "roang": "",
                "roarr": "",
                "robrk": "",
                "ropar": "",
                "ropf": "",
                "Ropf": "",
                "roplus": "",
                "rotimes": "",
                "RoundImplies": "",
                "rpar": ")",
                "rpargt": "",
                "rppolint": "",
                "rrarr": "",
                "Rrightarrow": "",
                "rsaquo": "",
                "rscr": "",
                "Rscr": "",
                "rsh": "",
                "Rsh": "",
                "rsqb": "]",
                "rsquo": "",
                "rsquor": "",
                "rthree": "",
                "rtimes": "",
                "rtri": "",
                "rtrie": "",
                "rtrif": "",
                "rtriltri": "",
                "RuleDelayed": "",
                "ruluhar": "",
                "rx": "",
                "Sacute": "",
                "sacute": "",
                "sbquo": "",
                "scap": "",
                "Scaron": "",
                "scaron": "",
                "Sc": "",
                "sc": "",
                "sccue": "",
                "sce": "",
                "scE": "",
                "Scedil": "",
                "scedil": "",
                "Scirc": "",
                "scirc": "",
                "scnap": "",
                "scnE": "",
                "scnsim": "",
                "scpolint": "",
                "scsim": "",
                "Scy": "",
                "scy": "",
                "sdotb": "",
                "sdot": "",
                "sdote": "",
                "searhk": "",
                "searr": "",
                "seArr": "",
                "searrow": "",
                "sect": "",
                "semi": ";",
                "seswar": "",
                "setminus": "",
                "setmn": "",
                "sext": "",
                "Sfr": "",
                "sfr": "",
                "sfrown": "",
                "sharp": "",
                "SHCHcy": "",
                "shchcy": "",
                "SHcy": "",
                "shcy": "",
                "ShortDownArrow": "",
                "ShortLeftArrow": "",
                "shortmid": "",
                "shortparallel": "",
                "ShortRightArrow": "",
                "ShortUpArrow": "",
                "shy": "",
                "Sigma": "",
                "sigma": "",
                "sigmaf": "",
                "sigmav": "",
                "sim": "",
                "simdot": "",
                "sime": "",
                "simeq": "",
                "simg": "",
                "simgE": "",
                "siml": "",
                "simlE": "",
                "simne": "",
                "simplus": "",
                "simrarr": "",
                "slarr": "",
                "SmallCircle": "",
                "smallsetminus": "",
                "smashp": "",
                "smeparsl": "",
                "smid": "",
                "smile": "",
                "smt": "",
                "smte": "",
                "smtes": "",
                "SOFTcy": "",
                "softcy": "",
                "solbar": "",
                "solb": "",
                "sol": "/",
                "Sopf": "",
                "sopf": "",
                "spades": "",
                "spadesuit": "",
                "spar": "",
                "sqcap": "",
                "sqcaps": "",
                "sqcup": "",
                "sqcups": "",
                "Sqrt": "",
                "sqsub": "",
                "sqsube": "",
                "sqsubset": "",
                "sqsubseteq": "",
                "sqsup": "",
                "sqsupe": "",
                "sqsupset": "",
                "sqsupseteq": "",
                "square": "",
                "Square": "",
                "SquareIntersection": "",
                "SquareSubset": "",
                "SquareSubsetEqual": "",
                "SquareSuperset": "",
                "SquareSupersetEqual": "",
                "SquareUnion": "",
                "squarf": "",
                "squ": "",
                "squf": "",
                "srarr": "",
                "Sscr": "",
                "sscr": "",
                "ssetmn": "",
                "ssmile": "",
                "sstarf": "",
                "Star": "",
                "star": "",
                "starf": "",
                "straightepsilon": "",
                "straightphi": "",
                "strns": "",
                "sub": "",
                "Sub": "",
                "subdot": "",
                "subE": "",
                "sube": "",
                "subedot": "",
                "submult": "",
                "subnE": "",
                "subne": "",
                "subplus": "",
                "subrarr": "",
                "subset": "",
                "Subset": "",
                "subseteq": "",
                "subseteqq": "",
                "SubsetEqual": "",
                "subsetneq": "",
                "subsetneqq": "",
                "subsim": "",
                "subsub": "",
                "subsup": "",
                "succapprox": "",
                "succ": "",
                "succcurlyeq": "",
                "Succeeds": "",
                "SucceedsEqual": "",
                "SucceedsSlantEqual": "",
                "SucceedsTilde": "",
                "succeq": "",
                "succnapprox": "",
                "succneqq": "",
                "succnsim": "",
                "succsim": "",
                "SuchThat": "",
                "sum": "",
                "Sum": "",
                "sung": "",
                "sup1": "",
                "sup2": "",
                "sup3": "",
                "sup": "",
                "Sup": "",
                "supdot": "",
                "supdsub": "",
                "supE": "",
                "supe": "",
                "supedot": "",
                "Superset": "",
                "SupersetEqual": "",
                "suphsol": "",
                "suphsub": "",
                "suplarr": "",
                "supmult": "",
                "supnE": "",
                "supne": "",
                "supplus": "",
                "supset": "",
                "Supset": "",
                "supseteq": "",
                "supseteqq": "",
                "supsetneq": "",
                "supsetneqq": "",
                "supsim": "",
                "supsub": "",
                "supsup": "",
                "swarhk": "",
                "swarr": "",
                "swArr": "",
                "swarrow": "",
                "swnwar": "",
                "szlig": "",
                "Tab": "\t",
                "target": "",
                "Tau": "",
                "tau": "",
                "tbrk": "",
                "Tcaron": "",
                "tcaron": "",
                "Tcedil": "",
                "tcedil": "",
                "Tcy": "",
                "tcy": "",
                "tdot": "",
                "telrec": "",
                "Tfr": "",
                "tfr": "",
                "there4": "",
                "therefore": "",
                "Therefore": "",
                "Theta": "",
                "theta": "",
                "thetasym": "",
                "thetav": "",
                "thickapprox": "",
                "thicksim": "",
                "ThickSpace": "",
                "ThinSpace": "",
                "thinsp": "",
                "thkap": "",
                "thksim": "",
                "THORN": "",
                "thorn": "",
                "tilde": "",
                "Tilde": "",
                "TildeEqual": "",
                "TildeFullEqual": "",
                "TildeTilde": "",
                "timesbar": "",
                "timesb": "",
                "times": "",
                "timesd": "",
                "tint": "",
                "toea": "",
                "topbot": "",
                "topcir": "",
                "top": "",
                "Topf": "",
                "topf": "",
                "topfork": "",
                "tosa": "",
                "tprime": "",
                "trade": "",
                "TRADE": "",
                "triangle": "",
                "triangledown": "",
                "triangleleft": "",
                "trianglelefteq": "",
                "triangleq": "",
                "triangleright": "",
                "trianglerighteq": "",
                "tridot": "",
                "trie": "",
                "triminus": "",
                "TripleDot": "",
                "triplus": "",
                "trisb": "",
                "tritime": "",
                "trpezium": "",
                "Tscr": "",
                "tscr": "",
                "TScy": "",
                "tscy": "",
                "TSHcy": "",
                "tshcy": "",
                "Tstrok": "",
                "tstrok": "",
                "twixt": "",
                "twoheadleftarrow": "",
                "twoheadrightarrow": "",
                "Uacute": "",
                "uacute": "",
                "uarr": "",
                "Uarr": "",
                "uArr": "",
                "Uarrocir": "",
                "Ubrcy": "",
                "ubrcy": "",
                "Ubreve": "",
                "ubreve": "",
                "Ucirc": "",
                "ucirc": "",
                "Ucy": "",
                "ucy": "",
                "udarr": "",
                "Udblac": "",
                "udblac": "",
                "udhar": "",
                "ufisht": "",
                "Ufr": "",
                "ufr": "",
                "Ugrave": "",
                "ugrave": "",
                "uHar": "",
                "uharl": "",
                "uharr": "",
                "uhblk": "",
                "ulcorn": "",
                "ulcorner": "",
                "ulcrop": "",
                "ultri": "",
                "Umacr": "",
                "umacr": "",
                "uml": "",
                "UnderBar": "_",
                "UnderBrace": "",
                "UnderBracket": "",
                "UnderParenthesis": "",
                "Union": "",
                "UnionPlus": "",
                "Uogon": "",
                "uogon": "",
                "Uopf": "",
                "uopf": "",
                "UpArrowBar": "",
                "uparrow": "",
                "UpArrow": "",
                "Uparrow": "",
                "UpArrowDownArrow": "",
                "updownarrow": "",
                "UpDownArrow": "",
                "Updownarrow": "",
                "UpEquilibrium": "",
                "upharpoonleft": "",
                "upharpoonright": "",
                "uplus": "",
                "UpperLeftArrow": "",
                "UpperRightArrow": "",
                "upsi": "",
                "Upsi": "",
                "upsih": "",
                "Upsilon": "",
                "upsilon": "",
                "UpTeeArrow": "",
                "UpTee": "",
                "upuparrows": "",
                "urcorn": "",
                "urcorner": "",
                "urcrop": "",
                "Uring": "",
                "uring": "",
                "urtri": "",
                "Uscr": "",
                "uscr": "",
                "utdot": "",
                "Utilde": "",
                "utilde": "",
                "utri": "",
                "utrif": "",
                "uuarr": "",
                "Uuml": "",
                "uuml": "",
                "uwangle": "",
                "vangrt": "",
                "varepsilon": "",
                "varkappa": "",
                "varnothing": "",
                "varphi": "",
                "varpi": "",
                "varpropto": "",
                "varr": "",
                "vArr": "",
                "varrho": "",
                "varsigma": "",
                "varsubsetneq": "",
                "varsubsetneqq": "",
                "varsupsetneq": "",
                "varsupsetneqq": "",
                "vartheta": "",
                "vartriangleleft": "",
                "vartriangleright": "",
                "vBar": "",
                "Vbar": "",
                "vBarv": "",
                "Vcy": "",
                "vcy": "",
                "vdash": "",
                "vDash": "",
                "Vdash": "",
                "VDash": "",
                "Vdashl": "",
                "veebar": "",
                "vee": "",
                "Vee": "",
                "veeeq": "",
                "vellip": "",
                "verbar": "|",
                "Verbar": "",
                "vert": "|",
                "Vert": "",
                "VerticalBar": "",
                "VerticalLine": "|",
                "VerticalSeparator": "",
                "VerticalTilde": "",
                "VeryThinSpace": "",
                "Vfr": "",
                "vfr": "",
                "vltri": "",
                "vnsub": "",
                "vnsup": "",
                "Vopf": "",
                "vopf": "",
                "vprop": "",
                "vrtri": "",
                "Vscr": "",
                "vscr": "",
                "vsubnE": "",
                "vsubne": "",
                "vsupnE": "",
                "vsupne": "",
                "Vvdash": "",
                "vzigzag": "",
                "Wcirc": "",
                "wcirc": "",
                "wedbar": "",
                "wedge": "",
                "Wedge": "",
                "wedgeq": "",
                "weierp": "",
                "Wfr": "",
                "wfr": "",
                "Wopf": "",
                "wopf": "",
                "wp": "",
                "wr": "",
                "wreath": "",
                "Wscr": "",
                "wscr": "",
                "xcap": "",
                "xcirc": "",
                "xcup": "",
                "xdtri": "",
                "Xfr": "",
                "xfr": "",
                "xharr": "",
                "xhArr": "",
                "Xi": "",
                "xi": "",
                "xlarr": "",
                "xlArr": "",
                "xmap": "",
                "xnis": "",
                "xodot": "",
                "Xopf": "",
                "xopf": "",
                "xoplus": "",
                "xotime": "",
                "xrarr": "",
                "xrArr": "",
                "Xscr": "",
                "xscr": "",
                "xsqcup": "",
                "xuplus": "",
                "xutri": "",
                "xvee": "",
                "xwedge": "",
                "Yacute": "",
                "yacute": "",
                "YAcy": "",
                "yacy": "",
                "Ycirc": "",
                "ycirc": "",
                "Ycy": "",
                "ycy": "",
                "yen": "",
                "Yfr": "",
                "yfr": "",
                "YIcy": "",
                "yicy": "",
                "Yopf": "",
                "yopf": "",
                "Yscr": "",
                "yscr": "",
                "YUcy": "",
                "yucy": "",
                "yuml": "",
                "Yuml": "",
                "Zacute": "",
                "zacute": "",
                "Zcaron": "",
                "zcaron": "",
                "Zcy": "",
                "zcy": "",
                "Zdot": "",
                "zdot": "",
                "zeetrf": "",
                "ZeroWidthSpace": "",
                "Zeta": "",
                "zeta": "",
                "zfr": "",
                "Zfr": "",
                "ZHcy": "",
                "zhcy": "",
                "zigrarr": "",
                "zopf": "",
                "Zopf": "",
                "Zscr": "",
                "zscr": "",
                "zwj": "",
                "zwnj": ""
            };

            /***/
        }),
        /* 266 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SSOServiceException = void 0;
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(112), exports);
            tslib_1.__exportStar(__webpack_require__(995), exports);
            tslib_1.__exportStar(__webpack_require__(366), exports);
            tslib_1.__exportStar(__webpack_require__(203), exports);
            tslib_1.__exportStar(__webpack_require__(355), exports);
            var SSOServiceException_1 = __webpack_require__(238);
            Object.defineProperty(exports, "SSOServiceException", {
                enumerable: true, get: function () {
                    return SSOServiceException_1.SSOServiceException;
                }
            });


            /***/
        }),
        /* 267 */,
        /* 268 */,
        /* 269 */,
        /* 270 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(236), exports);
            tslib_1.__exportStar(__webpack_require__(603), exports);
            tslib_1.__exportStar(__webpack_require__(64), exports);


            /***/
        }),
        /* 271 */,
        /* 272 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getInstanceMetadataEndpoint = exports.httpRequest = void 0;
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(136), exports);
            tslib_1.__exportStar(__webpack_require__(959), exports);
            tslib_1.__exportStar(__webpack_require__(116), exports);
            tslib_1.__exportStar(__webpack_require__(767), exports);
            var httpRequest_1 = __webpack_require__(214);
            Object.defineProperty(exports, "httpRequest", {
                enumerable: true, get: function () {
                    return httpRequest_1.httpRequest;
                }
            });
            var getInstanceMetadataEndpoint_1 = __webpack_require__(899);
            Object.defineProperty(exports, "getInstanceMetadataEndpoint", {
                enumerable: true, get: function () {
                    return getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint;
                }
            });


            /***/
        }),
        /* 273 */,
        /* 274 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.serializerMiddleware = void 0;
            const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
                const request = await serializer(args.input, options);
                return next({
                    ...args,
                    request,
                });
            };
            exports.serializerMiddleware = serializerMiddleware;


            /***/
        }),
        /* 275 */,
        /* 276 */,
        /* 277 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(827), exports);


            /***/
        }),
        /* 278 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromIni = void 0;
            const shared_ini_file_loader_1 = __webpack_require__(706);
            const resolveProfileData_1 = __webpack_require__(558);
            const fromIni = (init = {}) => async () => {
                const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
                return (0, resolveProfileData_1.resolveProfileData)((0, shared_ini_file_loader_1.getProfileName)(init), profiles, init);
            };
            exports.fromIni = fromIni;


            /***/
        }),
        /* 279 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            /*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

            function isObject(o) {
                return Object.prototype.toString.call(o) === '[object Object]';
            }

            function isPlainObject(o) {
                var ctor, prot;

                if (isObject(o) === false) return false;

                // If has modified constructor
                ctor = o.constructor;
                if (ctor === undefined) return true;

                // If has modified prototype
                prot = ctor.prototype;
                if (isObject(prot) === false) return false;

                // If constructor does not have an Object-specific method
                if (prot.hasOwnProperty('isPrototypeOf') === false) {
                    return false;
                }

                // Most likely a plain Object
                return true;
            }

            exports.isPlainObject = isPlainObject;


            /***/
        }),
        /* 280 */,
        /* 281 */,
        /* 282 */,
        /* 283 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.constructStack = void 0;
            const constructStack = () => {
                let absoluteEntries = [];
                let relativeEntries = [];
                const entriesNameSet = new Set();
                const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
                    priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
                const removeByName = (toRemove) => {
                    let isRemoved = false;
                    const filterCb = (entry) => {
                        if (entry.name && entry.name === toRemove) {
                            isRemoved = true;
                            entriesNameSet.delete(toRemove);
                            return false;
                        }
                        return true;
                    };
                    absoluteEntries = absoluteEntries.filter(filterCb);
                    relativeEntries = relativeEntries.filter(filterCb);
                    return isRemoved;
                };
                const removeByReference = (toRemove) => {
                    let isRemoved = false;
                    const filterCb = (entry) => {
                        if (entry.middleware === toRemove) {
                            isRemoved = true;
                            if (entry.name)
                                entriesNameSet.delete(entry.name);
                            return false;
                        }
                        return true;
                    };
                    absoluteEntries = absoluteEntries.filter(filterCb);
                    relativeEntries = relativeEntries.filter(filterCb);
                    return isRemoved;
                };
                const cloneTo = (toStack) => {
                    absoluteEntries.forEach((entry) => {
                        toStack.add(entry.middleware, {...entry});
                    });
                    relativeEntries.forEach((entry) => {
                        toStack.addRelativeTo(entry.middleware, {...entry});
                    });
                    return toStack;
                };
                const expandRelativeMiddlewareList = (from) => {
                    const expandedMiddlewareList = [];
                    from.before.forEach((entry) => {
                        if (entry.before.length === 0 && entry.after.length === 0) {
                            expandedMiddlewareList.push(entry);
                        } else {
                            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                        }
                    });
                    expandedMiddlewareList.push(from);
                    from.after.reverse().forEach((entry) => {
                        if (entry.before.length === 0 && entry.after.length === 0) {
                            expandedMiddlewareList.push(entry);
                        } else {
                            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                        }
                    });
                    return expandedMiddlewareList;
                };
                const getMiddlewareList = () => {
                    const normalizedAbsoluteEntries = [];
                    const normalizedRelativeEntries = [];
                    const normalizedEntriesNameMap = {};
                    absoluteEntries.forEach((entry) => {
                        const normalizedEntry = {
                            ...entry,
                            before: [],
                            after: [],
                        };
                        if (normalizedEntry.name)
                            normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
                        normalizedAbsoluteEntries.push(normalizedEntry);
                    });
                    relativeEntries.forEach((entry) => {
                        const normalizedEntry = {
                            ...entry,
                            before: [],
                            after: [],
                        };
                        if (normalizedEntry.name)
                            normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
                        normalizedRelativeEntries.push(normalizedEntry);
                    });
                    normalizedRelativeEntries.forEach((entry) => {
                        if (entry.toMiddleware) {
                            const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                            if (toMiddleware === undefined) {
                                throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
                            }
                            if (entry.relation === "after") {
                                toMiddleware.after.push(entry);
                            }
                            if (entry.relation === "before") {
                                toMiddleware.before.push(entry);
                            }
                        }
                    });
                    const mainChain = sort(normalizedAbsoluteEntries)
                        .map(expandRelativeMiddlewareList)
                        .reduce((wholeList, expendedMiddlewareList) => {
                            wholeList.push(...expendedMiddlewareList);
                            return wholeList;
                        }, []);
                    return mainChain.map((entry) => entry.middleware);
                };
                const stack = {
                    add: (middleware, options = {}) => {
                        const {name, override} = options;
                        const entry = {
                            step: "initialize",
                            priority: "normal",
                            middleware,
                            ...options,
                        };
                        if (name) {
                            if (entriesNameSet.has(name)) {
                                if (!override)
                                    throw new Error(`Duplicate middleware name '${name}'`);
                                const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === name);
                                const toOverride = absoluteEntries[toOverrideIndex];
                                if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
                                    throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be ` +
                                        `overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
                                }
                                absoluteEntries.splice(toOverrideIndex, 1);
                            }
                            entriesNameSet.add(name);
                        }
                        absoluteEntries.push(entry);
                    },
                    addRelativeTo: (middleware, options) => {
                        const {name, override} = options;
                        const entry = {
                            middleware,
                            ...options,
                        };
                        if (name) {
                            if (entriesNameSet.has(name)) {
                                if (!override)
                                    throw new Error(`Duplicate middleware name '${name}'`);
                                const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === name);
                                const toOverride = relativeEntries[toOverrideIndex];
                                if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                                    throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                        `by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
                                }
                                relativeEntries.splice(toOverrideIndex, 1);
                            }
                            entriesNameSet.add(name);
                        }
                        relativeEntries.push(entry);
                    },
                    clone: () => cloneTo((0, exports.constructStack)()),
                    use: (plugin) => {
                        plugin.applyToStack(stack);
                    },
                    remove: (toRemove) => {
                        if (typeof toRemove === "string")
                            return removeByName(toRemove);
                        else
                            return removeByReference(toRemove);
                    },
                    removeByTag: (toRemove) => {
                        let isRemoved = false;
                        const filterCb = (entry) => {
                            const {tags, name} = entry;
                            if (tags && tags.includes(toRemove)) {
                                if (name)
                                    entriesNameSet.delete(name);
                                isRemoved = true;
                                return false;
                            }
                            return true;
                        };
                        absoluteEntries = absoluteEntries.filter(filterCb);
                        relativeEntries = relativeEntries.filter(filterCb);
                        return isRemoved;
                    },
                    concat: (from) => {
                        const cloned = cloneTo((0, exports.constructStack)());
                        cloned.use(from);
                        return cloned;
                    },
                    applyToStack: cloneTo,
                    resolve: (handler, context) => {
                        for (const middleware of getMiddlewareList().reverse()) {
                            handler = middleware(handler, context);
                        }
                        return handler;
                    },
                };
                return stack;
            };
            exports.constructStack = constructStack;
            const stepWeights = {
                initialize: 5,
                serialize: 4,
                build: 3,
                finalizeRequest: 2,
                deserialize: 1,
            };
            const priorityWeights = {
                high: 3,
                normal: 2,
                low: 1,
            };


            /***/
        }),
        /* 284 */,
        /* 285 */,
        /* 286 */
        /***/ (function (module) {

            "use strict";


            var conversions = {};
            module.exports = conversions;

            function sign(x) {
                return x < 0 ? -1 : 1;
            }

            function evenRound(x) {
                // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
                if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)
                    return Math.floor(x);
                } else {
                    return Math.round(x);
                }
            }

            function createNumberConversion(bitLength, typeOpts) {
                if (!typeOpts.unsigned) {
                    --bitLength;
                }
                const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
                const upperBound = Math.pow(2, bitLength) - 1;

                const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
                const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);

                return function (V, opts) {
                    if (!opts) opts = {};

                    let x = +V;

                    if (opts.enforceRange) {
                        if (!Number.isFinite(x)) {
                            throw new TypeError("Argument is not a finite number");
                        }

                        x = sign(x) * Math.floor(Math.abs(x));
                        if (x < lowerBound || x > upperBound) {
                            throw new TypeError("Argument is not in byte range");
                        }

                        return x;
                    }

                    if (!isNaN(x) && opts.clamp) {
                        x = evenRound(x);

                        if (x < lowerBound) x = lowerBound;
                        if (x > upperBound) x = upperBound;
                        return x;
                    }

                    if (!Number.isFinite(x) || x === 0) {
                        return 0;
                    }

                    x = sign(x) * Math.floor(Math.abs(x));
                    x = x % moduloVal;

                    if (!typeOpts.unsigned && x >= moduloBound) {
                        return x - moduloVal;
                    } else if (typeOpts.unsigned) {
                        if (x < 0) {
                            x += moduloVal;
                        } else if (x === -0) { // don't return negative zero
                            return 0;
                        }
                    }

                    return x;
                }
            }

            conversions["void"] = function () {
                return undefined;
            };

            conversions["boolean"] = function (val) {
                return !!val;
            };

            conversions["byte"] = createNumberConversion(8, {unsigned: false});
            conversions["octet"] = createNumberConversion(8, {unsigned: true});

            conversions["short"] = createNumberConversion(16, {unsigned: false});
            conversions["unsigned short"] = createNumberConversion(16, {unsigned: true});

            conversions["long"] = createNumberConversion(32, {unsigned: false});
            conversions["unsigned long"] = createNumberConversion(32, {unsigned: true});

            conversions["long long"] = createNumberConversion(32, {unsigned: false, moduloBitLength: 64});
            conversions["unsigned long long"] = createNumberConversion(32, {unsigned: true, moduloBitLength: 64});

            conversions["double"] = function (V) {
                const x = +V;

                if (!Number.isFinite(x)) {
                    throw new TypeError("Argument is not a finite floating-point value");
                }

                return x;
            };

            conversions["unrestricted double"] = function (V) {
                const x = +V;

                if (isNaN(x)) {
                    throw new TypeError("Argument is NaN");
                }

                return x;
            };

// not quite valid, but good enough for JS
            conversions["float"] = conversions["double"];
            conversions["unrestricted float"] = conversions["unrestricted double"];

            conversions["DOMString"] = function (V, opts) {
                if (!opts) opts = {};

                if (opts.treatNullAsEmptyString && V === null) {
                    return "";
                }

                return String(V);
            };

            conversions["ByteString"] = function (V, opts) {
                const x = String(V);
                let c = undefined;
                for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
                    if (c > 255) {
                        throw new TypeError("Argument is not a valid bytestring");
                    }
                }

                return x;
            };

            conversions["USVString"] = function (V) {
                const S = String(V);
                const n = S.length;
                const U = [];
                for (let i = 0; i < n; ++i) {
                    const c = S.charCodeAt(i);
                    if (c < 0xD800 || c > 0xDFFF) {
                        U.push(String.fromCodePoint(c));
                    } else if (0xDC00 <= c && c <= 0xDFFF) {
                        U.push(String.fromCodePoint(0xFFFD));
                    } else {
                        if (i === n - 1) {
                            U.push(String.fromCodePoint(0xFFFD));
                        } else {
                            const d = S.charCodeAt(i + 1);
                            if (0xDC00 <= d && d <= 0xDFFF) {
                                const a = c & 0x3FF;
                                const b = d & 0x3FF;
                                U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                                ++i;
                            } else {
                                U.push(String.fromCodePoint(0xFFFD));
                            }
                        }
                    }
                }

                return U.join('');
            };

            conversions["Date"] = function (V, opts) {
                if (!(V instanceof Date)) {
                    throw new TypeError("Argument is not a Date object");
                }
                if (isNaN(V)) {
                    return undefined;
                }

                return V;
            };

            conversions["RegExp"] = function (V, opts) {
                if (!(V instanceof RegExp)) {
                    V = new RegExp(V);
                }

                return V;
            };


            /***/
        }),
        /* 287 */,
        /* 288 */,
        /* 289 */,
        /* 290 */,
        /* 291 */,
        /* 292 */,
        /* 293 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";
            /* eslint no-undefined: 0 */


            const MimeNode = __webpack_require__(652);
            const mimeFuncs = __webpack_require__(103);

            /**
             * Creates the object for composing a MimeNode instance out from the mail options
             *
             * @constructor
             * @param {Object} mail Mail options
             */
            class MailComposer {
                constructor(mail) {
                    this.mail = mail || {};
                    this.message = false;
                }

                /**
                 * Builds MimeNode instance
                 */
                compile() {
                    this._alternatives = this.getAlternatives();
                    this._htmlNode = this._alternatives.filter(alternative => /^text\/html\b/i.test(alternative.contentType)).pop();
                    this._attachments = this.getAttachments(!!this._htmlNode);

                    this._useRelated = !!(this._htmlNode && this._attachments.related.length);
                    this._useAlternative = this._alternatives.length > 1;
                    this._useMixed = this._attachments.attached.length > 1 || (this._alternatives.length && this._attachments.attached.length === 1);

                    // Compose MIME tree
                    if (this.mail.raw) {
                        this.message = new MimeNode('message/rfc822', {newline: this.mail.newline}).setRaw(this.mail.raw);
                    } else if (this._useMixed) {
                        this.message = this._createMixed();
                    } else if (this._useAlternative) {
                        this.message = this._createAlternative();
                    } else if (this._useRelated) {
                        this.message = this._createRelated();
                    } else {
                        this.message = this._createContentNode(
                            false,
                            []
                                .concat(this._alternatives || [])
                                .concat(this._attachments.attached || [])
                                .shift() || {
                                contentType: 'text/plain',
                                content: ''
                            }
                        );
                    }

                    // Add custom headers
                    if (this.mail.headers) {
                        this.message.addHeader(this.mail.headers);
                    }

                    // Add headers to the root node, always overrides custom headers
                    ['from', 'sender', 'to', 'cc', 'bcc', 'reply-to', 'in-reply-to', 'references', 'subject', 'message-id', 'date'].forEach(header => {
                        let key = header.replace(/-(\w)/g, (o, c) => c.toUpperCase());
                        if (this.mail[key]) {
                            this.message.setHeader(header, this.mail[key]);
                        }
                    });

                    // Sets custom envelope
                    if (this.mail.envelope) {
                        this.message.setEnvelope(this.mail.envelope);
                    }

                    // ensure Message-Id value
                    this.message.messageId();

                    return this.message;
                }

                /**
                 * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes
                 *
                 * @param {Boolean} findRelated If true separate related attachments from attached ones
                 * @returns {Object} An object of arrays (`related` and `attached`)
                 */
                getAttachments(findRelated) {
                    let icalEvent, eventObject;
                    let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {
                        let data;
                        let isMessageNode = /^message\//i.test(attachment.contentType);

                        if (/^data:/i.test(attachment.path || attachment.href)) {
                            attachment = this._processDataUrl(attachment);
                        }

                        data = {
                            contentType: attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin'),
                            contentDisposition: attachment.contentDisposition || (isMessageNode ? 'inline' : 'attachment'),
                            contentTransferEncoding: 'contentTransferEncoding' in attachment ? attachment.contentTransferEncoding : 'base64'
                        };

                        if (attachment.filename) {
                            data.filename = attachment.filename;
                        } else if (!isMessageNode && attachment.filename !== false) {
                            data.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);
                            if (data.filename.indexOf('.') < 0) {
                                data.filename += '.' + mimeFuncs.detectExtension(data.contentType);
                            }
                        }

                        if (/^https?:\/\//i.test(attachment.path)) {
                            attachment.href = attachment.path;
                            attachment.path = undefined;
                        }

                        if (attachment.cid) {
                            data.cid = attachment.cid;
                        }

                        if (attachment.raw) {
                            data.raw = attachment.raw;
                        } else if (attachment.path) {
                            data.content = {
                                path: attachment.path
                            };
                        } else if (attachment.href) {
                            data.content = {
                                href: attachment.href,
                                httpHeaders: attachment.httpHeaders
                            };
                        } else {
                            data.content = attachment.content || '';
                        }

                        if (attachment.encoding) {
                            data.encoding = attachment.encoding;
                        }

                        if (attachment.headers) {
                            data.headers = attachment.headers;
                        }

                        return data;
                    });

                    if (this.mail.icalEvent) {
                        if (
                            typeof this.mail.icalEvent === 'object' &&
                            (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)
                        ) {
                            icalEvent = this.mail.icalEvent;
                        } else {
                            icalEvent = {
                                content: this.mail.icalEvent
                            };
                        }

                        eventObject = {};
                        Object.keys(icalEvent).forEach(key => {
                            eventObject[key] = icalEvent[key];
                        });

                        eventObject.contentType = 'application/ics';
                        if (!eventObject.headers) {
                            eventObject.headers = {};
                        }
                        eventObject.filename = eventObject.filename || 'invite.ics';
                        eventObject.headers['Content-Disposition'] = 'attachment';
                        eventObject.headers['Content-Transfer-Encoding'] = 'base64';
                    }

                    if (!findRelated) {
                        return {
                            attached: attachments.concat(eventObject || []),
                            related: []
                        };
                    } else {
                        return {
                            attached: attachments.filter(attachment => !attachment.cid).concat(eventObject || []),
                            related: attachments.filter(attachment => !!attachment.cid)
                        };
                    }
                }

                /**
                 * List alternatives. Resulting objects can be used as input for MimeNode nodes
                 *
                 * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well
                 */
                getAlternatives() {
                    let alternatives = [],
                        text,
                        html,
                        watchHtml,
                        amp,
                        icalEvent,
                        eventObject;

                    if (this.mail.text) {
                        if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
                            text = this.mail.text;
                        } else {
                            text = {
                                content: this.mail.text
                            };
                        }
                        text.contentType = 'text/plain; charset=utf-8';
                    }

                    if (this.mail.watchHtml) {
                        if (
                            typeof this.mail.watchHtml === 'object' &&
                            (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)
                        ) {
                            watchHtml = this.mail.watchHtml;
                        } else {
                            watchHtml = {
                                content: this.mail.watchHtml
                            };
                        }
                        watchHtml.contentType = 'text/watch-html; charset=utf-8';
                    }

                    if (this.mail.amp) {
                        if (typeof this.mail.amp === 'object' && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
                            amp = this.mail.amp;
                        } else {
                            amp = {
                                content: this.mail.amp
                            };
                        }
                        amp.contentType = 'text/x-amp-html; charset=utf-8';
                    }

                    // NB! when including attachments with a calendar alternative you might end up in a blank screen on some clients
                    if (this.mail.icalEvent) {
                        if (
                            typeof this.mail.icalEvent === 'object' &&
                            (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)
                        ) {
                            icalEvent = this.mail.icalEvent;
                        } else {
                            icalEvent = {
                                content: this.mail.icalEvent
                            };
                        }

                        eventObject = {};
                        Object.keys(icalEvent).forEach(key => {
                            eventObject[key] = icalEvent[key];
                        });

                        if (eventObject.content && typeof eventObject.content === 'object') {
                            // we are going to have the same attachment twice, so mark this to be
                            // resolved just once
                            eventObject.content._resolve = true;
                        }

                        eventObject.filename = false;
                        eventObject.contentType = 'text/calendar; charset=utf-8; method=' + (eventObject.method || 'PUBLISH').toString().trim().toUpperCase();
                        if (!eventObject.headers) {
                            eventObject.headers = {};
                        }
                    }

                    if (this.mail.html) {
                        if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
                            html = this.mail.html;
                        } else {
                            html = {
                                content: this.mail.html
                            };
                        }
                        html.contentType = 'text/html; charset=utf-8';
                    }

                    []
                        .concat(text || [])
                        .concat(watchHtml || [])
                        .concat(amp || [])
                        .concat(html || [])
                        .concat(eventObject || [])
                        .concat(this.mail.alternatives || [])
                        .forEach(alternative => {
                            let data;

                            if (/^data:/i.test(alternative.path || alternative.href)) {
                                alternative = this._processDataUrl(alternative);
                            }

                            data = {
                                contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),
                                contentTransferEncoding: alternative.contentTransferEncoding
                            };

                            if (alternative.filename) {
                                data.filename = alternative.filename;
                            }

                            if (/^https?:\/\//i.test(alternative.path)) {
                                alternative.href = alternative.path;
                                alternative.path = undefined;
                            }

                            if (alternative.raw) {
                                data.raw = alternative.raw;
                            } else if (alternative.path) {
                                data.content = {
                                    path: alternative.path
                                };
                            } else if (alternative.href) {
                                data.content = {
                                    href: alternative.href
                                };
                            } else {
                                data.content = alternative.content || '';
                            }

                            if (alternative.encoding) {
                                data.encoding = alternative.encoding;
                            }

                            if (alternative.headers) {
                                data.headers = alternative.headers;
                            }

                            alternatives.push(data);
                        });

                    return alternatives;
                }

                /**
                 * Builds multipart/mixed node. It should always contain different type of elements on the same level
                 * eg. text + attachments
                 *
                 * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
                 * @returns {Object} MimeNode node element
                 */
                _createMixed(parentNode) {
                    let node;

                    if (!parentNode) {
                        node = new MimeNode('multipart/mixed', {
                            baseBoundary: this.mail.baseBoundary,
                            textEncoding: this.mail.textEncoding,
                            boundaryPrefix: this.mail.boundaryPrefix,
                            disableUrlAccess: this.mail.disableUrlAccess,
                            disableFileAccess: this.mail.disableFileAccess,
                            normalizeHeaderKey: this.mail.normalizeHeaderKey,
                            newline: this.mail.newline
                        });
                    } else {
                        node = parentNode.createChild('multipart/mixed', {
                            disableUrlAccess: this.mail.disableUrlAccess,
                            disableFileAccess: this.mail.disableFileAccess,
                            normalizeHeaderKey: this.mail.normalizeHeaderKey,
                            newline: this.mail.newline
                        });
                    }

                    if (this._useAlternative) {
                        this._createAlternative(node);
                    } else if (this._useRelated) {
                        this._createRelated(node);
                    }

                    []
                        .concat((!this._useAlternative && this._alternatives) || [])
                        .concat(this._attachments.attached || [])
                        .forEach(element => {
                            // if the element is a html node from related subpart then ignore it
                            if (!this._useRelated || element !== this._htmlNode) {
                                this._createContentNode(node, element);
                            }
                        });

                    return node;
                }

                /**
                 * Builds multipart/alternative node. It should always contain same type of elements on the same level
                 * eg. text + html view of the same data
                 *
                 * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
                 * @returns {Object} MimeNode node element
                 */
                _createAlternative(parentNode) {
                    let node;

                    if (!parentNode) {
                        node = new MimeNode('multipart/alternative', {
                            baseBoundary: this.mail.baseBoundary,
                            textEncoding: this.mail.textEncoding,
                            boundaryPrefix: this.mail.boundaryPrefix,
                            disableUrlAccess: this.mail.disableUrlAccess,
                            disableFileAccess: this.mail.disableFileAccess,
                            normalizeHeaderKey: this.mail.normalizeHeaderKey,
                            newline: this.mail.newline
                        });
                    } else {
                        node = parentNode.createChild('multipart/alternative', {
                            disableUrlAccess: this.mail.disableUrlAccess,
                            disableFileAccess: this.mail.disableFileAccess,
                            normalizeHeaderKey: this.mail.normalizeHeaderKey,
                            newline: this.mail.newline
                        });
                    }

                    this._alternatives.forEach(alternative => {
                        if (this._useRelated && this._htmlNode === alternative) {
                            this._createRelated(node);
                        } else {
                            this._createContentNode(node, alternative);
                        }
                    });

                    return node;
                }

                /**
                 * Builds multipart/related node. It should always contain html node with related attachments
                 *
                 * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
                 * @returns {Object} MimeNode node element
                 */
                _createRelated(parentNode) {
                    let node;

                    if (!parentNode) {
                        node = new MimeNode('multipart/related; type="text/html"', {
                            baseBoundary: this.mail.baseBoundary,
                            textEncoding: this.mail.textEncoding,
                            boundaryPrefix: this.mail.boundaryPrefix,
                            disableUrlAccess: this.mail.disableUrlAccess,
                            disableFileAccess: this.mail.disableFileAccess,
                            normalizeHeaderKey: this.mail.normalizeHeaderKey,
                            newline: this.mail.newline
                        });
                    } else {
                        node = parentNode.createChild('multipart/related; type="text/html"', {
                            disableUrlAccess: this.mail.disableUrlAccess,
                            disableFileAccess: this.mail.disableFileAccess,
                            normalizeHeaderKey: this.mail.normalizeHeaderKey,
                            newline: this.mail.newline
                        });
                    }

                    this._createContentNode(node, this._htmlNode);

                    this._attachments.related.forEach(alternative => this._createContentNode(node, alternative));

                    return node;
                }

                /**
                 * Creates a regular node with contents
                 *
                 * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
                 * @param {Object} element Node data
                 * @returns {Object} MimeNode node element
                 */
                _createContentNode(parentNode, element) {
                    element = element || {};
                    element.content = element.content || '';

                    let node;
                    let encoding = (element.encoding || 'utf8')
                        .toString()
                        .toLowerCase()
                        .replace(/[-_\s]/g, '');

                    if (!parentNode) {
                        node = new MimeNode(element.contentType, {
                            filename: element.filename,
                            baseBoundary: this.mail.baseBoundary,
                            textEncoding: this.mail.textEncoding,
                            boundaryPrefix: this.mail.boundaryPrefix,
                            disableUrlAccess: this.mail.disableUrlAccess,
                            disableFileAccess: this.mail.disableFileAccess,
                            normalizeHeaderKey: this.mail.normalizeHeaderKey,
                            newline: this.mail.newline
                        });
                    } else {
                        node = parentNode.createChild(element.contentType, {
                            filename: element.filename,
                            textEncoding: this.mail.textEncoding,
                            disableUrlAccess: this.mail.disableUrlAccess,
                            disableFileAccess: this.mail.disableFileAccess,
                            normalizeHeaderKey: this.mail.normalizeHeaderKey,
                            newline: this.mail.newline
                        });
                    }

                    // add custom headers
                    if (element.headers) {
                        node.addHeader(element.headers);
                    }

                    if (element.cid) {
                        node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');
                    }

                    if (element.contentTransferEncoding) {
                        node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);
                    } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
                        node.setHeader('Content-Transfer-Encoding', this.mail.encoding);
                    }

                    if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
                        node.setHeader('Content-Disposition', element.contentDisposition || (element.cid ? 'inline' : 'attachment'));
                    }

                    if (typeof element.content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {
                        element.content = Buffer.from(element.content, encoding);
                    }

                    // prefer pregenerated raw content
                    if (element.raw) {
                        node.setRaw(element.raw);
                    } else {
                        node.setContent(element.content);
                    }

                    return node;
                }

                /**
                 * Parses data uri and converts it to a Buffer
                 *
                 * @param {Object} element Content element
                 * @return {Object} Parsed element
                 */
                _processDataUrl(element) {
                    let parts = (element.path || element.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);
                    if (!parts) {
                        return element;
                    }

                    element.content = /\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2]));

                    if ('path' in element) {
                        element.path = false;
                    }

                    if ('href' in element) {
                        element.href = false;
                    }

                    parts[1].split(';').forEach(item => {
                        if (/^\w+\/[^/]+$/i.test(item)) {
                            element.contentType = element.contentType || item.toLowerCase();
                        }
                    });

                    return element;
                }
            }

            module.exports = MailComposer;


            /***/
        }),
        /* 294 */,
        /* 295 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.toBase64 = exports.fromBase64 = void 0;
            const util_buffer_from_1 = __webpack_require__(75);
            const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;

            function fromBase64(input) {
                if ((input.length * 3) % 4 !== 0) {
                    throw new TypeError(`Incorrect padding on base64 string.`);
                }
                if (!BASE64_REGEX.exec(input)) {
                    throw new TypeError(`Invalid base64 string.`);
                }
                const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
                return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
            }

            exports.fromBase64 = fromBase64;

            function toBase64(input) {
                return (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
            }

            exports.toBase64 = toBase64;


            /***/
        }),
        /* 296 */,
        /* 297 */,
        /* 298 */,
        /* 299 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            module.exports = __webpack_require__(686);


            /***/
        }),
        /* 300 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const stream = __webpack_require__(413);
            const Transform = stream.Transform;

            /**
             * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>
             * Also makes sure that only <CR><LF> sequences are used for linebreaks
             *
             * @param {Object} options Stream options
             */
            class DataStream extends Transform {
                constructor(options) {
                    super(options);
                    // init Transform
                    this.options = options || {};
                    this._curLine = '';

                    this.inByteCount = 0;
                    this.outByteCount = 0;
                    this.lastByte = false;
                }

                /**
                 * Escapes dots
                 */
                _transform(chunk, encoding, done) {
                    let chunks = [];
                    let chunklen = 0;
                    let i,
                        len,
                        lastPos = 0;
                    let buf;

                    if (!chunk || !chunk.length) {
                        return done();
                    }

                    if (typeof chunk === 'string') {
                        chunk = Buffer.from(chunk);
                    }

                    this.inByteCount += chunk.length;

                    for (i = 0, len = chunk.length; i < len; i++) {
                        if (chunk[i] === 0x2e) {
                            // .
                            if ((i && chunk[i - 1] === 0x0a) || (!i && (!this.lastByte || this.lastByte === 0x0a))) {
                                buf = chunk.slice(lastPos, i + 1);
                                chunks.push(buf);
                                chunks.push(Buffer.from('.'));
                                chunklen += buf.length + 1;
                                lastPos = i + 1;
                            }
                        } else if (chunk[i] === 0x0a) {
                            // .
                            if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {
                                if (i > lastPos) {
                                    buf = chunk.slice(lastPos, i);
                                    chunks.push(buf);
                                    chunklen += buf.length + 2;
                                } else {
                                    chunklen += 2;
                                }
                                chunks.push(Buffer.from('\r\n'));
                                lastPos = i + 1;
                            }
                        }
                    }

                    if (chunklen) {
                        // add last piece
                        if (lastPos < chunk.length) {
                            buf = chunk.slice(lastPos);
                            chunks.push(buf);
                            chunklen += buf.length;
                        }

                        this.outByteCount += chunklen;
                        this.push(Buffer.concat(chunks, chunklen));
                    } else {
                        this.outByteCount += chunk.length;
                        this.push(chunk);
                    }

                    this.lastByte = chunk[chunk.length - 1];
                    done();
                }

                /**
                 * Finalizes the stream with a dot on a single line
                 */
                _flush(done) {
                    let buf;
                    if (this.lastByte === 0x0a) {
                        buf = Buffer.from('.\r\n');
                    } else if (this.lastByte === 0x0d) {
                        buf = Buffer.from('\n.\r\n');
                    } else {
                        buf = Buffer.from('\r\n.\r\n');
                    }
                    this.outByteCount += buf.length;
                    this.push(buf);
                    done();
                }
            }

            module.exports = DataStream;


            /***/
        }),
        /* 301 */,
        /* 302 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SES = void 0;
            const CloneReceiptRuleSetCommand_1 = __webpack_require__(672);
            const CreateConfigurationSetCommand_1 = __webpack_require__(330);
            const CreateConfigurationSetEventDestinationCommand_1 = __webpack_require__(546);
            const CreateConfigurationSetTrackingOptionsCommand_1 = __webpack_require__(864);
            const CreateCustomVerificationEmailTemplateCommand_1 = __webpack_require__(788);
            const CreateReceiptFilterCommand_1 = __webpack_require__(194);
            const CreateReceiptRuleCommand_1 = __webpack_require__(448);
            const CreateReceiptRuleSetCommand_1 = __webpack_require__(253);
            const CreateTemplateCommand_1 = __webpack_require__(554);
            const DeleteConfigurationSetCommand_1 = __webpack_require__(602);
            const DeleteConfigurationSetEventDestinationCommand_1 = __webpack_require__(115);
            const DeleteConfigurationSetTrackingOptionsCommand_1 = __webpack_require__(812);
            const DeleteCustomVerificationEmailTemplateCommand_1 = __webpack_require__(425);
            const DeleteIdentityCommand_1 = __webpack_require__(251);
            const DeleteIdentityPolicyCommand_1 = __webpack_require__(384);
            const DeleteReceiptFilterCommand_1 = __webpack_require__(186);
            const DeleteReceiptRuleCommand_1 = __webpack_require__(184);
            const DeleteReceiptRuleSetCommand_1 = __webpack_require__(711);
            const DeleteTemplateCommand_1 = __webpack_require__(908);
            const DeleteVerifiedEmailAddressCommand_1 = __webpack_require__(954);
            const DescribeActiveReceiptRuleSetCommand_1 = __webpack_require__(108);
            const DescribeConfigurationSetCommand_1 = __webpack_require__(322);
            const DescribeReceiptRuleCommand_1 = __webpack_require__(227);
            const DescribeReceiptRuleSetCommand_1 = __webpack_require__(369);
            const GetAccountSendingEnabledCommand_1 = __webpack_require__(455);
            const GetCustomVerificationEmailTemplateCommand_1 = __webpack_require__(444);
            const GetIdentityDkimAttributesCommand_1 = __webpack_require__(68);
            const GetIdentityMailFromDomainAttributesCommand_1 = __webpack_require__(871);
            const GetIdentityNotificationAttributesCommand_1 = __webpack_require__(861);
            const GetIdentityPoliciesCommand_1 = __webpack_require__(391);
            const GetIdentityVerificationAttributesCommand_1 = __webpack_require__(370);
            const GetSendQuotaCommand_1 = __webpack_require__(998);
            const GetSendStatisticsCommand_1 = __webpack_require__(156);
            const GetTemplateCommand_1 = __webpack_require__(756);
            const ListConfigurationSetsCommand_1 = __webpack_require__(91);
            const ListCustomVerificationEmailTemplatesCommand_1 = __webpack_require__(458);
            const ListIdentitiesCommand_1 = __webpack_require__(843);
            const ListIdentityPoliciesCommand_1 = __webpack_require__(836);
            const ListReceiptFiltersCommand_1 = __webpack_require__(90);
            const ListReceiptRuleSetsCommand_1 = __webpack_require__(100);
            const ListTemplatesCommand_1 = __webpack_require__(62);
            const ListVerifiedEmailAddressesCommand_1 = __webpack_require__(395);
            const PutConfigurationSetDeliveryOptionsCommand_1 = __webpack_require__(991);
            const PutIdentityPolicyCommand_1 = __webpack_require__(641);
            const ReorderReceiptRuleSetCommand_1 = __webpack_require__(6);
            const SendBounceCommand_1 = __webpack_require__(46);
            const SendBulkTemplatedEmailCommand_1 = __webpack_require__(10);
            const SendCustomVerificationEmailCommand_1 = __webpack_require__(651);
            const SendEmailCommand_1 = __webpack_require__(77);
            const SendRawEmailCommand_1 = __webpack_require__(577);
            const SendTemplatedEmailCommand_1 = __webpack_require__(907);
            const SetActiveReceiptRuleSetCommand_1 = __webpack_require__(86);
            const SetIdentityDkimEnabledCommand_1 = __webpack_require__(462);
            const SetIdentityFeedbackForwardingEnabledCommand_1 = __webpack_require__(110);
            const SetIdentityHeadersInNotificationsEnabledCommand_1 = __webpack_require__(398);
            const SetIdentityMailFromDomainCommand_1 = __webpack_require__(976);
            const SetIdentityNotificationTopicCommand_1 = __webpack_require__(649);
            const SetReceiptRulePositionCommand_1 = __webpack_require__(926);
            const TestRenderTemplateCommand_1 = __webpack_require__(916);
            const UpdateAccountSendingEnabledCommand_1 = __webpack_require__(166);
            const UpdateConfigurationSetEventDestinationCommand_1 = __webpack_require__(309);
            const UpdateConfigurationSetReputationMetricsEnabledCommand_1 = __webpack_require__(224);
            const UpdateConfigurationSetSendingEnabledCommand_1 = __webpack_require__(42);
            const UpdateConfigurationSetTrackingOptionsCommand_1 = __webpack_require__(501);
            const UpdateCustomVerificationEmailTemplateCommand_1 = __webpack_require__(375);
            const UpdateReceiptRuleCommand_1 = __webpack_require__(754);
            const UpdateTemplateCommand_1 = __webpack_require__(125);
            const VerifyDomainDkimCommand_1 = __webpack_require__(9);
            const VerifyDomainIdentityCommand_1 = __webpack_require__(811);
            const VerifyEmailAddressCommand_1 = __webpack_require__(970);
            const VerifyEmailIdentityCommand_1 = __webpack_require__(412);
            const SESClient_1 = __webpack_require__(522);

            class SES extends SESClient_1.SESClient {
                cloneReceiptRuleSet(args, optionsOrCb, cb) {
                    const command = new CloneReceiptRuleSetCommand_1.CloneReceiptRuleSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                createConfigurationSet(args, optionsOrCb, cb) {
                    const command = new CreateConfigurationSetCommand_1.CreateConfigurationSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                createConfigurationSetEventDestination(args, optionsOrCb, cb) {
                    const command = new CreateConfigurationSetEventDestinationCommand_1.CreateConfigurationSetEventDestinationCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                createConfigurationSetTrackingOptions(args, optionsOrCb, cb) {
                    const command = new CreateConfigurationSetTrackingOptionsCommand_1.CreateConfigurationSetTrackingOptionsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                createCustomVerificationEmailTemplate(args, optionsOrCb, cb) {
                    const command = new CreateCustomVerificationEmailTemplateCommand_1.CreateCustomVerificationEmailTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                createReceiptFilter(args, optionsOrCb, cb) {
                    const command = new CreateReceiptFilterCommand_1.CreateReceiptFilterCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                createReceiptRule(args, optionsOrCb, cb) {
                    const command = new CreateReceiptRuleCommand_1.CreateReceiptRuleCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                createReceiptRuleSet(args, optionsOrCb, cb) {
                    const command = new CreateReceiptRuleSetCommand_1.CreateReceiptRuleSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                createTemplate(args, optionsOrCb, cb) {
                    const command = new CreateTemplateCommand_1.CreateTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteConfigurationSet(args, optionsOrCb, cb) {
                    const command = new DeleteConfigurationSetCommand_1.DeleteConfigurationSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteConfigurationSetEventDestination(args, optionsOrCb, cb) {
                    const command = new DeleteConfigurationSetEventDestinationCommand_1.DeleteConfigurationSetEventDestinationCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteConfigurationSetTrackingOptions(args, optionsOrCb, cb) {
                    const command = new DeleteConfigurationSetTrackingOptionsCommand_1.DeleteConfigurationSetTrackingOptionsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteCustomVerificationEmailTemplate(args, optionsOrCb, cb) {
                    const command = new DeleteCustomVerificationEmailTemplateCommand_1.DeleteCustomVerificationEmailTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteIdentity(args, optionsOrCb, cb) {
                    const command = new DeleteIdentityCommand_1.DeleteIdentityCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteIdentityPolicy(args, optionsOrCb, cb) {
                    const command = new DeleteIdentityPolicyCommand_1.DeleteIdentityPolicyCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteReceiptFilter(args, optionsOrCb, cb) {
                    const command = new DeleteReceiptFilterCommand_1.DeleteReceiptFilterCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteReceiptRule(args, optionsOrCb, cb) {
                    const command = new DeleteReceiptRuleCommand_1.DeleteReceiptRuleCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteReceiptRuleSet(args, optionsOrCb, cb) {
                    const command = new DeleteReceiptRuleSetCommand_1.DeleteReceiptRuleSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteTemplate(args, optionsOrCb, cb) {
                    const command = new DeleteTemplateCommand_1.DeleteTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                deleteVerifiedEmailAddress(args, optionsOrCb, cb) {
                    const command = new DeleteVerifiedEmailAddressCommand_1.DeleteVerifiedEmailAddressCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                describeActiveReceiptRuleSet(args, optionsOrCb, cb) {
                    const command = new DescribeActiveReceiptRuleSetCommand_1.DescribeActiveReceiptRuleSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                describeConfigurationSet(args, optionsOrCb, cb) {
                    const command = new DescribeConfigurationSetCommand_1.DescribeConfigurationSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                describeReceiptRule(args, optionsOrCb, cb) {
                    const command = new DescribeReceiptRuleCommand_1.DescribeReceiptRuleCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                describeReceiptRuleSet(args, optionsOrCb, cb) {
                    const command = new DescribeReceiptRuleSetCommand_1.DescribeReceiptRuleSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getAccountSendingEnabled(args, optionsOrCb, cb) {
                    const command = new GetAccountSendingEnabledCommand_1.GetAccountSendingEnabledCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getCustomVerificationEmailTemplate(args, optionsOrCb, cb) {
                    const command = new GetCustomVerificationEmailTemplateCommand_1.GetCustomVerificationEmailTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getIdentityDkimAttributes(args, optionsOrCb, cb) {
                    const command = new GetIdentityDkimAttributesCommand_1.GetIdentityDkimAttributesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getIdentityMailFromDomainAttributes(args, optionsOrCb, cb) {
                    const command = new GetIdentityMailFromDomainAttributesCommand_1.GetIdentityMailFromDomainAttributesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getIdentityNotificationAttributes(args, optionsOrCb, cb) {
                    const command = new GetIdentityNotificationAttributesCommand_1.GetIdentityNotificationAttributesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getIdentityPolicies(args, optionsOrCb, cb) {
                    const command = new GetIdentityPoliciesCommand_1.GetIdentityPoliciesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getIdentityVerificationAttributes(args, optionsOrCb, cb) {
                    const command = new GetIdentityVerificationAttributesCommand_1.GetIdentityVerificationAttributesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getSendQuota(args, optionsOrCb, cb) {
                    const command = new GetSendQuotaCommand_1.GetSendQuotaCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getSendStatistics(args, optionsOrCb, cb) {
                    const command = new GetSendStatisticsCommand_1.GetSendStatisticsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                getTemplate(args, optionsOrCb, cb) {
                    const command = new GetTemplateCommand_1.GetTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listConfigurationSets(args, optionsOrCb, cb) {
                    const command = new ListConfigurationSetsCommand_1.ListConfigurationSetsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listCustomVerificationEmailTemplates(args, optionsOrCb, cb) {
                    const command = new ListCustomVerificationEmailTemplatesCommand_1.ListCustomVerificationEmailTemplatesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listIdentities(args, optionsOrCb, cb) {
                    const command = new ListIdentitiesCommand_1.ListIdentitiesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listIdentityPolicies(args, optionsOrCb, cb) {
                    const command = new ListIdentityPoliciesCommand_1.ListIdentityPoliciesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listReceiptFilters(args, optionsOrCb, cb) {
                    const command = new ListReceiptFiltersCommand_1.ListReceiptFiltersCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listReceiptRuleSets(args, optionsOrCb, cb) {
                    const command = new ListReceiptRuleSetsCommand_1.ListReceiptRuleSetsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listTemplates(args, optionsOrCb, cb) {
                    const command = new ListTemplatesCommand_1.ListTemplatesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                listVerifiedEmailAddresses(args, optionsOrCb, cb) {
                    const command = new ListVerifiedEmailAddressesCommand_1.ListVerifiedEmailAddressesCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                putConfigurationSetDeliveryOptions(args, optionsOrCb, cb) {
                    const command = new PutConfigurationSetDeliveryOptionsCommand_1.PutConfigurationSetDeliveryOptionsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                putIdentityPolicy(args, optionsOrCb, cb) {
                    const command = new PutIdentityPolicyCommand_1.PutIdentityPolicyCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                reorderReceiptRuleSet(args, optionsOrCb, cb) {
                    const command = new ReorderReceiptRuleSetCommand_1.ReorderReceiptRuleSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                sendBounce(args, optionsOrCb, cb) {
                    const command = new SendBounceCommand_1.SendBounceCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                sendBulkTemplatedEmail(args, optionsOrCb, cb) {
                    const command = new SendBulkTemplatedEmailCommand_1.SendBulkTemplatedEmailCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                sendCustomVerificationEmail(args, optionsOrCb, cb) {
                    const command = new SendCustomVerificationEmailCommand_1.SendCustomVerificationEmailCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                sendEmail(args, optionsOrCb, cb) {
                    const command = new SendEmailCommand_1.SendEmailCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                sendRawEmail(args, optionsOrCb, cb) {
                    const command = new SendRawEmailCommand_1.SendRawEmailCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                sendTemplatedEmail(args, optionsOrCb, cb) {
                    const command = new SendTemplatedEmailCommand_1.SendTemplatedEmailCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                setActiveReceiptRuleSet(args, optionsOrCb, cb) {
                    const command = new SetActiveReceiptRuleSetCommand_1.SetActiveReceiptRuleSetCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                setIdentityDkimEnabled(args, optionsOrCb, cb) {
                    const command = new SetIdentityDkimEnabledCommand_1.SetIdentityDkimEnabledCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                setIdentityFeedbackForwardingEnabled(args, optionsOrCb, cb) {
                    const command = new SetIdentityFeedbackForwardingEnabledCommand_1.SetIdentityFeedbackForwardingEnabledCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                setIdentityHeadersInNotificationsEnabled(args, optionsOrCb, cb) {
                    const command = new SetIdentityHeadersInNotificationsEnabledCommand_1.SetIdentityHeadersInNotificationsEnabledCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                setIdentityMailFromDomain(args, optionsOrCb, cb) {
                    const command = new SetIdentityMailFromDomainCommand_1.SetIdentityMailFromDomainCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                setIdentityNotificationTopic(args, optionsOrCb, cb) {
                    const command = new SetIdentityNotificationTopicCommand_1.SetIdentityNotificationTopicCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                setReceiptRulePosition(args, optionsOrCb, cb) {
                    const command = new SetReceiptRulePositionCommand_1.SetReceiptRulePositionCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                testRenderTemplate(args, optionsOrCb, cb) {
                    const command = new TestRenderTemplateCommand_1.TestRenderTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                updateAccountSendingEnabled(args, optionsOrCb, cb) {
                    const command = new UpdateAccountSendingEnabledCommand_1.UpdateAccountSendingEnabledCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                updateConfigurationSetEventDestination(args, optionsOrCb, cb) {
                    const command = new UpdateConfigurationSetEventDestinationCommand_1.UpdateConfigurationSetEventDestinationCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                updateConfigurationSetReputationMetricsEnabled(args, optionsOrCb, cb) {
                    const command = new UpdateConfigurationSetReputationMetricsEnabledCommand_1.UpdateConfigurationSetReputationMetricsEnabledCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                updateConfigurationSetSendingEnabled(args, optionsOrCb, cb) {
                    const command = new UpdateConfigurationSetSendingEnabledCommand_1.UpdateConfigurationSetSendingEnabledCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                updateConfigurationSetTrackingOptions(args, optionsOrCb, cb) {
                    const command = new UpdateConfigurationSetTrackingOptionsCommand_1.UpdateConfigurationSetTrackingOptionsCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                updateCustomVerificationEmailTemplate(args, optionsOrCb, cb) {
                    const command = new UpdateCustomVerificationEmailTemplateCommand_1.UpdateCustomVerificationEmailTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                updateReceiptRule(args, optionsOrCb, cb) {
                    const command = new UpdateReceiptRuleCommand_1.UpdateReceiptRuleCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                updateTemplate(args, optionsOrCb, cb) {
                    const command = new UpdateTemplateCommand_1.UpdateTemplateCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                verifyDomainDkim(args, optionsOrCb, cb) {
                    const command = new VerifyDomainDkimCommand_1.VerifyDomainDkimCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                verifyDomainIdentity(args, optionsOrCb, cb) {
                    const command = new VerifyDomainIdentityCommand_1.VerifyDomainIdentityCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                verifyEmailAddress(args, optionsOrCb, cb) {
                    const command = new VerifyEmailAddressCommand_1.VerifyEmailAddressCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }

                verifyEmailIdentity(args, optionsOrCb, cb) {
                    const command = new VerifyEmailIdentityCommand_1.VerifyEmailIdentityCommand(args);
                    if (typeof optionsOrCb === "function") {
                        this.send(command, optionsOrCb);
                    } else if (typeof cb === "function") {
                        if (typeof optionsOrCb !== "object")
                            throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
                        this.send(command, optionsOrCb || {}, cb);
                    } else {
                        return this.send(command, optionsOrCb);
                    }
                }
            }

            exports.SES = SES;


            /***/
        }),
        /* 303 */,
        /* 304 */,
        /* 305 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const Mailer = __webpack_require__(988);
            const shared = __webpack_require__(190);
            const SMTPPool = __webpack_require__(884);
            const SMTPTransport = __webpack_require__(975);
            const SendmailTransport = __webpack_require__(632);
            const StreamTransport = __webpack_require__(507);
            const JSONTransport = __webpack_require__(174);
            const SESTransport = __webpack_require__(481);
            const fetch = __webpack_require__(204);
            const packageData = __webpack_require__(786);

            const ETHEREAL_API = (process.env.ETHEREAL_API || 'https://api.nodemailer.com').replace(/\/+$/, '');
            const ETHEREAL_WEB = (process.env.ETHEREAL_WEB || 'https://ethereal.email').replace(/\/+$/, '');
            const ETHEREAL_CACHE = ['true', 'yes', 'y', '1'].includes((process.env.ETHEREAL_CACHE || 'yes').toString().trim().toLowerCase());

            let testAccount = false;

            module.exports.createTransport = function (transporter, defaults) {
                let urlConfig;
                let options;
                let mailer;

                if (
                    // provided transporter is a configuration object, not transporter plugin
                    (typeof transporter === 'object' && typeof transporter.send !== 'function') ||
                    // provided transporter looks like a connection url
                    (typeof transporter === 'string' && /^(smtps?|direct):/i.test(transporter))
                ) {
                    if ((urlConfig = typeof transporter === 'string' ? transporter : transporter.url)) {
                        // parse a configuration URL into configuration options
                        options = shared.parseConnectionUrl(urlConfig);
                    } else {
                        options = transporter;
                    }

                    if (options.pool) {
                        transporter = new SMTPPool(options);
                    } else if (options.sendmail) {
                        transporter = new SendmailTransport(options);
                    } else if (options.streamTransport) {
                        transporter = new StreamTransport(options);
                    } else if (options.jsonTransport) {
                        transporter = new JSONTransport(options);
                    } else if (options.SES) {
                        transporter = new SESTransport(options);
                    } else {
                        transporter = new SMTPTransport(options);
                    }
                }

                mailer = new Mailer(transporter, options, defaults);

                return mailer;
            };

            module.exports.createTestAccount = function (apiUrl, callback) {
                let promise;

                if (!callback && typeof apiUrl === 'function') {
                    callback = apiUrl;
                    apiUrl = false;
                }

                if (!callback) {
                    promise = new Promise((resolve, reject) => {
                        callback = shared.callbackPromise(resolve, reject);
                    });
                }

                if (ETHEREAL_CACHE && testAccount) {
                    setImmediate(() => callback(null, testAccount));
                    return promise;
                }

                apiUrl = apiUrl || ETHEREAL_API;

                let chunks = [];
                let chunklen = 0;

                let req = fetch(apiUrl + '/user', {
                    contentType: 'application/json',
                    method: 'POST',
                    body: Buffer.from(
                        JSON.stringify({
                            requestor: packageData.name,
                            version: packageData.version
                        })
                    )
                });

                req.on('readable', () => {
                    let chunk;
                    while ((chunk = req.read()) !== null) {
                        chunks.push(chunk);
                        chunklen += chunk.length;
                    }
                });

                req.once('error', err => callback(err));

                req.once('end', () => {
                    let res = Buffer.concat(chunks, chunklen);
                    let data;
                    let err;
                    try {
                        data = JSON.parse(res.toString());
                    } catch (E) {
                        err = E;
                    }
                    if (err) {
                        return callback(err);
                    }
                    if (data.status !== 'success' || data.error) {
                        return callback(new Error(data.error || 'Request failed'));
                    }
                    delete data.status;
                    testAccount = data;
                    callback(null, testAccount);
                });

                return promise;
            };

            module.exports.getTestMessageUrl = function (info) {
                if (!info || !info.response) {
                    return false;
                }

                let infoProps = new Map();
                info.response.replace(/\[([^\]]+)\]$/, (m, props) => {
                    props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m, key, value) => {
                        infoProps.set(key, value);
                    });
                });

                if (infoProps.has('STATUS') && infoProps.has('MSGID')) {
                    return (testAccount.web || ETHEREAL_WEB) + '/message/' + infoProps.get('MSGID');
                }

                return false;
            };


            /***/
        }),
        /* 306 */,
        /* 307 */,
        /* 308 */,
        /* 309 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UpdateConfigurationSetEventDestinationCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class UpdateConfigurationSetEventDestinationCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "UpdateConfigurationSetEventDestinationCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.UpdateConfigurationSetEventDestinationRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.UpdateConfigurationSetEventDestinationResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryUpdateConfigurationSetEventDestinationCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryUpdateConfigurationSetEventDestinationCommand)(output, context);
                }
            }

            exports.UpdateConfigurationSetEventDestinationCommand = UpdateConfigurationSetEventDestinationCommand;


            /***/
        }),
        /* 310 */,
        /* 311 */
        /***/ (function (module) {

            "use strict";


            module.exports.mixin = function mixin(target, source) {
                const keys = Object.getOwnPropertyNames(source);
                for (let i = 0; i < keys.length; ++i) {
                    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
                }
            };

            module.exports.wrapperSymbol = Symbol("wrapper");
            module.exports.implSymbol = Symbol("impl");

            module.exports.wrapperForImpl = function (impl) {
                return impl[module.exports.wrapperSymbol];
            };

            module.exports.implForWrapper = function (wrapper) {
                return wrapper[module.exports.implSymbol];
            };


            /***/
        }),
        /* 312 */,
        /* 313 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.sleep = void 0;
            const sleep = (seconds) => {
                return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
            };
            exports.sleep = sleep;


            /***/
        }),
        /* 314 */,
        /* 315 */,
        /* 316 */,
        /* 317 */,
        /* 318 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getHostHeaderPlugin = exports.hostHeaderMiddlewareOptions = exports.hostHeaderMiddleware = exports.resolveHostHeaderConfig = void 0;
            const protocol_http_1 = __webpack_require__(197);

            function resolveHostHeaderConfig(input) {
                return input;
            }

            exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
            const hostHeaderMiddleware = (options) => (next) => async (args) => {
                if (!protocol_http_1.HttpRequest.isInstance(args.request))
                    return next(args);
                const {request} = args;
                const {handlerProtocol = ""} = options.requestHandler.metadata || {};
                if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
                    delete request.headers["host"];
                    request.headers[":authority"] = "";
                } else if (!request.headers["host"]) {
                    request.headers["host"] = request.hostname;
                }
                return next(args);
            };
            exports.hostHeaderMiddleware = hostHeaderMiddleware;
            exports.hostHeaderMiddlewareOptions = {
                name: "hostHeaderMiddleware",
                step: "build",
                priority: "low",
                tags: ["HOST"],
                override: true,
            };
            const getHostHeaderPlugin = (options) => ({
                applyToStack: (clientStack) => {
                    clientStack.add((0, exports.hostHeaderMiddleware)(options), exports.hostHeaderMiddlewareOptions);
                },
            });
            exports.getHostHeaderPlugin = getHostHeaderPlugin;


            /***/
        }),
        /* 319 */,
        /* 320 */,
        /* 321 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(533), exports);
            tslib_1.__exportStar(__webpack_require__(215), exports);
            tslib_1.__exportStar(__webpack_require__(79), exports);
            tslib_1.__exportStar(__webpack_require__(347), exports);


            /***/
        }),
        /* 322 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DescribeConfigurationSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DescribeConfigurationSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DescribeConfigurationSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DescribeConfigurationSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DescribeConfigurationSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDescribeConfigurationSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDescribeConfigurationSetCommand)(output, context);
                }
            }

            exports.DescribeConfigurationSetCommand = DescribeConfigurationSetCommand;


            /***/
        }),
        /* 323 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getProfileName = exports.DEFAULT_PROFILE = exports.ENV_PROFILE = void 0;
            exports.ENV_PROFILE = "AWS_PROFILE";
            exports.DEFAULT_PROFILE = "default";
            const getProfileName = (init) => init.profile || process.env[exports.ENV_PROFILE] || exports.DEFAULT_PROFILE;
            exports.getProfileName = getProfileName;


            /***/
        }),
        /* 324 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(556), exports);
            tslib_1.__exportStar(__webpack_require__(41), exports);
            tslib_1.__exportStar(__webpack_require__(486), exports);
            tslib_1.__exportStar(__webpack_require__(418), exports);


            /***/
        }),
        /* 325 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromEnv = void 0;
            const property_provider_1 = __webpack_require__(118);
            const fromEnv = (envVarSelector) => async () => {
                try {
                    const config = envVarSelector(process.env);
                    if (config === undefined) {
                        throw new Error();
                    }
                    return config;
                } catch (e) {
                    throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
                }
            };
            exports.fromEnv = fromEnv;


            /***/
        }),
        /* 326 */,
        /* 327 */,
        /* 328 */,
        /* 329 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.memoize = void 0;
            const memoize = (provider, isExpired, requiresRefresh) => {
                let resolved;
                let pending;
                let hasResult;
                let isConstant = false;
                const coalesceProvider = async () => {
                    if (!pending) {
                        pending = provider();
                    }
                    try {
                        resolved = await pending;
                        hasResult = true;
                        isConstant = false;
                    } finally {
                        pending = undefined;
                    }
                    return resolved;
                };
                if (isExpired === undefined) {
                    return async (options) => {
                        if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
                            resolved = await coalesceProvider();
                        }
                        return resolved;
                    };
                }
                return async (options) => {
                    if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
                        resolved = await coalesceProvider();
                    }
                    if (isConstant) {
                        return resolved;
                    }
                    if (requiresRefresh && !requiresRefresh(resolved)) {
                        isConstant = true;
                        return resolved;
                    }
                    if (isExpired(resolved)) {
                        await coalesceProvider();
                        return resolved;
                    }
                    return resolved;
                };
            };
            exports.memoize = memoize;


            /***/
        }),
        /* 330 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CreateConfigurationSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CreateConfigurationSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CreateConfigurationSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CreateConfigurationSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.CreateConfigurationSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCreateConfigurationSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCreateConfigurationSetCommand)(output, context);
                }
            }

            exports.CreateConfigurationSetCommand = CreateConfigurationSetCommand;


            /***/
        }),
        /* 331 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.validateWaiterOptions = void 0;
            const validateWaiterOptions = (options) => {
                if (options.maxWaitTime < 1) {
                    throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
                } else if (options.minDelay < 1) {
                    throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
                } else if (options.maxDelay < 1) {
                    throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
                } else if (options.maxWaitTime <= options.minDelay) {
                    throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
                } else if (options.maxDelay < options.minDelay) {
                    throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
                }
            };
            exports.validateWaiterOptions = validateWaiterOptions;


            /***/
        }),
        /* 332 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";
            /* eslint quote-props: 0 */


            const path = __webpack_require__(622);

            const defaultMimeType = 'application/octet-stream';
            const defaultExtension = 'bin';

            const mimeTypes = new Map([
                ['application/acad', 'dwg'],
                ['application/applixware', 'aw'],
                ['application/arj', 'arj'],
                ['application/atom+xml', 'xml'],
                ['application/atomcat+xml', 'atomcat'],
                ['application/atomsvc+xml', 'atomsvc'],
                ['application/base64', ['mm', 'mme']],
                ['application/binhex', 'hqx'],
                ['application/binhex4', 'hqx'],
                ['application/book', ['book', 'boo']],
                ['application/ccxml+xml,', 'ccxml'],
                ['application/cdf', 'cdf'],
                ['application/cdmi-capability', 'cdmia'],
                ['application/cdmi-container', 'cdmic'],
                ['application/cdmi-domain', 'cdmid'],
                ['application/cdmi-object', 'cdmio'],
                ['application/cdmi-queue', 'cdmiq'],
                ['application/clariscad', 'ccad'],
                ['application/commonground', 'dp'],
                ['application/cu-seeme', 'cu'],
                ['application/davmount+xml', 'davmount'],
                ['application/drafting', 'drw'],
                ['application/dsptype', 'tsp'],
                ['application/dssc+der', 'dssc'],
                ['application/dssc+xml', 'xdssc'],
                ['application/dxf', 'dxf'],
                ['application/ecmascript', ['js', 'es']],
                ['application/emma+xml', 'emma'],
                ['application/envoy', 'evy'],
                ['application/epub+zip', 'epub'],
                ['application/excel', ['xls', 'xl', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],
                ['application/exi', 'exi'],
                ['application/font-tdpfr', 'pfr'],
                ['application/fractals', 'fif'],
                ['application/freeloader', 'frl'],
                ['application/futuresplash', 'spl'],
                ['application/gnutar', 'tgz'],
                ['application/groupwise', 'vew'],
                ['application/hlp', 'hlp'],
                ['application/hta', 'hta'],
                ['application/hyperstudio', 'stk'],
                ['application/i-deas', 'unv'],
                ['application/iges', ['iges', 'igs']],
                ['application/inf', 'inf'],
                ['application/internet-property-stream', 'acx'],
                ['application/ipfix', 'ipfix'],
                ['application/java', 'class'],
                ['application/java-archive', 'jar'],
                ['application/java-byte-code', 'class'],
                ['application/java-serialized-object', 'ser'],
                ['application/java-vm', 'class'],
                ['application/javascript', 'js'],
                ['application/json', 'json'],
                ['application/lha', 'lha'],
                ['application/lzx', 'lzx'],
                ['application/mac-binary', 'bin'],
                ['application/mac-binhex', 'hqx'],
                ['application/mac-binhex40', 'hqx'],
                ['application/mac-compactpro', 'cpt'],
                ['application/macbinary', 'bin'],
                ['application/mads+xml', 'mads'],
                ['application/marc', 'mrc'],
                ['application/marcxml+xml', 'mrcx'],
                ['application/mathematica', 'ma'],
                ['application/mathml+xml', 'mathml'],
                ['application/mbedlet', 'mbd'],
                ['application/mbox', 'mbox'],
                ['application/mcad', 'mcd'],
                ['application/mediaservercontrol+xml', 'mscml'],
                ['application/metalink4+xml', 'meta4'],
                ['application/mets+xml', 'mets'],
                ['application/mime', 'aps'],
                ['application/mods+xml', 'mods'],
                ['application/mp21', 'm21'],
                ['application/mp4', 'mp4'],
                ['application/mspowerpoint', ['ppt', 'pot', 'pps', 'ppz']],
                ['application/msword', ['doc', 'dot', 'w6w', 'wiz', 'word']],
                ['application/mswrite', 'wri'],
                ['application/mxf', 'mxf'],
                ['application/netmc', 'mcp'],
                ['application/octet-stream', ['*']],
                ['application/oda', 'oda'],
                ['application/oebps-package+xml', 'opf'],
                ['application/ogg', 'ogx'],
                ['application/olescript', 'axs'],
                ['application/onenote', 'onetoc'],
                ['application/patch-ops-error+xml', 'xer'],
                ['application/pdf', 'pdf'],
                ['application/pgp-encrypted', 'asc'],
                ['application/pgp-signature', 'pgp'],
                ['application/pics-rules', 'prf'],
                ['application/pkcs-12', 'p12'],
                ['application/pkcs-crl', 'crl'],
                ['application/pkcs10', 'p10'],
                ['application/pkcs7-mime', ['p7c', 'p7m']],
                ['application/pkcs7-signature', 'p7s'],
                ['application/pkcs8', 'p8'],
                ['application/pkix-attr-cert', 'ac'],
                ['application/pkix-cert', ['cer', 'crt']],
                ['application/pkix-crl', 'crl'],
                ['application/pkix-pkipath', 'pkipath'],
                ['application/pkixcmp', 'pki'],
                ['application/plain', 'text'],
                ['application/pls+xml', 'pls'],
                ['application/postscript', ['ps', 'ai', 'eps']],
                ['application/powerpoint', 'ppt'],
                ['application/pro_eng', ['part', 'prt']],
                ['application/prs.cww', 'cww'],
                ['application/pskc+xml', 'pskcxml'],
                ['application/rdf+xml', 'rdf'],
                ['application/reginfo+xml', 'rif'],
                ['application/relax-ng-compact-syntax', 'rnc'],
                ['application/resource-lists+xml', 'rl'],
                ['application/resource-lists-diff+xml', 'rld'],
                ['application/ringing-tones', 'rng'],
                ['application/rls-services+xml', 'rs'],
                ['application/rsd+xml', 'rsd'],
                ['application/rss+xml', 'xml'],
                ['application/rtf', ['rtf', 'rtx']],
                ['application/sbml+xml', 'sbml'],
                ['application/scvp-cv-request', 'scq'],
                ['application/scvp-cv-response', 'scs'],
                ['application/scvp-vp-request', 'spq'],
                ['application/scvp-vp-response', 'spp'],
                ['application/sdp', 'sdp'],
                ['application/sea', 'sea'],
                ['application/set', 'set'],
                ['application/set-payment-initiation', 'setpay'],
                ['application/set-registration-initiation', 'setreg'],
                ['application/shf+xml', 'shf'],
                ['application/sla', 'stl'],
                ['application/smil', ['smi', 'smil']],
                ['application/smil+xml', 'smi'],
                ['application/solids', 'sol'],
                ['application/sounder', 'sdr'],
                ['application/sparql-query', 'rq'],
                ['application/sparql-results+xml', 'srx'],
                ['application/srgs', 'gram'],
                ['application/srgs+xml', 'grxml'],
                ['application/sru+xml', 'sru'],
                ['application/ssml+xml', 'ssml'],
                ['application/step', ['step', 'stp']],
                ['application/streamingmedia', 'ssm'],
                ['application/tei+xml', 'tei'],
                ['application/thraud+xml', 'tfi'],
                ['application/timestamped-data', 'tsd'],
                ['application/toolbook', 'tbk'],
                ['application/vda', 'vda'],
                ['application/vnd.3gpp.pic-bw-large', 'plb'],
                ['application/vnd.3gpp.pic-bw-small', 'psb'],
                ['application/vnd.3gpp.pic-bw-var', 'pvb'],
                ['application/vnd.3gpp2.tcap', 'tcap'],
                ['application/vnd.3m.post-it-notes', 'pwn'],
                ['application/vnd.accpac.simply.aso', 'aso'],
                ['application/vnd.accpac.simply.imp', 'imp'],
                ['application/vnd.acucobol', 'acu'],
                ['application/vnd.acucorp', 'atc'],
                ['application/vnd.adobe.air-application-installer-package+zip', 'air'],
                ['application/vnd.adobe.fxp', 'fxp'],
                ['application/vnd.adobe.xdp+xml', 'xdp'],
                ['application/vnd.adobe.xfdf', 'xfdf'],
                ['application/vnd.ahead.space', 'ahead'],
                ['application/vnd.airzip.filesecure.azf', 'azf'],
                ['application/vnd.airzip.filesecure.azs', 'azs'],
                ['application/vnd.amazon.ebook', 'azw'],
                ['application/vnd.americandynamics.acc', 'acc'],
                ['application/vnd.amiga.ami', 'ami'],
                ['application/vnd.android.package-archive', 'apk'],
                ['application/vnd.anser-web-certificate-issue-initiation', 'cii'],
                ['application/vnd.anser-web-funds-transfer-initiation', 'fti'],
                ['application/vnd.antix.game-component', 'atx'],
                ['application/vnd.apple.installer+xml', 'mpkg'],
                ['application/vnd.apple.mpegurl', 'm3u8'],
                ['application/vnd.aristanetworks.swi', 'swi'],
                ['application/vnd.audiograph', 'aep'],
                ['application/vnd.blueice.multipass', 'mpm'],
                ['application/vnd.bmi', 'bmi'],
                ['application/vnd.businessobjects', 'rep'],
                ['application/vnd.chemdraw+xml', 'cdxml'],
                ['application/vnd.chipnuts.karaoke-mmd', 'mmd'],
                ['application/vnd.cinderella', 'cdy'],
                ['application/vnd.claymore', 'cla'],
                ['application/vnd.cloanto.rp9', 'rp9'],
                ['application/vnd.clonk.c4group', 'c4g'],
                ['application/vnd.cluetrust.cartomobile-config', 'c11amc'],
                ['application/vnd.cluetrust.cartomobile-config-pkg', 'c11amz'],
                ['application/vnd.commonspace', 'csp'],
                ['application/vnd.contact.cmsg', 'cdbcmsg'],
                ['application/vnd.cosmocaller', 'cmc'],
                ['application/vnd.crick.clicker', 'clkx'],
                ['application/vnd.crick.clicker.keyboard', 'clkk'],
                ['application/vnd.crick.clicker.palette', 'clkp'],
                ['application/vnd.crick.clicker.template', 'clkt'],
                ['application/vnd.crick.clicker.wordbank', 'clkw'],
                ['application/vnd.criticaltools.wbs+xml', 'wbs'],
                ['application/vnd.ctc-posml', 'pml'],
                ['application/vnd.cups-ppd', 'ppd'],
                ['application/vnd.curl.car', 'car'],
                ['application/vnd.curl.pcurl', 'pcurl'],
                ['application/vnd.data-vision.rdz', 'rdz'],
                ['application/vnd.denovo.fcselayout-link', 'fe_launch'],
                ['application/vnd.dna', 'dna'],
                ['application/vnd.dolby.mlp', 'mlp'],
                ['application/vnd.dpgraph', 'dpg'],
                ['application/vnd.dreamfactory', 'dfac'],
                ['application/vnd.dvb.ait', 'ait'],
                ['application/vnd.dvb.service', 'svc'],
                ['application/vnd.dynageo', 'geo'],
                ['application/vnd.ecowin.chart', 'mag'],
                ['application/vnd.enliven', 'nml'],
                ['application/vnd.epson.esf', 'esf'],
                ['application/vnd.epson.msf', 'msf'],
                ['application/vnd.epson.quickanime', 'qam'],
                ['application/vnd.epson.salt', 'slt'],
                ['application/vnd.epson.ssf', 'ssf'],
                ['application/vnd.eszigno3+xml', 'es3'],
                ['application/vnd.ezpix-album', 'ez2'],
                ['application/vnd.ezpix-package', 'ez3'],
                ['application/vnd.fdf', 'fdf'],
                ['application/vnd.fdsn.seed', 'seed'],
                ['application/vnd.flographit', 'gph'],
                ['application/vnd.fluxtime.clip', 'ftc'],
                ['application/vnd.framemaker', 'fm'],
                ['application/vnd.frogans.fnc', 'fnc'],
                ['application/vnd.frogans.ltf', 'ltf'],
                ['application/vnd.fsc.weblaunch', 'fsc'],
                ['application/vnd.fujitsu.oasys', 'oas'],
                ['application/vnd.fujitsu.oasys2', 'oa2'],
                ['application/vnd.fujitsu.oasys3', 'oa3'],
                ['application/vnd.fujitsu.oasysgp', 'fg5'],
                ['application/vnd.fujitsu.oasysprs', 'bh2'],
                ['application/vnd.fujixerox.ddd', 'ddd'],
                ['application/vnd.fujixerox.docuworks', 'xdw'],
                ['application/vnd.fujixerox.docuworks.binder', 'xbd'],
                ['application/vnd.fuzzysheet', 'fzs'],
                ['application/vnd.genomatix.tuxedo', 'txd'],
                ['application/vnd.geogebra.file', 'ggb'],
                ['application/vnd.geogebra.tool', 'ggt'],
                ['application/vnd.geometry-explorer', 'gex'],
                ['application/vnd.geonext', 'gxt'],
                ['application/vnd.geoplan', 'g2w'],
                ['application/vnd.geospace', 'g3w'],
                ['application/vnd.gmx', 'gmx'],
                ['application/vnd.google-earth.kml+xml', 'kml'],
                ['application/vnd.google-earth.kmz', 'kmz'],
                ['application/vnd.grafeq', 'gqf'],
                ['application/vnd.groove-account', 'gac'],
                ['application/vnd.groove-help', 'ghf'],
                ['application/vnd.groove-identity-message', 'gim'],
                ['application/vnd.groove-injector', 'grv'],
                ['application/vnd.groove-tool-message', 'gtm'],
                ['application/vnd.groove-tool-template', 'tpl'],
                ['application/vnd.groove-vcard', 'vcg'],
                ['application/vnd.hal+xml', 'hal'],
                ['application/vnd.handheld-entertainment+xml', 'zmm'],
                ['application/vnd.hbci', 'hbci'],
                ['application/vnd.hhe.lesson-player', 'les'],
                ['application/vnd.hp-hpgl', ['hgl', 'hpg', 'hpgl']],
                ['application/vnd.hp-hpid', 'hpid'],
                ['application/vnd.hp-hps', 'hps'],
                ['application/vnd.hp-jlyt', 'jlt'],
                ['application/vnd.hp-pcl', 'pcl'],
                ['application/vnd.hp-pclxl', 'pclxl'],
                ['application/vnd.hydrostatix.sof-data', 'sfd-hdstx'],
                ['application/vnd.hzn-3d-crossword', 'x3d'],
                ['application/vnd.ibm.minipay', 'mpy'],
                ['application/vnd.ibm.modcap', 'afp'],
                ['application/vnd.ibm.rights-management', 'irm'],
                ['application/vnd.ibm.secure-container', 'sc'],
                ['application/vnd.iccprofile', 'icc'],
                ['application/vnd.igloader', 'igl'],
                ['application/vnd.immervision-ivp', 'ivp'],
                ['application/vnd.immervision-ivu', 'ivu'],
                ['application/vnd.insors.igm', 'igm'],
                ['application/vnd.intercon.formnet', 'xpw'],
                ['application/vnd.intergeo', 'i2g'],
                ['application/vnd.intu.qbo', 'qbo'],
                ['application/vnd.intu.qfx', 'qfx'],
                ['application/vnd.ipunplugged.rcprofile', 'rcprofile'],
                ['application/vnd.irepository.package+xml', 'irp'],
                ['application/vnd.is-xpr', 'xpr'],
                ['application/vnd.isac.fcs', 'fcs'],
                ['application/vnd.jam', 'jam'],
                ['application/vnd.jcp.javame.midlet-rms', 'rms'],
                ['application/vnd.jisp', 'jisp'],
                ['application/vnd.joost.joda-archive', 'joda'],
                ['application/vnd.kahootz', 'ktz'],
                ['application/vnd.kde.karbon', 'karbon'],
                ['application/vnd.kde.kchart', 'chrt'],
                ['application/vnd.kde.kformula', 'kfo'],
                ['application/vnd.kde.kivio', 'flw'],
                ['application/vnd.kde.kontour', 'kon'],
                ['application/vnd.kde.kpresenter', 'kpr'],
                ['application/vnd.kde.kspread', 'ksp'],
                ['application/vnd.kde.kword', 'kwd'],
                ['application/vnd.kenameaapp', 'htke'],
                ['application/vnd.kidspiration', 'kia'],
                ['application/vnd.kinar', 'kne'],
                ['application/vnd.koan', 'skp'],
                ['application/vnd.kodak-descriptor', 'sse'],
                ['application/vnd.las.las+xml', 'lasxml'],
                ['application/vnd.llamagraphics.life-balance.desktop', 'lbd'],
                ['application/vnd.llamagraphics.life-balance.exchange+xml', 'lbe'],
                ['application/vnd.lotus-1-2-3', '123'],
                ['application/vnd.lotus-approach', 'apr'],
                ['application/vnd.lotus-freelance', 'pre'],
                ['application/vnd.lotus-notes', 'nsf'],
                ['application/vnd.lotus-organizer', 'org'],
                ['application/vnd.lotus-screencam', 'scm'],
                ['application/vnd.lotus-wordpro', 'lwp'],
                ['application/vnd.macports.portpkg', 'portpkg'],
                ['application/vnd.mcd', 'mcd'],
                ['application/vnd.medcalcdata', 'mc1'],
                ['application/vnd.mediastation.cdkey', 'cdkey'],
                ['application/vnd.mfer', 'mwf'],
                ['application/vnd.mfmp', 'mfm'],
                ['application/vnd.micrografx.flo', 'flo'],
                ['application/vnd.micrografx.igx', 'igx'],
                ['application/vnd.mif', 'mif'],
                ['application/vnd.mobius.daf', 'daf'],
                ['application/vnd.mobius.dis', 'dis'],
                ['application/vnd.mobius.mbk', 'mbk'],
                ['application/vnd.mobius.mqy', 'mqy'],
                ['application/vnd.mobius.msl', 'msl'],
                ['application/vnd.mobius.plc', 'plc'],
                ['application/vnd.mobius.txf', 'txf'],
                ['application/vnd.mophun.application', 'mpn'],
                ['application/vnd.mophun.certificate', 'mpc'],
                ['application/vnd.mozilla.xul+xml', 'xul'],
                ['application/vnd.ms-artgalry', 'cil'],
                ['application/vnd.ms-cab-compressed', 'cab'],
                ['application/vnd.ms-excel', ['xls', 'xla', 'xlc', 'xlm', 'xlt', 'xlw', 'xlb', 'xll']],
                ['application/vnd.ms-excel.addin.macroenabled.12', 'xlam'],
                ['application/vnd.ms-excel.sheet.binary.macroenabled.12', 'xlsb'],
                ['application/vnd.ms-excel.sheet.macroenabled.12', 'xlsm'],
                ['application/vnd.ms-excel.template.macroenabled.12', 'xltm'],
                ['application/vnd.ms-fontobject', 'eot'],
                ['application/vnd.ms-htmlhelp', 'chm'],
                ['application/vnd.ms-ims', 'ims'],
                ['application/vnd.ms-lrm', 'lrm'],
                ['application/vnd.ms-officetheme', 'thmx'],
                ['application/vnd.ms-outlook', 'msg'],
                ['application/vnd.ms-pki.certstore', 'sst'],
                ['application/vnd.ms-pki.pko', 'pko'],
                ['application/vnd.ms-pki.seccat', 'cat'],
                ['application/vnd.ms-pki.stl', 'stl'],
                ['application/vnd.ms-pkicertstore', 'sst'],
                ['application/vnd.ms-pkiseccat', 'cat'],
                ['application/vnd.ms-pkistl', 'stl'],
                ['application/vnd.ms-powerpoint', ['ppt', 'pot', 'pps', 'ppa', 'pwz']],
                ['application/vnd.ms-powerpoint.addin.macroenabled.12', 'ppam'],
                ['application/vnd.ms-powerpoint.presentation.macroenabled.12', 'pptm'],
                ['application/vnd.ms-powerpoint.slide.macroenabled.12', 'sldm'],
                ['application/vnd.ms-powerpoint.slideshow.macroenabled.12', 'ppsm'],
                ['application/vnd.ms-powerpoint.template.macroenabled.12', 'potm'],
                ['application/vnd.ms-project', 'mpp'],
                ['application/vnd.ms-word.document.macroenabled.12', 'docm'],
                ['application/vnd.ms-word.template.macroenabled.12', 'dotm'],
                ['application/vnd.ms-works', ['wks', 'wcm', 'wdb', 'wps']],
                ['application/vnd.ms-wpl', 'wpl'],
                ['application/vnd.ms-xpsdocument', 'xps'],
                ['application/vnd.mseq', 'mseq'],
                ['application/vnd.musician', 'mus'],
                ['application/vnd.muvee.style', 'msty'],
                ['application/vnd.neurolanguage.nlu', 'nlu'],
                ['application/vnd.noblenet-directory', 'nnd'],
                ['application/vnd.noblenet-sealer', 'nns'],
                ['application/vnd.noblenet-web', 'nnw'],
                ['application/vnd.nokia.configuration-message', 'ncm'],
                ['application/vnd.nokia.n-gage.data', 'ngdat'],
                ['application/vnd.nokia.n-gage.symbian.install', 'n-gage'],
                ['application/vnd.nokia.radio-preset', 'rpst'],
                ['application/vnd.nokia.radio-presets', 'rpss'],
                ['application/vnd.nokia.ringing-tone', 'rng'],
                ['application/vnd.novadigm.edm', 'edm'],
                ['application/vnd.novadigm.edx', 'edx'],
                ['application/vnd.novadigm.ext', 'ext'],
                ['application/vnd.oasis.opendocument.chart', 'odc'],
                ['application/vnd.oasis.opendocument.chart-template', 'otc'],
                ['application/vnd.oasis.opendocument.database', 'odb'],
                ['application/vnd.oasis.opendocument.formula', 'odf'],
                ['application/vnd.oasis.opendocument.formula-template', 'odft'],
                ['application/vnd.oasis.opendocument.graphics', 'odg'],
                ['application/vnd.oasis.opendocument.graphics-template', 'otg'],
                ['application/vnd.oasis.opendocument.image', 'odi'],
                ['application/vnd.oasis.opendocument.image-template', 'oti'],
                ['application/vnd.oasis.opendocument.presentation', 'odp'],
                ['application/vnd.oasis.opendocument.presentation-template', 'otp'],
                ['application/vnd.oasis.opendocument.spreadsheet', 'ods'],
                ['application/vnd.oasis.opendocument.spreadsheet-template', 'ots'],
                ['application/vnd.oasis.opendocument.text', 'odt'],
                ['application/vnd.oasis.opendocument.text-master', 'odm'],
                ['application/vnd.oasis.opendocument.text-template', 'ott'],
                ['application/vnd.oasis.opendocument.text-web', 'oth'],
                ['application/vnd.olpc-sugar', 'xo'],
                ['application/vnd.oma.dd2+xml', 'dd2'],
                ['application/vnd.openofficeorg.extension', 'oxt'],
                ['application/vnd.openxmlformats-officedocument.presentationml.presentation', 'pptx'],
                ['application/vnd.openxmlformats-officedocument.presentationml.slide', 'sldx'],
                ['application/vnd.openxmlformats-officedocument.presentationml.slideshow', 'ppsx'],
                ['application/vnd.openxmlformats-officedocument.presentationml.template', 'potx'],
                ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'xlsx'],
                ['application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'xltx'],
                ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'docx'],
                ['application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'dotx'],
                ['application/vnd.osgeo.mapguide.package', 'mgp'],
                ['application/vnd.osgi.dp', 'dp'],
                ['application/vnd.palm', 'pdb'],
                ['application/vnd.pawaafile', 'paw'],
                ['application/vnd.pg.format', 'str'],
                ['application/vnd.pg.osasli', 'ei6'],
                ['application/vnd.picsel', 'efif'],
                ['application/vnd.pmi.widget', 'wg'],
                ['application/vnd.pocketlearn', 'plf'],
                ['application/vnd.powerbuilder6', 'pbd'],
                ['application/vnd.previewsystems.box', 'box'],
                ['application/vnd.proteus.magazine', 'mgz'],
                ['application/vnd.publishare-delta-tree', 'qps'],
                ['application/vnd.pvi.ptid1', 'ptid'],
                ['application/vnd.quark.quarkxpress', 'qxd'],
                ['application/vnd.realvnc.bed', 'bed'],
                ['application/vnd.recordare.musicxml', 'mxl'],
                ['application/vnd.recordare.musicxml+xml', 'musicxml'],
                ['application/vnd.rig.cryptonote', 'cryptonote'],
                ['application/vnd.rim.cod', 'cod'],
                ['application/vnd.rn-realmedia', 'rm'],
                ['application/vnd.rn-realplayer', 'rnx'],
                ['application/vnd.route66.link66+xml', 'link66'],
                ['application/vnd.sailingtracker.track', 'st'],
                ['application/vnd.seemail', 'see'],
                ['application/vnd.sema', 'sema'],
                ['application/vnd.semd', 'semd'],
                ['application/vnd.semf', 'semf'],
                ['application/vnd.shana.informed.formdata', 'ifm'],
                ['application/vnd.shana.informed.formtemplate', 'itp'],
                ['application/vnd.shana.informed.interchange', 'iif'],
                ['application/vnd.shana.informed.package', 'ipk'],
                ['application/vnd.simtech-mindmapper', 'twd'],
                ['application/vnd.smaf', 'mmf'],
                ['application/vnd.smart.teacher', 'teacher'],
                ['application/vnd.solent.sdkm+xml', 'sdkm'],
                ['application/vnd.spotfire.dxp', 'dxp'],
                ['application/vnd.spotfire.sfs', 'sfs'],
                ['application/vnd.stardivision.calc', 'sdc'],
                ['application/vnd.stardivision.draw', 'sda'],
                ['application/vnd.stardivision.impress', 'sdd'],
                ['application/vnd.stardivision.math', 'smf'],
                ['application/vnd.stardivision.writer', 'sdw'],
                ['application/vnd.stardivision.writer-global', 'sgl'],
                ['application/vnd.stepmania.stepchart', 'sm'],
                ['application/vnd.sun.xml.calc', 'sxc'],
                ['application/vnd.sun.xml.calc.template', 'stc'],
                ['application/vnd.sun.xml.draw', 'sxd'],
                ['application/vnd.sun.xml.draw.template', 'std'],
                ['application/vnd.sun.xml.impress', 'sxi'],
                ['application/vnd.sun.xml.impress.template', 'sti'],
                ['application/vnd.sun.xml.math', 'sxm'],
                ['application/vnd.sun.xml.writer', 'sxw'],
                ['application/vnd.sun.xml.writer.global', 'sxg'],
                ['application/vnd.sun.xml.writer.template', 'stw'],
                ['application/vnd.sus-calendar', 'sus'],
                ['application/vnd.svd', 'svd'],
                ['application/vnd.symbian.install', 'sis'],
                ['application/vnd.syncml+xml', 'xsm'],
                ['application/vnd.syncml.dm+wbxml', 'bdm'],
                ['application/vnd.syncml.dm+xml', 'xdm'],
                ['application/vnd.tao.intent-module-archive', 'tao'],
                ['application/vnd.tmobile-livetv', 'tmo'],
                ['application/vnd.trid.tpt', 'tpt'],
                ['application/vnd.triscape.mxs', 'mxs'],
                ['application/vnd.trueapp', 'tra'],
                ['application/vnd.ufdl', 'ufd'],
                ['application/vnd.uiq.theme', 'utz'],
                ['application/vnd.umajin', 'umj'],
                ['application/vnd.unity', 'unityweb'],
                ['application/vnd.uoml+xml', 'uoml'],
                ['application/vnd.vcx', 'vcx'],
                ['application/vnd.visio', 'vsd'],
                ['application/vnd.visionary', 'vis'],
                ['application/vnd.vsf', 'vsf'],
                ['application/vnd.wap.wbxml', 'wbxml'],
                ['application/vnd.wap.wmlc', 'wmlc'],
                ['application/vnd.wap.wmlscriptc', 'wmlsc'],
                ['application/vnd.webturbo', 'wtb'],
                ['application/vnd.wolfram.player', 'nbp'],
                ['application/vnd.wordperfect', 'wpd'],
                ['application/vnd.wqd', 'wqd'],
                ['application/vnd.wt.stf', 'stf'],
                ['application/vnd.xara', ['web', 'xar']],
                ['application/vnd.xfdl', 'xfdl'],
                ['application/vnd.yamaha.hv-dic', 'hvd'],
                ['application/vnd.yamaha.hv-script', 'hvs'],
                ['application/vnd.yamaha.hv-voice', 'hvp'],
                ['application/vnd.yamaha.openscoreformat', 'osf'],
                ['application/vnd.yamaha.openscoreformat.osfpvg+xml', 'osfpvg'],
                ['application/vnd.yamaha.smaf-audio', 'saf'],
                ['application/vnd.yamaha.smaf-phrase', 'spf'],
                ['application/vnd.yellowriver-custom-menu', 'cmp'],
                ['application/vnd.zul', 'zir'],
                ['application/vnd.zzazz.deck+xml', 'zaz'],
                ['application/vocaltec-media-desc', 'vmd'],
                ['application/vocaltec-media-file', 'vmf'],
                ['application/voicexml+xml', 'vxml'],
                ['application/widget', 'wgt'],
                ['application/winhlp', 'hlp'],
                ['application/wordperfect', ['wp', 'wp5', 'wp6', 'wpd']],
                ['application/wordperfect6.0', ['w60', 'wp5']],
                ['application/wordperfect6.1', 'w61'],
                ['application/wsdl+xml', 'wsdl'],
                ['application/wspolicy+xml', 'wspolicy'],
                ['application/x-123', 'wk1'],
                ['application/x-7z-compressed', '7z'],
                ['application/x-abiword', 'abw'],
                ['application/x-ace-compressed', 'ace'],
                ['application/x-aim', 'aim'],
                ['application/x-authorware-bin', 'aab'],
                ['application/x-authorware-map', 'aam'],
                ['application/x-authorware-seg', 'aas'],
                ['application/x-bcpio', 'bcpio'],
                ['application/x-binary', 'bin'],
                ['application/x-binhex40', 'hqx'],
                ['application/x-bittorrent', 'torrent'],
                ['application/x-bsh', ['bsh', 'sh', 'shar']],
                ['application/x-bytecode.elisp', 'elc'],
                ['applicaiton/x-bytecode.python', 'pyc'],
                ['application/x-bzip', 'bz'],
                ['application/x-bzip2', ['boz', 'bz2']],
                ['application/x-cdf', 'cdf'],
                ['application/x-cdlink', 'vcd'],
                ['application/x-chat', ['cha', 'chat']],
                ['application/x-chess-pgn', 'pgn'],
                ['application/x-cmu-raster', 'ras'],
                ['application/x-cocoa', 'cco'],
                ['application/x-compactpro', 'cpt'],
                ['application/x-compress', 'z'],
                ['application/x-compressed', ['tgz', 'gz', 'z', 'zip']],
                ['application/x-conference', 'nsc'],
                ['application/x-cpio', 'cpio'],
                ['application/x-cpt', 'cpt'],
                ['application/x-csh', 'csh'],
                ['application/x-debian-package', 'deb'],
                ['application/x-deepv', 'deepv'],
                ['application/x-director', ['dir', 'dcr', 'dxr']],
                ['application/x-doom', 'wad'],
                ['application/x-dtbncx+xml', 'ncx'],
                ['application/x-dtbook+xml', 'dtb'],
                ['application/x-dtbresource+xml', 'res'],
                ['application/x-dvi', 'dvi'],
                ['application/x-elc', 'elc'],
                ['application/x-envoy', ['env', 'evy']],
                ['application/x-esrehber', 'es'],
                ['application/x-excel', ['xls', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],
                ['application/x-font-bdf', 'bdf'],
                ['application/x-font-ghostscript', 'gsf'],
                ['application/x-font-linux-psf', 'psf'],
                ['application/x-font-otf', 'otf'],
                ['application/x-font-pcf', 'pcf'],
                ['application/x-font-snf', 'snf'],
                ['application/x-font-ttf', 'ttf'],
                ['application/x-font-type1', 'pfa'],
                ['application/x-font-woff', 'woff'],
                ['application/x-frame', 'mif'],
                ['application/x-freelance', 'pre'],
                ['application/x-futuresplash', 'spl'],
                ['application/x-gnumeric', 'gnumeric'],
                ['application/x-gsp', 'gsp'],
                ['application/x-gss', 'gss'],
                ['application/x-gtar', 'gtar'],
                ['application/x-gzip', ['gz', 'gzip']],
                ['application/x-hdf', 'hdf'],
                ['application/x-helpfile', ['help', 'hlp']],
                ['application/x-httpd-imap', 'imap'],
                ['application/x-ima', 'ima'],
                ['application/x-internet-signup', ['ins', 'isp']],
                ['application/x-internett-signup', 'ins'],
                ['application/x-inventor', 'iv'],
                ['application/x-ip2', 'ip'],
                ['application/x-iphone', 'iii'],
                ['application/x-java-class', 'class'],
                ['application/x-java-commerce', 'jcm'],
                ['application/x-java-jnlp-file', 'jnlp'],
                ['application/x-javascript', 'js'],
                ['application/x-koan', ['skd', 'skm', 'skp', 'skt']],
                ['application/x-ksh', 'ksh'],
                ['application/x-latex', ['latex', 'ltx']],
                ['application/x-lha', 'lha'],
                ['application/x-lisp', 'lsp'],
                ['application/x-livescreen', 'ivy'],
                ['application/x-lotus', 'wq1'],
                ['application/x-lotusscreencam', 'scm'],
                ['application/x-lzh', 'lzh'],
                ['application/x-lzx', 'lzx'],
                ['application/x-mac-binhex40', 'hqx'],
                ['application/x-macbinary', 'bin'],
                ['application/x-magic-cap-package-1.0', 'mc$'],
                ['application/x-mathcad', 'mcd'],
                ['application/x-meme', 'mm'],
                ['application/x-midi', ['mid', 'midi']],
                ['application/x-mif', 'mif'],
                ['application/x-mix-transfer', 'nix'],
                ['application/x-mobipocket-ebook', 'prc'],
                ['application/x-mplayer2', 'asx'],
                ['application/x-ms-application', 'application'],
                ['application/x-ms-wmd', 'wmd'],
                ['application/x-ms-wmz', 'wmz'],
                ['application/x-ms-xbap', 'xbap'],
                ['application/x-msaccess', 'mdb'],
                ['application/x-msbinder', 'obd'],
                ['application/x-mscardfile', 'crd'],
                ['application/x-msclip', 'clp'],
                ['application/x-msdownload', ['exe', 'dll']],
                ['application/x-msexcel', ['xls', 'xla', 'xlw']],
                ['application/x-msmediaview', ['mvb', 'm13', 'm14']],
                ['application/x-msmetafile', 'wmf'],
                ['application/x-msmoney', 'mny'],
                ['application/x-mspowerpoint', 'ppt'],
                ['application/x-mspublisher', 'pub'],
                ['application/x-msschedule', 'scd'],
                ['application/x-msterminal', 'trm'],
                ['application/x-mswrite', 'wri'],
                ['application/x-navi-animation', 'ani'],
                ['application/x-navidoc', 'nvd'],
                ['application/x-navimap', 'map'],
                ['application/x-navistyle', 'stl'],
                ['application/x-netcdf', ['cdf', 'nc']],
                ['application/x-newton-compatible-pkg', 'pkg'],
                ['application/x-nokia-9000-communicator-add-on-software', 'aos'],
                ['application/x-omc', 'omc'],
                ['application/x-omcdatamaker', 'omcd'],
                ['application/x-omcregerator', 'omcr'],
                ['application/x-pagemaker', ['pm4', 'pm5']],
                ['application/x-pcl', 'pcl'],
                ['application/x-perfmon', ['pma', 'pmc', 'pml', 'pmr', 'pmw']],
                ['application/x-pixclscript', 'plx'],
                ['application/x-pkcs10', 'p10'],
                ['application/x-pkcs12', ['p12', 'pfx']],
                ['application/x-pkcs7-certificates', ['p7b', 'spc']],
                ['application/x-pkcs7-certreqresp', 'p7r'],
                ['application/x-pkcs7-mime', ['p7m', 'p7c']],
                ['application/x-pkcs7-signature', ['p7s', 'p7a']],
                ['application/x-pointplus', 'css'],
                ['application/x-portable-anymap', 'pnm'],
                ['application/x-project', ['mpc', 'mpt', 'mpv', 'mpx']],
                ['application/x-qpro', 'wb1'],
                ['application/x-rar-compressed', 'rar'],
                ['application/x-rtf', 'rtf'],
                ['application/x-sdp', 'sdp'],
                ['application/x-sea', 'sea'],
                ['application/x-seelogo', 'sl'],
                ['application/x-sh', 'sh'],
                ['application/x-shar', ['shar', 'sh']],
                ['application/x-shockwave-flash', 'swf'],
                ['application/x-silverlight-app', 'xap'],
                ['application/x-sit', 'sit'],
                ['application/x-sprite', ['spr', 'sprite']],
                ['application/x-stuffit', 'sit'],
                ['application/x-stuffitx', 'sitx'],
                ['application/x-sv4cpio', 'sv4cpio'],
                ['application/x-sv4crc', 'sv4crc'],
                ['application/x-tar', 'tar'],
                ['application/x-tbook', ['sbk', 'tbk']],
                ['application/x-tcl', 'tcl'],
                ['application/x-tex', 'tex'],
                ['application/x-tex-tfm', 'tfm'],
                ['application/x-texinfo', ['texi', 'texinfo']],
                ['application/x-troff', ['roff', 't', 'tr']],
                ['application/x-troff-man', 'man'],
                ['application/x-troff-me', 'me'],
                ['application/x-troff-ms', 'ms'],
                ['application/x-troff-msvideo', 'avi'],
                ['application/x-ustar', 'ustar'],
                ['application/x-visio', ['vsd', 'vst', 'vsw']],
                ['application/x-vnd.audioexplosion.mzz', 'mzz'],
                ['application/x-vnd.ls-xpix', 'xpix'],
                ['application/x-vrml', 'vrml'],
                ['application/x-wais-source', ['src', 'wsrc']],
                ['application/x-winhelp', 'hlp'],
                ['application/x-wintalk', 'wtk'],
                ['application/x-world', ['wrl', 'svr']],
                ['application/x-wpwin', 'wpd'],
                ['application/x-wri', 'wri'],
                ['application/x-x509-ca-cert', ['cer', 'crt', 'der']],
                ['application/x-x509-user-cert', 'crt'],
                ['application/x-xfig', 'fig'],
                ['application/x-xpinstall', 'xpi'],
                ['application/x-zip-compressed', 'zip'],
                ['application/xcap-diff+xml', 'xdf'],
                ['application/xenc+xml', 'xenc'],
                ['application/xhtml+xml', 'xhtml'],
                ['application/xml', 'xml'],
                ['application/xml-dtd', 'dtd'],
                ['application/xop+xml', 'xop'],
                ['application/xslt+xml', 'xslt'],
                ['application/xspf+xml', 'xspf'],
                ['application/xv+xml', 'mxml'],
                ['application/yang', 'yang'],
                ['application/yin+xml', 'yin'],
                ['application/ynd.ms-pkipko', 'pko'],
                ['application/zip', 'zip'],
                ['audio/adpcm', 'adp'],
                ['audio/aiff', ['aiff', 'aif', 'aifc']],
                ['audio/basic', ['snd', 'au']],
                ['audio/it', 'it'],
                ['audio/make', ['funk', 'my', 'pfunk']],
                ['audio/make.my.funk', 'pfunk'],
                ['audio/mid', ['mid', 'rmi']],
                ['audio/midi', ['midi', 'kar', 'mid']],
                ['audio/mod', 'mod'],
                ['audio/mp4', 'mp4a'],
                ['audio/mpeg', ['mpga', 'mp3', 'm2a', 'mp2', 'mpa', 'mpg']],
                ['audio/mpeg3', 'mp3'],
                ['audio/nspaudio', ['la', 'lma']],
                ['audio/ogg', 'oga'],
                ['audio/s3m', 's3m'],
                ['audio/tsp-audio', 'tsi'],
                ['audio/tsplayer', 'tsp'],
                ['audio/vnd.dece.audio', 'uva'],
                ['audio/vnd.digital-winds', 'eol'],
                ['audio/vnd.dra', 'dra'],
                ['audio/vnd.dts', 'dts'],
                ['audio/vnd.dts.hd', 'dtshd'],
                ['audio/vnd.lucent.voice', 'lvp'],
                ['audio/vnd.ms-playready.media.pya', 'pya'],
                ['audio/vnd.nuera.ecelp4800', 'ecelp4800'],
                ['audio/vnd.nuera.ecelp7470', 'ecelp7470'],
                ['audio/vnd.nuera.ecelp9600', 'ecelp9600'],
                ['audio/vnd.qcelp', 'qcp'],
                ['audio/vnd.rip', 'rip'],
                ['audio/voc', 'voc'],
                ['audio/voxware', 'vox'],
                ['audio/wav', 'wav'],
                ['audio/webm', 'weba'],
                ['audio/x-aac', 'aac'],
                ['audio/x-adpcm', 'snd'],
                ['audio/x-aiff', ['aiff', 'aif', 'aifc']],
                ['audio/x-au', 'au'],
                ['audio/x-gsm', ['gsd', 'gsm']],
                ['audio/x-jam', 'jam'],
                ['audio/x-liveaudio', 'lam'],
                ['audio/x-mid', ['mid', 'midi']],
                ['audio/x-midi', ['midi', 'mid']],
                ['audio/x-mod', 'mod'],
                ['audio/x-mpeg', 'mp2'],
                ['audio/x-mpeg-3', 'mp3'],
                ['audio/x-mpegurl', 'm3u'],
                ['audio/x-mpequrl', 'm3u'],
                ['audio/x-ms-wax', 'wax'],
                ['audio/x-ms-wma', 'wma'],
                ['audio/x-nspaudio', ['la', 'lma']],
                ['audio/x-pn-realaudio', ['ra', 'ram', 'rm', 'rmm', 'rmp']],
                ['audio/x-pn-realaudio-plugin', ['ra', 'rmp', 'rpm']],
                ['audio/x-psid', 'sid'],
                ['audio/x-realaudio', 'ra'],
                ['audio/x-twinvq', 'vqf'],
                ['audio/x-twinvq-plugin', ['vqe', 'vql']],
                ['audio/x-vnd.audioexplosion.mjuicemediafile', 'mjf'],
                ['audio/x-voc', 'voc'],
                ['audio/x-wav', 'wav'],
                ['audio/xm', 'xm'],
                ['chemical/x-cdx', 'cdx'],
                ['chemical/x-cif', 'cif'],
                ['chemical/x-cmdf', 'cmdf'],
                ['chemical/x-cml', 'cml'],
                ['chemical/x-csml', 'csml'],
                ['chemical/x-pdb', ['pdb', 'xyz']],
                ['chemical/x-xyz', 'xyz'],
                ['drawing/x-dwf', 'dwf'],
                ['i-world/i-vrml', 'ivr'],
                ['image/bmp', ['bmp', 'bm']],
                ['image/cgm', 'cgm'],
                ['image/cis-cod', 'cod'],
                ['image/cmu-raster', ['ras', 'rast']],
                ['image/fif', 'fif'],
                ['image/florian', ['flo', 'turbot']],
                ['image/g3fax', 'g3'],
                ['image/gif', 'gif'],
                ['image/ief', ['ief', 'iefs']],
                ['image/jpeg', ['jpeg', 'jpe', 'jpg', 'jfif', 'jfif-tbnl']],
                ['image/jutvision', 'jut'],
                ['image/ktx', 'ktx'],
                ['image/naplps', ['nap', 'naplps']],
                ['image/pict', ['pic', 'pict']],
                ['image/pipeg', 'jfif'],
                ['image/pjpeg', ['jfif', 'jpe', 'jpeg', 'jpg']],
                ['image/png', ['png', 'x-png']],
                ['image/prs.btif', 'btif'],
                ['image/svg+xml', 'svg'],
                ['image/tiff', ['tif', 'tiff']],
                ['image/vasa', 'mcf'],
                ['image/vnd.adobe.photoshop', 'psd'],
                ['image/vnd.dece.graphic', 'uvi'],
                ['image/vnd.djvu', 'djvu'],
                ['image/vnd.dvb.subtitle', 'sub'],
                ['image/vnd.dwg', ['dwg', 'dxf', 'svf']],
                ['image/vnd.dxf', 'dxf'],
                ['image/vnd.fastbidsheet', 'fbs'],
                ['image/vnd.fpx', 'fpx'],
                ['image/vnd.fst', 'fst'],
                ['image/vnd.fujixerox.edmics-mmr', 'mmr'],
                ['image/vnd.fujixerox.edmics-rlc', 'rlc'],
                ['image/vnd.ms-modi', 'mdi'],
                ['image/vnd.net-fpx', ['fpx', 'npx']],
                ['image/vnd.rn-realflash', 'rf'],
                ['image/vnd.rn-realpix', 'rp'],
                ['image/vnd.wap.wbmp', 'wbmp'],
                ['image/vnd.xiff', 'xif'],
                ['image/webp', 'webp'],
                ['image/x-cmu-raster', 'ras'],
                ['image/x-cmx', 'cmx'],
                ['image/x-dwg', ['dwg', 'dxf', 'svf']],
                ['image/x-freehand', 'fh'],
                ['image/x-icon', 'ico'],
                ['image/x-jg', 'art'],
                ['image/x-jps', 'jps'],
                ['image/x-niff', ['niff', 'nif']],
                ['image/x-pcx', 'pcx'],
                ['image/x-pict', ['pct', 'pic']],
                ['image/x-portable-anymap', 'pnm'],
                ['image/x-portable-bitmap', 'pbm'],
                ['image/x-portable-graymap', 'pgm'],
                ['image/x-portable-greymap', 'pgm'],
                ['image/x-portable-pixmap', 'ppm'],
                ['image/x-quicktime', ['qif', 'qti', 'qtif']],
                ['image/x-rgb', 'rgb'],
                ['image/x-tiff', ['tif', 'tiff']],
                ['image/x-windows-bmp', 'bmp'],
                ['image/x-xbitmap', 'xbm'],
                ['image/x-xbm', 'xbm'],
                ['image/x-xpixmap', ['xpm', 'pm']],
                ['image/x-xwd', 'xwd'],
                ['image/x-xwindowdump', 'xwd'],
                ['image/xbm', 'xbm'],
                ['image/xpm', 'xpm'],
                ['message/rfc822', ['eml', 'mht', 'mhtml', 'nws', 'mime']],
                ['model/iges', ['iges', 'igs']],
                ['model/mesh', 'msh'],
                ['model/vnd.collada+xml', 'dae'],
                ['model/vnd.dwf', 'dwf'],
                ['model/vnd.gdl', 'gdl'],
                ['model/vnd.gtw', 'gtw'],
                ['model/vnd.mts', 'mts'],
                ['model/vnd.vtu', 'vtu'],
                ['model/vrml', ['vrml', 'wrl', 'wrz']],
                ['model/x-pov', 'pov'],
                ['multipart/x-gzip', 'gzip'],
                ['multipart/x-ustar', 'ustar'],
                ['multipart/x-zip', 'zip'],
                ['music/crescendo', ['mid', 'midi']],
                ['music/x-karaoke', 'kar'],
                ['paleovu/x-pv', 'pvu'],
                ['text/asp', 'asp'],
                ['text/calendar', 'ics'],
                ['text/css', 'css'],
                ['text/csv', 'csv'],
                ['text/ecmascript', 'js'],
                ['text/h323', '323'],
                ['text/html', ['html', 'htm', 'stm', 'acgi', 'htmls', 'htx', 'shtml']],
                ['text/iuls', 'uls'],
                ['text/javascript', 'js'],
                ['text/mcf', 'mcf'],
                ['text/n3', 'n3'],
                ['text/pascal', 'pas'],
                [
                    'text/plain',
                    [
                        'txt',
                        'bas',
                        'c',
                        'h',
                        'c++',
                        'cc',
                        'com',
                        'conf',
                        'cxx',
                        'def',
                        'f',
                        'f90',
                        'for',
                        'g',
                        'hh',
                        'idc',
                        'jav',
                        'java',
                        'list',
                        'log',
                        'lst',
                        'm',
                        'mar',
                        'pl',
                        'sdml',
                        'text'
                    ]
                ],
                ['text/plain-bas', 'par'],
                ['text/prs.lines.tag', 'dsc'],
                ['text/richtext', ['rtx', 'rt', 'rtf']],
                ['text/scriplet', 'wsc'],
                ['text/scriptlet', 'sct'],
                ['text/sgml', ['sgm', 'sgml']],
                ['text/tab-separated-values', 'tsv'],
                ['text/troff', 't'],
                ['text/turtle', 'ttl'],
                ['text/uri-list', ['uni', 'unis', 'uri', 'uris']],
                ['text/vnd.abc', 'abc'],
                ['text/vnd.curl', 'curl'],
                ['text/vnd.curl.dcurl', 'dcurl'],
                ['text/vnd.curl.mcurl', 'mcurl'],
                ['text/vnd.curl.scurl', 'scurl'],
                ['text/vnd.fly', 'fly'],
                ['text/vnd.fmi.flexstor', 'flx'],
                ['text/vnd.graphviz', 'gv'],
                ['text/vnd.in3d.3dml', '3dml'],
                ['text/vnd.in3d.spot', 'spot'],
                ['text/vnd.rn-realtext', 'rt'],
                ['text/vnd.sun.j2me.app-descriptor', 'jad'],
                ['text/vnd.wap.wml', 'wml'],
                ['text/vnd.wap.wmlscript', 'wmls'],
                ['text/webviewhtml', 'htt'],
                ['text/x-asm', ['asm', 's']],
                ['text/x-audiosoft-intra', 'aip'],
                ['text/x-c', ['c', 'cc', 'cpp']],
                ['text/x-component', 'htc'],
                ['text/x-fortran', ['for', 'f', 'f77', 'f90']],
                ['text/x-h', ['h', 'hh']],
                ['text/x-java-source', ['java', 'jav']],
                ['text/x-java-source,java', 'java'],
                ['text/x-la-asf', 'lsx'],
                ['text/x-m', 'm'],
                ['text/x-pascal', 'p'],
                ['text/x-script', 'hlb'],
                ['text/x-script.csh', 'csh'],
                ['text/x-script.elisp', 'el'],
                ['text/x-script.guile', 'scm'],
                ['text/x-script.ksh', 'ksh'],
                ['text/x-script.lisp', 'lsp'],
                ['text/x-script.perl', 'pl'],
                ['text/x-script.perl-module', 'pm'],
                ['text/x-script.phyton', 'py'],
                ['text/x-script.rexx', 'rexx'],
                ['text/x-script.scheme', 'scm'],
                ['text/x-script.sh', 'sh'],
                ['text/x-script.tcl', 'tcl'],
                ['text/x-script.tcsh', 'tcsh'],
                ['text/x-script.zsh', 'zsh'],
                ['text/x-server-parsed-html', ['shtml', 'ssi']],
                ['text/x-setext', 'etx'],
                ['text/x-sgml', ['sgm', 'sgml']],
                ['text/x-speech', ['spc', 'talk']],
                ['text/x-uil', 'uil'],
                ['text/x-uuencode', ['uu', 'uue']],
                ['text/x-vcalendar', 'vcs'],
                ['text/x-vcard', 'vcf'],
                ['text/xml', 'xml'],
                ['video/3gpp', '3gp'],
                ['video/3gpp2', '3g2'],
                ['video/animaflex', 'afl'],
                ['video/avi', 'avi'],
                ['video/avs-video', 'avs'],
                ['video/dl', 'dl'],
                ['video/fli', 'fli'],
                ['video/gl', 'gl'],
                ['video/h261', 'h261'],
                ['video/h263', 'h263'],
                ['video/h264', 'h264'],
                ['video/jpeg', 'jpgv'],
                ['video/jpm', 'jpm'],
                ['video/mj2', 'mj2'],
                ['video/mp4', 'mp4'],
                ['video/mpeg', ['mpeg', 'mp2', 'mpa', 'mpe', 'mpg', 'mpv2', 'm1v', 'm2v', 'mp3']],
                ['video/msvideo', 'avi'],
                ['video/ogg', 'ogv'],
                ['video/quicktime', ['mov', 'qt', 'moov']],
                ['video/vdo', 'vdo'],
                ['video/vivo', ['viv', 'vivo']],
                ['video/vnd.dece.hd', 'uvh'],
                ['video/vnd.dece.mobile', 'uvm'],
                ['video/vnd.dece.pd', 'uvp'],
                ['video/vnd.dece.sd', 'uvs'],
                ['video/vnd.dece.video', 'uvv'],
                ['video/vnd.fvt', 'fvt'],
                ['video/vnd.mpegurl', 'mxu'],
                ['video/vnd.ms-playready.media.pyv', 'pyv'],
                ['video/vnd.rn-realvideo', 'rv'],
                ['video/vnd.uvvu.mp4', 'uvu'],
                ['video/vnd.vivo', ['viv', 'vivo']],
                ['video/vosaic', 'vos'],
                ['video/webm', 'webm'],
                ['video/x-amt-demorun', 'xdr'],
                ['video/x-amt-showrun', 'xsr'],
                ['video/x-atomic3d-feature', 'fmf'],
                ['video/x-dl', 'dl'],
                ['video/x-dv', ['dif', 'dv']],
                ['video/x-f4v', 'f4v'],
                ['video/x-fli', 'fli'],
                ['video/x-flv', 'flv'],
                ['video/x-gl', 'gl'],
                ['video/x-isvideo', 'isu'],
                ['video/x-la-asf', ['lsf', 'lsx']],
                ['video/x-m4v', 'm4v'],
                ['video/x-motion-jpeg', 'mjpg'],
                ['video/x-mpeg', ['mp3', 'mp2']],
                ['video/x-mpeq2a', 'mp2'],
                ['video/x-ms-asf', ['asf', 'asr', 'asx']],
                ['video/x-ms-asf-plugin', 'asx'],
                ['video/x-ms-wm', 'wm'],
                ['video/x-ms-wmv', 'wmv'],
                ['video/x-ms-wmx', 'wmx'],
                ['video/x-ms-wvx', 'wvx'],
                ['video/x-msvideo', 'avi'],
                ['video/x-qtc', 'qtc'],
                ['video/x-scm', 'scm'],
                ['video/x-sgi-movie', ['movie', 'mv']],
                ['windows/metafile', 'wmf'],
                ['www/mime', 'mime'],
                ['x-conference/x-cooltalk', 'ice'],
                ['x-music/x-midi', ['mid', 'midi']],
                ['x-world/x-3dmf', ['3dm', '3dmf', 'qd3', 'qd3d']],
                ['x-world/x-svr', 'svr'],
                ['x-world/x-vrml', ['flr', 'vrml', 'wrl', 'wrz', 'xaf', 'xof']],
                ['x-world/x-vrt', 'vrt'],
                ['xgl/drawing', 'xgz'],
                ['xgl/movie', 'xmz']
            ]);
            const extensions = new Map([
                ['123', 'application/vnd.lotus-1-2-3'],
                ['323', 'text/h323'],
                ['*', 'application/octet-stream'],
                ['3dm', 'x-world/x-3dmf'],
                ['3dmf', 'x-world/x-3dmf'],
                ['3dml', 'text/vnd.in3d.3dml'],
                ['3g2', 'video/3gpp2'],
                ['3gp', 'video/3gpp'],
                ['7z', 'application/x-7z-compressed'],
                ['a', 'application/octet-stream'],
                ['aab', 'application/x-authorware-bin'],
                ['aac', 'audio/x-aac'],
                ['aam', 'application/x-authorware-map'],
                ['aas', 'application/x-authorware-seg'],
                ['abc', 'text/vnd.abc'],
                ['abw', 'application/x-abiword'],
                ['ac', 'application/pkix-attr-cert'],
                ['acc', 'application/vnd.americandynamics.acc'],
                ['ace', 'application/x-ace-compressed'],
                ['acgi', 'text/html'],
                ['acu', 'application/vnd.acucobol'],
                ['acx', 'application/internet-property-stream'],
                ['adp', 'audio/adpcm'],
                ['aep', 'application/vnd.audiograph'],
                ['afl', 'video/animaflex'],
                ['afp', 'application/vnd.ibm.modcap'],
                ['ahead', 'application/vnd.ahead.space'],
                ['ai', 'application/postscript'],
                ['aif', ['audio/aiff', 'audio/x-aiff']],
                ['aifc', ['audio/aiff', 'audio/x-aiff']],
                ['aiff', ['audio/aiff', 'audio/x-aiff']],
                ['aim', 'application/x-aim'],
                ['aip', 'text/x-audiosoft-intra'],
                ['air', 'application/vnd.adobe.air-application-installer-package+zip'],
                ['ait', 'application/vnd.dvb.ait'],
                ['ami', 'application/vnd.amiga.ami'],
                ['ani', 'application/x-navi-animation'],
                ['aos', 'application/x-nokia-9000-communicator-add-on-software'],
                ['apk', 'application/vnd.android.package-archive'],
                ['application', 'application/x-ms-application'],
                ['apr', 'application/vnd.lotus-approach'],
                ['aps', 'application/mime'],
                ['arc', 'application/octet-stream'],
                ['arj', ['application/arj', 'application/octet-stream']],
                ['art', 'image/x-jg'],
                ['asf', 'video/x-ms-asf'],
                ['asm', 'text/x-asm'],
                ['aso', 'application/vnd.accpac.simply.aso'],
                ['asp', 'text/asp'],
                ['asr', 'video/x-ms-asf'],
                ['asx', ['video/x-ms-asf', 'application/x-mplayer2', 'video/x-ms-asf-plugin']],
                ['atc', 'application/vnd.acucorp'],
                ['atomcat', 'application/atomcat+xml'],
                ['atomsvc', 'application/atomsvc+xml'],
                ['atx', 'application/vnd.antix.game-component'],
                ['au', ['audio/basic', 'audio/x-au']],
                ['avi', ['video/avi', 'video/msvideo', 'application/x-troff-msvideo', 'video/x-msvideo']],
                ['avs', 'video/avs-video'],
                ['aw', 'application/applixware'],
                ['axs', 'application/olescript'],
                ['azf', 'application/vnd.airzip.filesecure.azf'],
                ['azs', 'application/vnd.airzip.filesecure.azs'],
                ['azw', 'application/vnd.amazon.ebook'],
                ['bas', 'text/plain'],
                ['bcpio', 'application/x-bcpio'],
                ['bdf', 'application/x-font-bdf'],
                ['bdm', 'application/vnd.syncml.dm+wbxml'],
                ['bed', 'application/vnd.realvnc.bed'],
                ['bh2', 'application/vnd.fujitsu.oasysprs'],
                ['bin', ['application/octet-stream', 'application/mac-binary', 'application/macbinary', 'application/x-macbinary', 'application/x-binary']],
                ['bm', 'image/bmp'],
                ['bmi', 'application/vnd.bmi'],
                ['bmp', ['image/bmp', 'image/x-windows-bmp']],
                ['boo', 'application/book'],
                ['book', 'application/book'],
                ['box', 'application/vnd.previewsystems.box'],
                ['boz', 'application/x-bzip2'],
                ['bsh', 'application/x-bsh'],
                ['btif', 'image/prs.btif'],
                ['bz', 'application/x-bzip'],
                ['bz2', 'application/x-bzip2'],
                ['c', ['text/plain', 'text/x-c']],
                ['c++', 'text/plain'],
                ['c11amc', 'application/vnd.cluetrust.cartomobile-config'],
                ['c11amz', 'application/vnd.cluetrust.cartomobile-config-pkg'],
                ['c4g', 'application/vnd.clonk.c4group'],
                ['cab', 'application/vnd.ms-cab-compressed'],
                ['car', 'application/vnd.curl.car'],
                ['cat', ['application/vnd.ms-pkiseccat', 'application/vnd.ms-pki.seccat']],
                ['cc', ['text/plain', 'text/x-c']],
                ['ccad', 'application/clariscad'],
                ['cco', 'application/x-cocoa'],
                ['ccxml', 'application/ccxml+xml,'],
                ['cdbcmsg', 'application/vnd.contact.cmsg'],
                ['cdf', ['application/cdf', 'application/x-cdf', 'application/x-netcdf']],
                ['cdkey', 'application/vnd.mediastation.cdkey'],
                ['cdmia', 'application/cdmi-capability'],
                ['cdmic', 'application/cdmi-container'],
                ['cdmid', 'application/cdmi-domain'],
                ['cdmio', 'application/cdmi-object'],
                ['cdmiq', 'application/cdmi-queue'],
                ['cdx', 'chemical/x-cdx'],
                ['cdxml', 'application/vnd.chemdraw+xml'],
                ['cdy', 'application/vnd.cinderella'],
                ['cer', ['application/pkix-cert', 'application/x-x509-ca-cert']],
                ['cgm', 'image/cgm'],
                ['cha', 'application/x-chat'],
                ['chat', 'application/x-chat'],
                ['chm', 'application/vnd.ms-htmlhelp'],
                ['chrt', 'application/vnd.kde.kchart'],
                ['cif', 'chemical/x-cif'],
                ['cii', 'application/vnd.anser-web-certificate-issue-initiation'],
                ['cil', 'application/vnd.ms-artgalry'],
                ['cla', 'application/vnd.claymore'],
                ['class', ['application/octet-stream', 'application/java', 'application/java-byte-code', 'application/java-vm', 'application/x-java-class']],
                ['clkk', 'application/vnd.crick.clicker.keyboard'],
                ['clkp', 'application/vnd.crick.clicker.palette'],
                ['clkt', 'application/vnd.crick.clicker.template'],
                ['clkw', 'application/vnd.crick.clicker.wordbank'],
                ['clkx', 'application/vnd.crick.clicker'],
                ['clp', 'application/x-msclip'],
                ['cmc', 'application/vnd.cosmocaller'],
                ['cmdf', 'chemical/x-cmdf'],
                ['cml', 'chemical/x-cml'],
                ['cmp', 'application/vnd.yellowriver-custom-menu'],
                ['cmx', 'image/x-cmx'],
                ['cod', ['image/cis-cod', 'application/vnd.rim.cod']],
                ['com', ['application/octet-stream', 'text/plain']],
                ['conf', 'text/plain'],
                ['cpio', 'application/x-cpio'],
                ['cpp', 'text/x-c'],
                ['cpt', ['application/mac-compactpro', 'application/x-compactpro', 'application/x-cpt']],
                ['crd', 'application/x-mscardfile'],
                ['crl', ['application/pkix-crl', 'application/pkcs-crl']],
                ['crt', ['application/pkix-cert', 'application/x-x509-user-cert', 'application/x-x509-ca-cert']],
                ['cryptonote', 'application/vnd.rig.cryptonote'],
                ['csh', ['text/x-script.csh', 'application/x-csh']],
                ['csml', 'chemical/x-csml'],
                ['csp', 'application/vnd.commonspace'],
                ['css', ['text/css', 'application/x-pointplus']],
                ['csv', 'text/csv'],
                ['cu', 'application/cu-seeme'],
                ['curl', 'text/vnd.curl'],
                ['cww', 'application/prs.cww'],
                ['cxx', 'text/plain'],
                ['dae', 'model/vnd.collada+xml'],
                ['daf', 'application/vnd.mobius.daf'],
                ['davmount', 'application/davmount+xml'],
                ['dcr', 'application/x-director'],
                ['dcurl', 'text/vnd.curl.dcurl'],
                ['dd2', 'application/vnd.oma.dd2+xml'],
                ['ddd', 'application/vnd.fujixerox.ddd'],
                ['deb', 'application/x-debian-package'],
                ['deepv', 'application/x-deepv'],
                ['def', 'text/plain'],
                ['der', 'application/x-x509-ca-cert'],
                ['dfac', 'application/vnd.dreamfactory'],
                ['dif', 'video/x-dv'],
                ['dir', 'application/x-director'],
                ['dis', 'application/vnd.mobius.dis'],
                ['djvu', 'image/vnd.djvu'],
                ['dl', ['video/dl', 'video/x-dl']],
                ['dll', 'application/x-msdownload'],
                ['dms', 'application/octet-stream'],
                ['dna', 'application/vnd.dna'],
                ['doc', 'application/msword'],
                ['docm', 'application/vnd.ms-word.document.macroenabled.12'],
                ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
                ['dot', 'application/msword'],
                ['dotm', 'application/vnd.ms-word.template.macroenabled.12'],
                ['dotx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template'],
                ['dp', ['application/commonground', 'application/vnd.osgi.dp']],
                ['dpg', 'application/vnd.dpgraph'],
                ['dra', 'audio/vnd.dra'],
                ['drw', 'application/drafting'],
                ['dsc', 'text/prs.lines.tag'],
                ['dssc', 'application/dssc+der'],
                ['dtb', 'application/x-dtbook+xml'],
                ['dtd', 'application/xml-dtd'],
                ['dts', 'audio/vnd.dts'],
                ['dtshd', 'audio/vnd.dts.hd'],
                ['dump', 'application/octet-stream'],
                ['dv', 'video/x-dv'],
                ['dvi', 'application/x-dvi'],
                ['dwf', ['model/vnd.dwf', 'drawing/x-dwf']],
                ['dwg', ['application/acad', 'image/vnd.dwg', 'image/x-dwg']],
                ['dxf', ['application/dxf', 'image/vnd.dwg', 'image/vnd.dxf', 'image/x-dwg']],
                ['dxp', 'application/vnd.spotfire.dxp'],
                ['dxr', 'application/x-director'],
                ['ecelp4800', 'audio/vnd.nuera.ecelp4800'],
                ['ecelp7470', 'audio/vnd.nuera.ecelp7470'],
                ['ecelp9600', 'audio/vnd.nuera.ecelp9600'],
                ['edm', 'application/vnd.novadigm.edm'],
                ['edx', 'application/vnd.novadigm.edx'],
                ['efif', 'application/vnd.picsel'],
                ['ei6', 'application/vnd.pg.osasli'],
                ['el', 'text/x-script.elisp'],
                ['elc', ['application/x-elc', 'application/x-bytecode.elisp']],
                ['eml', 'message/rfc822'],
                ['emma', 'application/emma+xml'],
                ['env', 'application/x-envoy'],
                ['eol', 'audio/vnd.digital-winds'],
                ['eot', 'application/vnd.ms-fontobject'],
                ['eps', 'application/postscript'],
                ['epub', 'application/epub+zip'],
                ['es', ['application/ecmascript', 'application/x-esrehber']],
                ['es3', 'application/vnd.eszigno3+xml'],
                ['esf', 'application/vnd.epson.esf'],
                ['etx', 'text/x-setext'],
                ['evy', ['application/envoy', 'application/x-envoy']],
                ['exe', ['application/octet-stream', 'application/x-msdownload']],
                ['exi', 'application/exi'],
                ['ext', 'application/vnd.novadigm.ext'],
                ['ez2', 'application/vnd.ezpix-album'],
                ['ez3', 'application/vnd.ezpix-package'],
                ['f', ['text/plain', 'text/x-fortran']],
                ['f4v', 'video/x-f4v'],
                ['f77', 'text/x-fortran'],
                ['f90', ['text/plain', 'text/x-fortran']],
                ['fbs', 'image/vnd.fastbidsheet'],
                ['fcs', 'application/vnd.isac.fcs'],
                ['fdf', 'application/vnd.fdf'],
                ['fe_launch', 'application/vnd.denovo.fcselayout-link'],
                ['fg5', 'application/vnd.fujitsu.oasysgp'],
                ['fh', 'image/x-freehand'],
                ['fif', ['application/fractals', 'image/fif']],
                ['fig', 'application/x-xfig'],
                ['fli', ['video/fli', 'video/x-fli']],
                ['flo', ['image/florian', 'application/vnd.micrografx.flo']],
                ['flr', 'x-world/x-vrml'],
                ['flv', 'video/x-flv'],
                ['flw', 'application/vnd.kde.kivio'],
                ['flx', 'text/vnd.fmi.flexstor'],
                ['fly', 'text/vnd.fly'],
                ['fm', 'application/vnd.framemaker'],
                ['fmf', 'video/x-atomic3d-feature'],
                ['fnc', 'application/vnd.frogans.fnc'],
                ['for', ['text/plain', 'text/x-fortran']],
                ['fpx', ['image/vnd.fpx', 'image/vnd.net-fpx']],
                ['frl', 'application/freeloader'],
                ['fsc', 'application/vnd.fsc.weblaunch'],
                ['fst', 'image/vnd.fst'],
                ['ftc', 'application/vnd.fluxtime.clip'],
                ['fti', 'application/vnd.anser-web-funds-transfer-initiation'],
                ['funk', 'audio/make'],
                ['fvt', 'video/vnd.fvt'],
                ['fxp', 'application/vnd.adobe.fxp'],
                ['fzs', 'application/vnd.fuzzysheet'],
                ['g', 'text/plain'],
                ['g2w', 'application/vnd.geoplan'],
                ['g3', 'image/g3fax'],
                ['g3w', 'application/vnd.geospace'],
                ['gac', 'application/vnd.groove-account'],
                ['gdl', 'model/vnd.gdl'],
                ['geo', 'application/vnd.dynageo'],
                ['gex', 'application/vnd.geometry-explorer'],
                ['ggb', 'application/vnd.geogebra.file'],
                ['ggt', 'application/vnd.geogebra.tool'],
                ['ghf', 'application/vnd.groove-help'],
                ['gif', 'image/gif'],
                ['gim', 'application/vnd.groove-identity-message'],
                ['gl', ['video/gl', 'video/x-gl']],
                ['gmx', 'application/vnd.gmx'],
                ['gnumeric', 'application/x-gnumeric'],
                ['gph', 'application/vnd.flographit'],
                ['gqf', 'application/vnd.grafeq'],
                ['gram', 'application/srgs'],
                ['grv', 'application/vnd.groove-injector'],
                ['grxml', 'application/srgs+xml'],
                ['gsd', 'audio/x-gsm'],
                ['gsf', 'application/x-font-ghostscript'],
                ['gsm', 'audio/x-gsm'],
                ['gsp', 'application/x-gsp'],
                ['gss', 'application/x-gss'],
                ['gtar', 'application/x-gtar'],
                ['gtm', 'application/vnd.groove-tool-message'],
                ['gtw', 'model/vnd.gtw'],
                ['gv', 'text/vnd.graphviz'],
                ['gxt', 'application/vnd.geonext'],
                ['gz', ['application/x-gzip', 'application/x-compressed']],
                ['gzip', ['multipart/x-gzip', 'application/x-gzip']],
                ['h', ['text/plain', 'text/x-h']],
                ['h261', 'video/h261'],
                ['h263', 'video/h263'],
                ['h264', 'video/h264'],
                ['hal', 'application/vnd.hal+xml'],
                ['hbci', 'application/vnd.hbci'],
                ['hdf', 'application/x-hdf'],
                ['help', 'application/x-helpfile'],
                ['hgl', 'application/vnd.hp-hpgl'],
                ['hh', ['text/plain', 'text/x-h']],
                ['hlb', 'text/x-script'],
                ['hlp', ['application/winhlp', 'application/hlp', 'application/x-helpfile', 'application/x-winhelp']],
                ['hpg', 'application/vnd.hp-hpgl'],
                ['hpgl', 'application/vnd.hp-hpgl'],
                ['hpid', 'application/vnd.hp-hpid'],
                ['hps', 'application/vnd.hp-hps'],
                [
                    'hqx',
                    [
                        'application/mac-binhex40',
                        'application/binhex',
                        'application/binhex4',
                        'application/mac-binhex',
                        'application/x-binhex40',
                        'application/x-mac-binhex40'
                    ]
                ],
                ['hta', 'application/hta'],
                ['htc', 'text/x-component'],
                ['htke', 'application/vnd.kenameaapp'],
                ['htm', 'text/html'],
                ['html', 'text/html'],
                ['htmls', 'text/html'],
                ['htt', 'text/webviewhtml'],
                ['htx', 'text/html'],
                ['hvd', 'application/vnd.yamaha.hv-dic'],
                ['hvp', 'application/vnd.yamaha.hv-voice'],
                ['hvs', 'application/vnd.yamaha.hv-script'],
                ['i2g', 'application/vnd.intergeo'],
                ['icc', 'application/vnd.iccprofile'],
                ['ice', 'x-conference/x-cooltalk'],
                ['ico', 'image/x-icon'],
                ['ics', 'text/calendar'],
                ['idc', 'text/plain'],
                ['ief', 'image/ief'],
                ['iefs', 'image/ief'],
                ['ifm', 'application/vnd.shana.informed.formdata'],
                ['iges', ['application/iges', 'model/iges']],
                ['igl', 'application/vnd.igloader'],
                ['igm', 'application/vnd.insors.igm'],
                ['igs', ['application/iges', 'model/iges']],
                ['igx', 'application/vnd.micrografx.igx'],
                ['iif', 'application/vnd.shana.informed.interchange'],
                ['iii', 'application/x-iphone'],
                ['ima', 'application/x-ima'],
                ['imap', 'application/x-httpd-imap'],
                ['imp', 'application/vnd.accpac.simply.imp'],
                ['ims', 'application/vnd.ms-ims'],
                ['inf', 'application/inf'],
                ['ins', ['application/x-internet-signup', 'application/x-internett-signup']],
                ['ip', 'application/x-ip2'],
                ['ipfix', 'application/ipfix'],
                ['ipk', 'application/vnd.shana.informed.package'],
                ['irm', 'application/vnd.ibm.rights-management'],
                ['irp', 'application/vnd.irepository.package+xml'],
                ['isp', 'application/x-internet-signup'],
                ['isu', 'video/x-isvideo'],
                ['it', 'audio/it'],
                ['itp', 'application/vnd.shana.informed.formtemplate'],
                ['iv', 'application/x-inventor'],
                ['ivp', 'application/vnd.immervision-ivp'],
                ['ivr', 'i-world/i-vrml'],
                ['ivu', 'application/vnd.immervision-ivu'],
                ['ivy', 'application/x-livescreen'],
                ['jad', 'text/vnd.sun.j2me.app-descriptor'],
                ['jam', ['application/vnd.jam', 'audio/x-jam']],
                ['jar', 'application/java-archive'],
                ['jav', ['text/plain', 'text/x-java-source']],
                ['java', ['text/plain', 'text/x-java-source,java', 'text/x-java-source']],
                ['jcm', 'application/x-java-commerce'],
                ['jfif', ['image/pipeg', 'image/jpeg', 'image/pjpeg']],
                ['jfif-tbnl', 'image/jpeg'],
                ['jisp', 'application/vnd.jisp'],
                ['jlt', 'application/vnd.hp-jlyt'],
                ['jnlp', 'application/x-java-jnlp-file'],
                ['joda', 'application/vnd.joost.joda-archive'],
                ['jpe', ['image/jpeg', 'image/pjpeg']],
                ['jpeg', ['image/jpeg', 'image/pjpeg']],
                ['jpg', ['image/jpeg', 'image/pjpeg']],
                ['jpgv', 'video/jpeg'],
                ['jpm', 'video/jpm'],
                ['jps', 'image/x-jps'],
                ['js', ['application/javascript', 'application/ecmascript', 'text/javascript', 'text/ecmascript', 'application/x-javascript']],
                ['json', 'application/json'],
                ['jut', 'image/jutvision'],
                ['kar', ['audio/midi', 'music/x-karaoke']],
                ['karbon', 'application/vnd.kde.karbon'],
                ['kfo', 'application/vnd.kde.kformula'],
                ['kia', 'application/vnd.kidspiration'],
                ['kml', 'application/vnd.google-earth.kml+xml'],
                ['kmz', 'application/vnd.google-earth.kmz'],
                ['kne', 'application/vnd.kinar'],
                ['kon', 'application/vnd.kde.kontour'],
                ['kpr', 'application/vnd.kde.kpresenter'],
                ['ksh', ['application/x-ksh', 'text/x-script.ksh']],
                ['ksp', 'application/vnd.kde.kspread'],
                ['ktx', 'image/ktx'],
                ['ktz', 'application/vnd.kahootz'],
                ['kwd', 'application/vnd.kde.kword'],
                ['la', ['audio/nspaudio', 'audio/x-nspaudio']],
                ['lam', 'audio/x-liveaudio'],
                ['lasxml', 'application/vnd.las.las+xml'],
                ['latex', 'application/x-latex'],
                ['lbd', 'application/vnd.llamagraphics.life-balance.desktop'],
                ['lbe', 'application/vnd.llamagraphics.life-balance.exchange+xml'],
                ['les', 'application/vnd.hhe.lesson-player'],
                ['lha', ['application/octet-stream', 'application/lha', 'application/x-lha']],
                ['lhx', 'application/octet-stream'],
                ['link66', 'application/vnd.route66.link66+xml'],
                ['list', 'text/plain'],
                ['lma', ['audio/nspaudio', 'audio/x-nspaudio']],
                ['log', 'text/plain'],
                ['lrm', 'application/vnd.ms-lrm'],
                ['lsf', 'video/x-la-asf'],
                ['lsp', ['application/x-lisp', 'text/x-script.lisp']],
                ['lst', 'text/plain'],
                ['lsx', ['video/x-la-asf', 'text/x-la-asf']],
                ['ltf', 'application/vnd.frogans.ltf'],
                ['ltx', 'application/x-latex'],
                ['lvp', 'audio/vnd.lucent.voice'],
                ['lwp', 'application/vnd.lotus-wordpro'],
                ['lzh', ['application/octet-stream', 'application/x-lzh']],
                ['lzx', ['application/lzx', 'application/octet-stream', 'application/x-lzx']],
                ['m', ['text/plain', 'text/x-m']],
                ['m13', 'application/x-msmediaview'],
                ['m14', 'application/x-msmediaview'],
                ['m1v', 'video/mpeg'],
                ['m21', 'application/mp21'],
                ['m2a', 'audio/mpeg'],
                ['m2v', 'video/mpeg'],
                ['m3u', ['audio/x-mpegurl', 'audio/x-mpequrl']],
                ['m3u8', 'application/vnd.apple.mpegurl'],
                ['m4v', 'video/x-m4v'],
                ['ma', 'application/mathematica'],
                ['mads', 'application/mads+xml'],
                ['mag', 'application/vnd.ecowin.chart'],
                ['man', 'application/x-troff-man'],
                ['map', 'application/x-navimap'],
                ['mar', 'text/plain'],
                ['mathml', 'application/mathml+xml'],
                ['mbd', 'application/mbedlet'],
                ['mbk', 'application/vnd.mobius.mbk'],
                ['mbox', 'application/mbox'],
                ['mc$', 'application/x-magic-cap-package-1.0'],
                ['mc1', 'application/vnd.medcalcdata'],
                ['mcd', ['application/mcad', 'application/vnd.mcd', 'application/x-mathcad']],
                ['mcf', ['image/vasa', 'text/mcf']],
                ['mcp', 'application/netmc'],
                ['mcurl', 'text/vnd.curl.mcurl'],
                ['mdb', 'application/x-msaccess'],
                ['mdi', 'image/vnd.ms-modi'],
                ['me', 'application/x-troff-me'],
                ['meta4', 'application/metalink4+xml'],
                ['mets', 'application/mets+xml'],
                ['mfm', 'application/vnd.mfmp'],
                ['mgp', 'application/vnd.osgeo.mapguide.package'],
                ['mgz', 'application/vnd.proteus.magazine'],
                ['mht', 'message/rfc822'],
                ['mhtml', 'message/rfc822'],
                ['mid', ['audio/mid', 'audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],
                ['midi', ['audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],
                ['mif', ['application/vnd.mif', 'application/x-mif', 'application/x-frame']],
                ['mime', ['message/rfc822', 'www/mime']],
                ['mj2', 'video/mj2'],
                ['mjf', 'audio/x-vnd.audioexplosion.mjuicemediafile'],
                ['mjpg', 'video/x-motion-jpeg'],
                ['mlp', 'application/vnd.dolby.mlp'],
                ['mm', ['application/base64', 'application/x-meme']],
                ['mmd', 'application/vnd.chipnuts.karaoke-mmd'],
                ['mme', 'application/base64'],
                ['mmf', 'application/vnd.smaf'],
                ['mmr', 'image/vnd.fujixerox.edmics-mmr'],
                ['mny', 'application/x-msmoney'],
                ['mod', ['audio/mod', 'audio/x-mod']],
                ['mods', 'application/mods+xml'],
                ['moov', 'video/quicktime'],
                ['mov', 'video/quicktime'],
                ['movie', 'video/x-sgi-movie'],
                ['mp2', ['video/mpeg', 'audio/mpeg', 'video/x-mpeg', 'audio/x-mpeg', 'video/x-mpeq2a']],
                ['mp3', ['audio/mpeg', 'audio/mpeg3', 'video/mpeg', 'audio/x-mpeg-3', 'video/x-mpeg']],
                ['mp4', ['video/mp4', 'application/mp4']],
                ['mp4a', 'audio/mp4'],
                ['mpa', ['video/mpeg', 'audio/mpeg']],
                ['mpc', ['application/vnd.mophun.certificate', 'application/x-project']],
                ['mpe', 'video/mpeg'],
                ['mpeg', 'video/mpeg'],
                ['mpg', ['video/mpeg', 'audio/mpeg']],
                ['mpga', 'audio/mpeg'],
                ['mpkg', 'application/vnd.apple.installer+xml'],
                ['mpm', 'application/vnd.blueice.multipass'],
                ['mpn', 'application/vnd.mophun.application'],
                ['mpp', 'application/vnd.ms-project'],
                ['mpt', 'application/x-project'],
                ['mpv', 'application/x-project'],
                ['mpv2', 'video/mpeg'],
                ['mpx', 'application/x-project'],
                ['mpy', 'application/vnd.ibm.minipay'],
                ['mqy', 'application/vnd.mobius.mqy'],
                ['mrc', 'application/marc'],
                ['mrcx', 'application/marcxml+xml'],
                ['ms', 'application/x-troff-ms'],
                ['mscml', 'application/mediaservercontrol+xml'],
                ['mseq', 'application/vnd.mseq'],
                ['msf', 'application/vnd.epson.msf'],
                ['msg', 'application/vnd.ms-outlook'],
                ['msh', 'model/mesh'],
                ['msl', 'application/vnd.mobius.msl'],
                ['msty', 'application/vnd.muvee.style'],
                ['mts', 'model/vnd.mts'],
                ['mus', 'application/vnd.musician'],
                ['musicxml', 'application/vnd.recordare.musicxml+xml'],
                ['mv', 'video/x-sgi-movie'],
                ['mvb', 'application/x-msmediaview'],
                ['mwf', 'application/vnd.mfer'],
                ['mxf', 'application/mxf'],
                ['mxl', 'application/vnd.recordare.musicxml'],
                ['mxml', 'application/xv+xml'],
                ['mxs', 'application/vnd.triscape.mxs'],
                ['mxu', 'video/vnd.mpegurl'],
                ['my', 'audio/make'],
                ['mzz', 'application/x-vnd.audioexplosion.mzz'],
                ['n-gage', 'application/vnd.nokia.n-gage.symbian.install'],
                ['n3', 'text/n3'],
                ['nap', 'image/naplps'],
                ['naplps', 'image/naplps'],
                ['nbp', 'application/vnd.wolfram.player'],
                ['nc', 'application/x-netcdf'],
                ['ncm', 'application/vnd.nokia.configuration-message'],
                ['ncx', 'application/x-dtbncx+xml'],
                ['ngdat', 'application/vnd.nokia.n-gage.data'],
                ['nif', 'image/x-niff'],
                ['niff', 'image/x-niff'],
                ['nix', 'application/x-mix-transfer'],
                ['nlu', 'application/vnd.neurolanguage.nlu'],
                ['nml', 'application/vnd.enliven'],
                ['nnd', 'application/vnd.noblenet-directory'],
                ['nns', 'application/vnd.noblenet-sealer'],
                ['nnw', 'application/vnd.noblenet-web'],
                ['npx', 'image/vnd.net-fpx'],
                ['nsc', 'application/x-conference'],
                ['nsf', 'application/vnd.lotus-notes'],
                ['nvd', 'application/x-navidoc'],
                ['nws', 'message/rfc822'],
                ['o', 'application/octet-stream'],
                ['oa2', 'application/vnd.fujitsu.oasys2'],
                ['oa3', 'application/vnd.fujitsu.oasys3'],
                ['oas', 'application/vnd.fujitsu.oasys'],
                ['obd', 'application/x-msbinder'],
                ['oda', 'application/oda'],
                ['odb', 'application/vnd.oasis.opendocument.database'],
                ['odc', 'application/vnd.oasis.opendocument.chart'],
                ['odf', 'application/vnd.oasis.opendocument.formula'],
                ['odft', 'application/vnd.oasis.opendocument.formula-template'],
                ['odg', 'application/vnd.oasis.opendocument.graphics'],
                ['odi', 'application/vnd.oasis.opendocument.image'],
                ['odm', 'application/vnd.oasis.opendocument.text-master'],
                ['odp', 'application/vnd.oasis.opendocument.presentation'],
                ['ods', 'application/vnd.oasis.opendocument.spreadsheet'],
                ['odt', 'application/vnd.oasis.opendocument.text'],
                ['oga', 'audio/ogg'],
                ['ogv', 'video/ogg'],
                ['ogx', 'application/ogg'],
                ['omc', 'application/x-omc'],
                ['omcd', 'application/x-omcdatamaker'],
                ['omcr', 'application/x-omcregerator'],
                ['onetoc', 'application/onenote'],
                ['opf', 'application/oebps-package+xml'],
                ['org', 'application/vnd.lotus-organizer'],
                ['osf', 'application/vnd.yamaha.openscoreformat'],
                ['osfpvg', 'application/vnd.yamaha.openscoreformat.osfpvg+xml'],
                ['otc', 'application/vnd.oasis.opendocument.chart-template'],
                ['otf', 'application/x-font-otf'],
                ['otg', 'application/vnd.oasis.opendocument.graphics-template'],
                ['oth', 'application/vnd.oasis.opendocument.text-web'],
                ['oti', 'application/vnd.oasis.opendocument.image-template'],
                ['otp', 'application/vnd.oasis.opendocument.presentation-template'],
                ['ots', 'application/vnd.oasis.opendocument.spreadsheet-template'],
                ['ott', 'application/vnd.oasis.opendocument.text-template'],
                ['oxt', 'application/vnd.openofficeorg.extension'],
                ['p', 'text/x-pascal'],
                ['p10', ['application/pkcs10', 'application/x-pkcs10']],
                ['p12', ['application/pkcs-12', 'application/x-pkcs12']],
                ['p7a', 'application/x-pkcs7-signature'],
                ['p7b', 'application/x-pkcs7-certificates'],
                ['p7c', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],
                ['p7m', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],
                ['p7r', 'application/x-pkcs7-certreqresp'],
                ['p7s', ['application/pkcs7-signature', 'application/x-pkcs7-signature']],
                ['p8', 'application/pkcs8'],
                ['par', 'text/plain-bas'],
                ['part', 'application/pro_eng'],
                ['pas', 'text/pascal'],
                ['paw', 'application/vnd.pawaafile'],
                ['pbd', 'application/vnd.powerbuilder6'],
                ['pbm', 'image/x-portable-bitmap'],
                ['pcf', 'application/x-font-pcf'],
                ['pcl', ['application/vnd.hp-pcl', 'application/x-pcl']],
                ['pclxl', 'application/vnd.hp-pclxl'],
                ['pct', 'image/x-pict'],
                ['pcurl', 'application/vnd.curl.pcurl'],
                ['pcx', 'image/x-pcx'],
                ['pdb', ['application/vnd.palm', 'chemical/x-pdb']],
                ['pdf', 'application/pdf'],
                ['pfa', 'application/x-font-type1'],
                ['pfr', 'application/font-tdpfr'],
                ['pfunk', ['audio/make', 'audio/make.my.funk']],
                ['pfx', 'application/x-pkcs12'],
                ['pgm', ['image/x-portable-graymap', 'image/x-portable-greymap']],
                ['pgn', 'application/x-chess-pgn'],
                ['pgp', 'application/pgp-signature'],
                ['pic', ['image/pict', 'image/x-pict']],
                ['pict', 'image/pict'],
                ['pkg', 'application/x-newton-compatible-pkg'],
                ['pki', 'application/pkixcmp'],
                ['pkipath', 'application/pkix-pkipath'],
                ['pko', ['application/ynd.ms-pkipko', 'application/vnd.ms-pki.pko']],
                ['pl', ['text/plain', 'text/x-script.perl']],
                ['plb', 'application/vnd.3gpp.pic-bw-large'],
                ['plc', 'application/vnd.mobius.plc'],
                ['plf', 'application/vnd.pocketlearn'],
                ['pls', 'application/pls+xml'],
                ['plx', 'application/x-pixclscript'],
                ['pm', ['text/x-script.perl-module', 'image/x-xpixmap']],
                ['pm4', 'application/x-pagemaker'],
                ['pm5', 'application/x-pagemaker'],
                ['pma', 'application/x-perfmon'],
                ['pmc', 'application/x-perfmon'],
                ['pml', ['application/vnd.ctc-posml', 'application/x-perfmon']],
                ['pmr', 'application/x-perfmon'],
                ['pmw', 'application/x-perfmon'],
                ['png', 'image/png'],
                ['pnm', ['application/x-portable-anymap', 'image/x-portable-anymap']],
                ['portpkg', 'application/vnd.macports.portpkg'],
                ['pot', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],
                ['potm', 'application/vnd.ms-powerpoint.template.macroenabled.12'],
                ['potx', 'application/vnd.openxmlformats-officedocument.presentationml.template'],
                ['pov', 'model/x-pov'],
                ['ppa', 'application/vnd.ms-powerpoint'],
                ['ppam', 'application/vnd.ms-powerpoint.addin.macroenabled.12'],
                ['ppd', 'application/vnd.cups-ppd'],
                ['ppm', 'image/x-portable-pixmap'],
                ['pps', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],
                ['ppsm', 'application/vnd.ms-powerpoint.slideshow.macroenabled.12'],
                ['ppsx', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow'],
                ['ppt', ['application/vnd.ms-powerpoint', 'application/mspowerpoint', 'application/powerpoint', 'application/x-mspowerpoint']],
                ['pptm', 'application/vnd.ms-powerpoint.presentation.macroenabled.12'],
                ['pptx', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'],
                ['ppz', 'application/mspowerpoint'],
                ['prc', 'application/x-mobipocket-ebook'],
                ['pre', ['application/vnd.lotus-freelance', 'application/x-freelance']],
                ['prf', 'application/pics-rules'],
                ['prt', 'application/pro_eng'],
                ['ps', 'application/postscript'],
                ['psb', 'application/vnd.3gpp.pic-bw-small'],
                ['psd', ['application/octet-stream', 'image/vnd.adobe.photoshop']],
                ['psf', 'application/x-font-linux-psf'],
                ['pskcxml', 'application/pskc+xml'],
                ['ptid', 'application/vnd.pvi.ptid1'],
                ['pub', 'application/x-mspublisher'],
                ['pvb', 'application/vnd.3gpp.pic-bw-var'],
                ['pvu', 'paleovu/x-pv'],
                ['pwn', 'application/vnd.3m.post-it-notes'],
                ['pwz', 'application/vnd.ms-powerpoint'],
                ['py', 'text/x-script.phyton'],
                ['pya', 'audio/vnd.ms-playready.media.pya'],
                ['pyc', 'applicaiton/x-bytecode.python'],
                ['pyv', 'video/vnd.ms-playready.media.pyv'],
                ['qam', 'application/vnd.epson.quickanime'],
                ['qbo', 'application/vnd.intu.qbo'],
                ['qcp', 'audio/vnd.qcelp'],
                ['qd3', 'x-world/x-3dmf'],
                ['qd3d', 'x-world/x-3dmf'],
                ['qfx', 'application/vnd.intu.qfx'],
                ['qif', 'image/x-quicktime'],
                ['qps', 'application/vnd.publishare-delta-tree'],
                ['qt', 'video/quicktime'],
                ['qtc', 'video/x-qtc'],
                ['qti', 'image/x-quicktime'],
                ['qtif', 'image/x-quicktime'],
                ['qxd', 'application/vnd.quark.quarkxpress'],
                ['ra', ['audio/x-realaudio', 'audio/x-pn-realaudio', 'audio/x-pn-realaudio-plugin']],
                ['ram', 'audio/x-pn-realaudio'],
                ['rar', 'application/x-rar-compressed'],
                ['ras', ['image/cmu-raster', 'application/x-cmu-raster', 'image/x-cmu-raster']],
                ['rast', 'image/cmu-raster'],
                ['rcprofile', 'application/vnd.ipunplugged.rcprofile'],
                ['rdf', 'application/rdf+xml'],
                ['rdz', 'application/vnd.data-vision.rdz'],
                ['rep', 'application/vnd.businessobjects'],
                ['res', 'application/x-dtbresource+xml'],
                ['rexx', 'text/x-script.rexx'],
                ['rf', 'image/vnd.rn-realflash'],
                ['rgb', 'image/x-rgb'],
                ['rif', 'application/reginfo+xml'],
                ['rip', 'audio/vnd.rip'],
                ['rl', 'application/resource-lists+xml'],
                ['rlc', 'image/vnd.fujixerox.edmics-rlc'],
                ['rld', 'application/resource-lists-diff+xml'],
                ['rm', ['application/vnd.rn-realmedia', 'audio/x-pn-realaudio']],
                ['rmi', 'audio/mid'],
                ['rmm', 'audio/x-pn-realaudio'],
                ['rmp', ['audio/x-pn-realaudio-plugin', 'audio/x-pn-realaudio']],
                ['rms', 'application/vnd.jcp.javame.midlet-rms'],
                ['rnc', 'application/relax-ng-compact-syntax'],
                ['rng', ['application/ringing-tones', 'application/vnd.nokia.ringing-tone']],
                ['rnx', 'application/vnd.rn-realplayer'],
                ['roff', 'application/x-troff'],
                ['rp', 'image/vnd.rn-realpix'],
                ['rp9', 'application/vnd.cloanto.rp9'],
                ['rpm', 'audio/x-pn-realaudio-plugin'],
                ['rpss', 'application/vnd.nokia.radio-presets'],
                ['rpst', 'application/vnd.nokia.radio-preset'],
                ['rq', 'application/sparql-query'],
                ['rs', 'application/rls-services+xml'],
                ['rsd', 'application/rsd+xml'],
                ['rt', ['text/richtext', 'text/vnd.rn-realtext']],
                ['rtf', ['application/rtf', 'text/richtext', 'application/x-rtf']],
                ['rtx', ['text/richtext', 'application/rtf']],
                ['rv', 'video/vnd.rn-realvideo'],
                ['s', 'text/x-asm'],
                ['s3m', 'audio/s3m'],
                ['saf', 'application/vnd.yamaha.smaf-audio'],
                ['saveme', 'application/octet-stream'],
                ['sbk', 'application/x-tbook'],
                ['sbml', 'application/sbml+xml'],
                ['sc', 'application/vnd.ibm.secure-container'],
                ['scd', 'application/x-msschedule'],
                ['scm', ['application/vnd.lotus-screencam', 'video/x-scm', 'text/x-script.guile', 'application/x-lotusscreencam', 'text/x-script.scheme']],
                ['scq', 'application/scvp-cv-request'],
                ['scs', 'application/scvp-cv-response'],
                ['sct', 'text/scriptlet'],
                ['scurl', 'text/vnd.curl.scurl'],
                ['sda', 'application/vnd.stardivision.draw'],
                ['sdc', 'application/vnd.stardivision.calc'],
                ['sdd', 'application/vnd.stardivision.impress'],
                ['sdkm', 'application/vnd.solent.sdkm+xml'],
                ['sdml', 'text/plain'],
                ['sdp', ['application/sdp', 'application/x-sdp']],
                ['sdr', 'application/sounder'],
                ['sdw', 'application/vnd.stardivision.writer'],
                ['sea', ['application/sea', 'application/x-sea']],
                ['see', 'application/vnd.seemail'],
                ['seed', 'application/vnd.fdsn.seed'],
                ['sema', 'application/vnd.sema'],
                ['semd', 'application/vnd.semd'],
                ['semf', 'application/vnd.semf'],
                ['ser', 'application/java-serialized-object'],
                ['set', 'application/set'],
                ['setpay', 'application/set-payment-initiation'],
                ['setreg', 'application/set-registration-initiation'],
                ['sfd-hdstx', 'application/vnd.hydrostatix.sof-data'],
                ['sfs', 'application/vnd.spotfire.sfs'],
                ['sgl', 'application/vnd.stardivision.writer-global'],
                ['sgm', ['text/sgml', 'text/x-sgml']],
                ['sgml', ['text/sgml', 'text/x-sgml']],
                ['sh', ['application/x-shar', 'application/x-bsh', 'application/x-sh', 'text/x-script.sh']],
                ['shar', ['application/x-bsh', 'application/x-shar']],
                ['shf', 'application/shf+xml'],
                ['shtml', ['text/html', 'text/x-server-parsed-html']],
                ['sid', 'audio/x-psid'],
                ['sis', 'application/vnd.symbian.install'],
                ['sit', ['application/x-stuffit', 'application/x-sit']],
                ['sitx', 'application/x-stuffitx'],
                ['skd', 'application/x-koan'],
                ['skm', 'application/x-koan'],
                ['skp', ['application/vnd.koan', 'application/x-koan']],
                ['skt', 'application/x-koan'],
                ['sl', 'application/x-seelogo'],
                ['sldm', 'application/vnd.ms-powerpoint.slide.macroenabled.12'],
                ['sldx', 'application/vnd.openxmlformats-officedocument.presentationml.slide'],
                ['slt', 'application/vnd.epson.salt'],
                ['sm', 'application/vnd.stepmania.stepchart'],
                ['smf', 'application/vnd.stardivision.math'],
                ['smi', ['application/smil', 'application/smil+xml']],
                ['smil', 'application/smil'],
                ['snd', ['audio/basic', 'audio/x-adpcm']],
                ['snf', 'application/x-font-snf'],
                ['sol', 'application/solids'],
                ['spc', ['text/x-speech', 'application/x-pkcs7-certificates']],
                ['spf', 'application/vnd.yamaha.smaf-phrase'],
                ['spl', ['application/futuresplash', 'application/x-futuresplash']],
                ['spot', 'text/vnd.in3d.spot'],
                ['spp', 'application/scvp-vp-response'],
                ['spq', 'application/scvp-vp-request'],
                ['spr', 'application/x-sprite'],
                ['sprite', 'application/x-sprite'],
                ['src', 'application/x-wais-source'],
                ['sru', 'application/sru+xml'],
                ['srx', 'application/sparql-results+xml'],
                ['sse', 'application/vnd.kodak-descriptor'],
                ['ssf', 'application/vnd.epson.ssf'],
                ['ssi', 'text/x-server-parsed-html'],
                ['ssm', 'application/streamingmedia'],
                ['ssml', 'application/ssml+xml'],
                ['sst', ['application/vnd.ms-pkicertstore', 'application/vnd.ms-pki.certstore']],
                ['st', 'application/vnd.sailingtracker.track'],
                ['stc', 'application/vnd.sun.xml.calc.template'],
                ['std', 'application/vnd.sun.xml.draw.template'],
                ['step', 'application/step'],
                ['stf', 'application/vnd.wt.stf'],
                ['sti', 'application/vnd.sun.xml.impress.template'],
                ['stk', 'application/hyperstudio'],
                ['stl', ['application/vnd.ms-pkistl', 'application/sla', 'application/vnd.ms-pki.stl', 'application/x-navistyle']],
                ['stm', 'text/html'],
                ['stp', 'application/step'],
                ['str', 'application/vnd.pg.format'],
                ['stw', 'application/vnd.sun.xml.writer.template'],
                ['sub', 'image/vnd.dvb.subtitle'],
                ['sus', 'application/vnd.sus-calendar'],
                ['sv4cpio', 'application/x-sv4cpio'],
                ['sv4crc', 'application/x-sv4crc'],
                ['svc', 'application/vnd.dvb.service'],
                ['svd', 'application/vnd.svd'],
                ['svf', ['image/vnd.dwg', 'image/x-dwg']],
                ['svg', 'image/svg+xml'],
                ['svr', ['x-world/x-svr', 'application/x-world']],
                ['swf', 'application/x-shockwave-flash'],
                ['swi', 'application/vnd.aristanetworks.swi'],
                ['sxc', 'application/vnd.sun.xml.calc'],
                ['sxd', 'application/vnd.sun.xml.draw'],
                ['sxg', 'application/vnd.sun.xml.writer.global'],
                ['sxi', 'application/vnd.sun.xml.impress'],
                ['sxm', 'application/vnd.sun.xml.math'],
                ['sxw', 'application/vnd.sun.xml.writer'],
                ['t', ['text/troff', 'application/x-troff']],
                ['talk', 'text/x-speech'],
                ['tao', 'application/vnd.tao.intent-module-archive'],
                ['tar', 'application/x-tar'],
                ['tbk', ['application/toolbook', 'application/x-tbook']],
                ['tcap', 'application/vnd.3gpp2.tcap'],
                ['tcl', ['text/x-script.tcl', 'application/x-tcl']],
                ['tcsh', 'text/x-script.tcsh'],
                ['teacher', 'application/vnd.smart.teacher'],
                ['tei', 'application/tei+xml'],
                ['tex', 'application/x-tex'],
                ['texi', 'application/x-texinfo'],
                ['texinfo', 'application/x-texinfo'],
                ['text', ['application/plain', 'text/plain']],
                ['tfi', 'application/thraud+xml'],
                ['tfm', 'application/x-tex-tfm'],
                ['tgz', ['application/gnutar', 'application/x-compressed']],
                ['thmx', 'application/vnd.ms-officetheme'],
                ['tif', ['image/tiff', 'image/x-tiff']],
                ['tiff', ['image/tiff', 'image/x-tiff']],
                ['tmo', 'application/vnd.tmobile-livetv'],
                ['torrent', 'application/x-bittorrent'],
                ['tpl', 'application/vnd.groove-tool-template'],
                ['tpt', 'application/vnd.trid.tpt'],
                ['tr', 'application/x-troff'],
                ['tra', 'application/vnd.trueapp'],
                ['trm', 'application/x-msterminal'],
                ['tsd', 'application/timestamped-data'],
                ['tsi', 'audio/tsp-audio'],
                ['tsp', ['application/dsptype', 'audio/tsplayer']],
                ['tsv', 'text/tab-separated-values'],
                ['ttf', 'application/x-font-ttf'],
                ['ttl', 'text/turtle'],
                ['turbot', 'image/florian'],
                ['twd', 'application/vnd.simtech-mindmapper'],
                ['txd', 'application/vnd.genomatix.tuxedo'],
                ['txf', 'application/vnd.mobius.txf'],
                ['txt', 'text/plain'],
                ['ufd', 'application/vnd.ufdl'],
                ['uil', 'text/x-uil'],
                ['uls', 'text/iuls'],
                ['umj', 'application/vnd.umajin'],
                ['uni', 'text/uri-list'],
                ['unis', 'text/uri-list'],
                ['unityweb', 'application/vnd.unity'],
                ['unv', 'application/i-deas'],
                ['uoml', 'application/vnd.uoml+xml'],
                ['uri', 'text/uri-list'],
                ['uris', 'text/uri-list'],
                ['ustar', ['application/x-ustar', 'multipart/x-ustar']],
                ['utz', 'application/vnd.uiq.theme'],
                ['uu', ['application/octet-stream', 'text/x-uuencode']],
                ['uue', 'text/x-uuencode'],
                ['uva', 'audio/vnd.dece.audio'],
                ['uvh', 'video/vnd.dece.hd'],
                ['uvi', 'image/vnd.dece.graphic'],
                ['uvm', 'video/vnd.dece.mobile'],
                ['uvp', 'video/vnd.dece.pd'],
                ['uvs', 'video/vnd.dece.sd'],
                ['uvu', 'video/vnd.uvvu.mp4'],
                ['uvv', 'video/vnd.dece.video'],
                ['vcd', 'application/x-cdlink'],
                ['vcf', 'text/x-vcard'],
                ['vcg', 'application/vnd.groove-vcard'],
                ['vcs', 'text/x-vcalendar'],
                ['vcx', 'application/vnd.vcx'],
                ['vda', 'application/vda'],
                ['vdo', 'video/vdo'],
                ['vew', 'application/groupwise'],
                ['vis', 'application/vnd.visionary'],
                ['viv', ['video/vivo', 'video/vnd.vivo']],
                ['vivo', ['video/vivo', 'video/vnd.vivo']],
                ['vmd', 'application/vocaltec-media-desc'],
                ['vmf', 'application/vocaltec-media-file'],
                ['voc', ['audio/voc', 'audio/x-voc']],
                ['vos', 'video/vosaic'],
                ['vox', 'audio/voxware'],
                ['vqe', 'audio/x-twinvq-plugin'],
                ['vqf', 'audio/x-twinvq'],
                ['vql', 'audio/x-twinvq-plugin'],
                ['vrml', ['model/vrml', 'x-world/x-vrml', 'application/x-vrml']],
                ['vrt', 'x-world/x-vrt'],
                ['vsd', ['application/vnd.visio', 'application/x-visio']],
                ['vsf', 'application/vnd.vsf'],
                ['vst', 'application/x-visio'],
                ['vsw', 'application/x-visio'],
                ['vtu', 'model/vnd.vtu'],
                ['vxml', 'application/voicexml+xml'],
                ['w60', 'application/wordperfect6.0'],
                ['w61', 'application/wordperfect6.1'],
                ['w6w', 'application/msword'],
                ['wad', 'application/x-doom'],
                ['wav', ['audio/wav', 'audio/x-wav']],
                ['wax', 'audio/x-ms-wax'],
                ['wb1', 'application/x-qpro'],
                ['wbmp', 'image/vnd.wap.wbmp'],
                ['wbs', 'application/vnd.criticaltools.wbs+xml'],
                ['wbxml', 'application/vnd.wap.wbxml'],
                ['wcm', 'application/vnd.ms-works'],
                ['wdb', 'application/vnd.ms-works'],
                ['web', 'application/vnd.xara'],
                ['weba', 'audio/webm'],
                ['webm', 'video/webm'],
                ['webp', 'image/webp'],
                ['wg', 'application/vnd.pmi.widget'],
                ['wgt', 'application/widget'],
                ['wiz', 'application/msword'],
                ['wk1', 'application/x-123'],
                ['wks', 'application/vnd.ms-works'],
                ['wm', 'video/x-ms-wm'],
                ['wma', 'audio/x-ms-wma'],
                ['wmd', 'application/x-ms-wmd'],
                ['wmf', ['windows/metafile', 'application/x-msmetafile']],
                ['wml', 'text/vnd.wap.wml'],
                ['wmlc', 'application/vnd.wap.wmlc'],
                ['wmls', 'text/vnd.wap.wmlscript'],
                ['wmlsc', 'application/vnd.wap.wmlscriptc'],
                ['wmv', 'video/x-ms-wmv'],
                ['wmx', 'video/x-ms-wmx'],
                ['wmz', 'application/x-ms-wmz'],
                ['woff', 'application/x-font-woff'],
                ['word', 'application/msword'],
                ['wp', 'application/wordperfect'],
                ['wp5', ['application/wordperfect', 'application/wordperfect6.0']],
                ['wp6', 'application/wordperfect'],
                ['wpd', ['application/wordperfect', 'application/vnd.wordperfect', 'application/x-wpwin']],
                ['wpl', 'application/vnd.ms-wpl'],
                ['wps', 'application/vnd.ms-works'],
                ['wq1', 'application/x-lotus'],
                ['wqd', 'application/vnd.wqd'],
                ['wri', ['application/mswrite', 'application/x-wri', 'application/x-mswrite']],
                ['wrl', ['model/vrml', 'x-world/x-vrml', 'application/x-world']],
                ['wrz', ['model/vrml', 'x-world/x-vrml']],
                ['wsc', 'text/scriplet'],
                ['wsdl', 'application/wsdl+xml'],
                ['wspolicy', 'application/wspolicy+xml'],
                ['wsrc', 'application/x-wais-source'],
                ['wtb', 'application/vnd.webturbo'],
                ['wtk', 'application/x-wintalk'],
                ['wvx', 'video/x-ms-wvx'],
                ['x-png', 'image/png'],
                ['x3d', 'application/vnd.hzn-3d-crossword'],
                ['xaf', 'x-world/x-vrml'],
                ['xap', 'application/x-silverlight-app'],
                ['xar', 'application/vnd.xara'],
                ['xbap', 'application/x-ms-xbap'],
                ['xbd', 'application/vnd.fujixerox.docuworks.binder'],
                ['xbm', ['image/xbm', 'image/x-xbm', 'image/x-xbitmap']],
                ['xdf', 'application/xcap-diff+xml'],
                ['xdm', 'application/vnd.syncml.dm+xml'],
                ['xdp', 'application/vnd.adobe.xdp+xml'],
                ['xdr', 'video/x-amt-demorun'],
                ['xdssc', 'application/dssc+xml'],
                ['xdw', 'application/vnd.fujixerox.docuworks'],
                ['xenc', 'application/xenc+xml'],
                ['xer', 'application/patch-ops-error+xml'],
                ['xfdf', 'application/vnd.adobe.xfdf'],
                ['xfdl', 'application/vnd.xfdl'],
                ['xgz', 'xgl/drawing'],
                ['xhtml', 'application/xhtml+xml'],
                ['xif', 'image/vnd.xiff'],
                ['xl', 'application/excel'],
                ['xla', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],
                ['xlam', 'application/vnd.ms-excel.addin.macroenabled.12'],
                ['xlb', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],
                ['xlc', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],
                ['xld', ['application/excel', 'application/x-excel']],
                ['xlk', ['application/excel', 'application/x-excel']],
                ['xll', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],
                ['xlm', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],
                ['xls', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],
                ['xlsb', 'application/vnd.ms-excel.sheet.binary.macroenabled.12'],
                ['xlsm', 'application/vnd.ms-excel.sheet.macroenabled.12'],
                ['xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],
                ['xlt', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],
                ['xltm', 'application/vnd.ms-excel.template.macroenabled.12'],
                ['xltx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template'],
                ['xlv', ['application/excel', 'application/x-excel']],
                ['xlw', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],
                ['xm', 'audio/xm'],
                ['xml', ['application/xml', 'text/xml', 'application/atom+xml', 'application/rss+xml']],
                ['xmz', 'xgl/movie'],
                ['xo', 'application/vnd.olpc-sugar'],
                ['xof', 'x-world/x-vrml'],
                ['xop', 'application/xop+xml'],
                ['xpi', 'application/x-xpinstall'],
                ['xpix', 'application/x-vnd.ls-xpix'],
                ['xpm', ['image/xpm', 'image/x-xpixmap']],
                ['xpr', 'application/vnd.is-xpr'],
                ['xps', 'application/vnd.ms-xpsdocument'],
                ['xpw', 'application/vnd.intercon.formnet'],
                ['xslt', 'application/xslt+xml'],
                ['xsm', 'application/vnd.syncml+xml'],
                ['xspf', 'application/xspf+xml'],
                ['xsr', 'video/x-amt-showrun'],
                ['xul', 'application/vnd.mozilla.xul+xml'],
                ['xwd', ['image/x-xwd', 'image/x-xwindowdump']],
                ['xyz', ['chemical/x-xyz', 'chemical/x-pdb']],
                ['yang', 'application/yang'],
                ['yin', 'application/yin+xml'],
                ['z', ['application/x-compressed', 'application/x-compress']],
                ['zaz', 'application/vnd.zzazz.deck+xml'],
                ['zip', ['application/zip', 'multipart/x-zip', 'application/x-zip-compressed', 'application/x-compressed']],
                ['zir', 'application/vnd.zul'],
                ['zmm', 'application/vnd.handheld-entertainment+xml'],
                ['zoo', 'application/octet-stream'],
                ['zsh', 'text/x-script.zsh']
            ]);

            module.exports = {
                detectMimeType(filename) {
                    if (!filename) {
                        return defaultMimeType;
                    }

                    let parsed = path.parse(filename);
                    let extension = (parsed.ext.substr(1) || parsed.name || '').split('?').shift().trim().toLowerCase();
                    let value = defaultMimeType;

                    if (extensions.has(extension)) {
                        value = extensions.get(extension);
                    }

                    if (Array.isArray(value)) {
                        return value[0];
                    }
                    return value;
                },

                detectExtension(mimeType) {
                    if (!mimeType) {
                        return defaultExtension;
                    }
                    let parts = (mimeType || '').toLowerCase().trim().split('/');
                    let rootType = parts.shift().trim();
                    let subType = parts.join('/').trim();

                    if (mimeTypes.has(rootType + '/' + subType)) {
                        let value = mimeTypes.get(rootType + '/' + subType);
                        if (Array.isArray(value)) {
                            return value[0];
                        }
                        return value;
                    }

                    switch (rootType) {
                        case 'text':
                            return 'txt';
                        default:
                            return 'bin';
                    }
                }
            };


            /***/
        }),
        /* 333 */,
        /* 334 */,
        /* 335 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            exports.URL = __webpack_require__(573).interface;
            exports.serializeURL = __webpack_require__(840).serializeURL;
            exports.serializeURLOrigin = __webpack_require__(840).serializeURLOrigin;
            exports.basicURLParse = __webpack_require__(840).basicURLParse;
            exports.setTheUsername = __webpack_require__(840).setTheUsername;
            exports.setThePassword = __webpack_require__(840).setThePassword;
            exports.serializeHost = __webpack_require__(840).serializeHost;
            exports.serializeInteger = __webpack_require__(840).serializeInteger;
            exports.parseURL = __webpack_require__(840).parseURL;


            /***/
        }),
        /* 336 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.runPolling = void 0;
            const sleep_1 = __webpack_require__(313);
            const waiter_1 = __webpack_require__(532);
            const exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
                if (attempt > attemptCeiling)
                    return maxDelay;
                const delay = minDelay * 2 ** (attempt - 1);
                return randomInRange(minDelay, delay);
            };
            const randomInRange = (min, max) => min + Math.random() * (max - min);
            const runPolling = async ({
                                          minDelay,
                                          maxDelay,
                                          maxWaitTime,
                                          abortController,
                                          client,
                                          abortSignal
                                      }, input, acceptorChecks) => {
                var _a;
                const {state} = await acceptorChecks(client, input);
                if (state !== waiter_1.WaiterState.RETRY) {
                    return {state};
                }
                let currentAttempt = 1;
                const waitUntil = Date.now() + maxWaitTime * 1000;
                const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
                while (true) {
                    if (((_a = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _a === void 0 ? void 0 : _a.aborted) || (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) {
                        return {state: waiter_1.WaiterState.ABORTED};
                    }
                    const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
                    if (Date.now() + delay * 1000 > waitUntil) {
                        return {state: waiter_1.WaiterState.TIMEOUT};
                    }
                    await (0, sleep_1.sleep)(delay);
                    const {state} = await acceptorChecks(client, input);
                    if (state !== waiter_1.WaiterState.RETRY) {
                        return {state};
                    }
                    currentAttempt += 1;
                }
            };
            exports.runPolling = runPolling;


            /***/
        }),
        /* 337 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : {"default": mod};
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var decode_json_1 = __importDefault(__webpack_require__(509));
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
            var fromCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                String.fromCodePoint ||
                function (codePoint) {
                    var output = "";
                    if (codePoint > 0xffff) {
                        codePoint -= 0x10000;
                        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
                        codePoint = 0xdc00 | (codePoint & 0x3ff);
                    }
                    output += String.fromCharCode(codePoint);
                    return output;
                };

            function decodeCodePoint(codePoint) {
                if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
                    return "\uFFFD";
                }
                if (codePoint in decode_json_1.default) {
                    codePoint = decode_json_1.default[codePoint];
                }
                return fromCodePoint(codePoint);
            }

            exports.default = decodeCodePoint;


            /***/
        }),
        /* 338 */,
        /* 339 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            function _interopDefault(ex) {
                return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex;
            }

            var endpoint = __webpack_require__(594);
            var universalUserAgent = __webpack_require__(922);
            var isPlainObject = __webpack_require__(279);
            var nodeFetch = _interopDefault(__webpack_require__(170));
            var requestError = __webpack_require__(160);

            const VERSION = "5.6.3";

            function getBufferResponse(response) {
                return response.arrayBuffer();
            }

            function fetchWrapper(requestOptions) {
                const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;

                if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
                    requestOptions.body = JSON.stringify(requestOptions.body);
                }

                let headers = {};
                let status;
                let url;
                const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;
                return fetch(requestOptions.url, Object.assign({
                        method: requestOptions.method,
                        body: requestOptions.body,
                        headers: requestOptions.headers,
                        redirect: requestOptions.redirect
                    }, // `requestOptions.request.agent` type is incompatible
                    // see https://github.com/octokit/types.ts/pull/264
                    requestOptions.request)).then(async response => {
                    url = response.url;
                    status = response.status;

                    for (const keyAndValue of response.headers) {
                        headers[keyAndValue[0]] = keyAndValue[1];
                    }

                    if ("deprecation" in headers) {
                        const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
                        const deprecationLink = matches && matches.pop();
                        log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
                    }

                    if (status === 204 || status === 205) {
                        return;
                    } // GitHub API returns 200 for HEAD requests


                    if (requestOptions.method === "HEAD") {
                        if (status < 400) {
                            return;
                        }

                        throw new requestError.RequestError(response.statusText, status, {
                            response: {
                                url,
                                status,
                                headers,
                                data: undefined
                            },
                            request: requestOptions
                        });
                    }

                    if (status === 304) {
                        throw new requestError.RequestError("Not modified", status, {
                            response: {
                                url,
                                status,
                                headers,
                                data: await getResponseData(response)
                            },
                            request: requestOptions
                        });
                    }

                    if (status >= 400) {
                        const data = await getResponseData(response);
                        const error = new requestError.RequestError(toErrorMessage(data), status, {
                            response: {
                                url,
                                status,
                                headers,
                                data
                            },
                            request: requestOptions
                        });
                        throw error;
                    }

                    return getResponseData(response);
                }).then(data => {
                    return {
                        status,
                        url,
                        headers,
                        data
                    };
                }).catch(error => {
                    if (error instanceof requestError.RequestError) throw error;
                    throw new requestError.RequestError(error.message, 500, {
                        request: requestOptions
                    });
                });
            }

            async function getResponseData(response) {
                const contentType = response.headers.get("content-type");

                if (/application\/json/.test(contentType)) {
                    return response.json();
                }

                if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
                    return response.text();
                }

                return getBufferResponse(response);
            }

            function toErrorMessage(data) {
                if (typeof data === "string") return data; // istanbul ignore else - just in case

                if ("message" in data) {
                    if (Array.isArray(data.errors)) {
                        return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
                    }

                    return data.message;
                } // istanbul ignore next - just in case


                return `Unknown error: ${JSON.stringify(data)}`;
            }

            function withDefaults(oldEndpoint, newDefaults) {
                const endpoint = oldEndpoint.defaults(newDefaults);

                const newApi = function (route, parameters) {
                    const endpointOptions = endpoint.merge(route, parameters);

                    if (!endpointOptions.request || !endpointOptions.request.hook) {
                        return fetchWrapper(endpoint.parse(endpointOptions));
                    }

                    const request = (route, parameters) => {
                        return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
                    };

                    Object.assign(request, {
                        endpoint,
                        defaults: withDefaults.bind(null, endpoint)
                    });
                    return endpointOptions.request.hook(request, endpointOptions);
                };

                return Object.assign(newApi, {
                    endpoint,
                    defaults: withDefaults.bind(null, endpoint)
                });
            }

            const request = withDefaults(endpoint.endpoint, {
                headers: {
                    "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
                }
            });

            exports.request = request;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 340 */,
        /* 341 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.toHex = exports.fromHex = void 0;
            const SHORT_TO_HEX = {};
            const HEX_TO_SHORT = {};
            for (let i = 0; i < 256; i++) {
                let encodedByte = i.toString(16).toLowerCase();
                if (encodedByte.length === 1) {
                    encodedByte = `0${encodedByte}`;
                }
                SHORT_TO_HEX[i] = encodedByte;
                HEX_TO_SHORT[encodedByte] = i;
            }

            function fromHex(encoded) {
                if (encoded.length % 2 !== 0) {
                    throw new Error("Hex encoded strings must have an even number length");
                }
                const out = new Uint8Array(encoded.length / 2);
                for (let i = 0; i < encoded.length; i += 2) {
                    const encodedByte = encoded.substr(i, 2).toLowerCase();
                    if (encodedByte in HEX_TO_SHORT) {
                        out[i / 2] = HEX_TO_SHORT[encodedByte];
                    } else {
                        throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
                    }
                }
                return out;
            }

            exports.fromHex = fromHex;

            function toHex(bytes) {
                let out = "";
                for (let i = 0; i < bytes.byteLength; i++) {
                    out += SHORT_TO_HEX[bytes[i]];
                }
                return out;
            }

            exports.toHex = toHex;


            /***/
        }),
        /* 342 */,
        /* 343 */,
        /* 344 */,
        /* 345 */,
        /* 346 */,
        /* 347 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.validateSsoProfile = void 0;
            const property_provider_1 = __webpack_require__(118);
            const validateSsoProfile = (profile) => {
                const {sso_start_url, sso_account_id, sso_region, sso_role_name} = profile;
                if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
                    throw new property_provider_1.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", ` +
                        `"sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
                }
                return profile;
            };
            exports.validateSsoProfile = validateSsoProfile;


            /***/
        }),
        /* 348 */,
        /* 349 */,
        /* 350 */,
        /* 351 */,
        /* 352 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveStsAuthConfig = void 0;
            const middleware_signing_1 = __webpack_require__(22);
            const resolveStsAuthConfig = (input, {stsClientCtor}) => (0, middleware_signing_1.resolveAwsAuthConfig)({
                ...input,
                stsClientCtor,
            });
            exports.resolveStsAuthConfig = resolveStsAuthConfig;


            /***/
        }),
        /* 353 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SESServiceException = void 0;
            const smithy_client_1 = __webpack_require__(449);

            class SESServiceException extends smithy_client_1.ServiceException {
                constructor(options) {
                    super(options);
                    Object.setPrototypeOf(this, SESServiceException.prototype);
                }
            }

            exports.SESServiceException = SESServiceException;


            /***/
        }),
        /* 354 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ProviderError = void 0;

            class ProviderError extends Error {
                constructor(message, tryNextLink = true) {
                    super(message);
                    this.tryNextLink = tryNextLink;
                    this.name = "ProviderError";
                    Object.setPrototypeOf(this, ProviderError.prototype);
                }

                static from(error, tryNextLink = true) {
                    return Object.assign(new this(error.message, tryNextLink), error);
                }
            }

            exports.ProviderError = ProviderError;


            /***/
        }),
        /* 355 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(526), exports);
            tslib_1.__exportStar(__webpack_require__(782), exports);
            tslib_1.__exportStar(__webpack_require__(798), exports);


            /***/
        }),
        /* 356 */,
        /* 357 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                Object.defineProperty(o, k2, {
                    enumerable: true, get: function () {
                        return m[k];
                    }
                });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", {enumerable: true, value: v});
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) {
                    return value instanceof P ? value : new P(function (resolve) {
                        resolve(value);
                    });
                }

                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
            const command_1 = __webpack_require__(92);
            const file_command_1 = __webpack_require__(158);
            const utils_1 = __webpack_require__(14);
            const os = __importStar(__webpack_require__(87));
            const path = __importStar(__webpack_require__(622));
            const oidc_utils_1 = __webpack_require__(531);
            /**
             * The code to exit an action
             */
            var ExitCode;
            (function (ExitCode) {
                /**
                 * A code indicating that the action was successful
                 */
                ExitCode[ExitCode["Success"] = 0] = "Success";
                /**
                 * A code indicating that the action was a failure
                 */
                ExitCode[ExitCode["Failure"] = 1] = "Failure";
            })(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
            /**
             * Sets env variable for this action and future actions in the job
             * @param name the name of the variable to set
             * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
             */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
            function exportVariable(name, val) {
                const convertedVal = utils_1.toCommandValue(val);
                process.env[name] = convertedVal;
                const filePath = process.env['GITHUB_ENV'] || '';
                if (filePath) {
                    const delimiter = '_GitHubActionsFileCommandDelimeter_';
                    const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
                    file_command_1.issueCommand('ENV', commandValue);
                } else {
                    command_1.issueCommand('set-env', {name}, convertedVal);
                }
            }

            exports.exportVariable = exportVariable;

            /**
             * Registers a secret which will get masked from logs
             * @param secret value of the secret
             */
            function setSecret(secret) {
                command_1.issueCommand('add-mask', {}, secret);
            }

            exports.setSecret = setSecret;

            /**
             * Prepends inputPath to the PATH (for this action and future actions)
             * @param inputPath
             */
            function addPath(inputPath) {
                const filePath = process.env['GITHUB_PATH'] || '';
                if (filePath) {
                    file_command_1.issueCommand('PATH', inputPath);
                } else {
                    command_1.issueCommand('add-path', {}, inputPath);
                }
                process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
            }

            exports.addPath = addPath;

            /**
             * Gets the value of an input.
             * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
             * Returns an empty string if the value is not defined.
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   string
             */
            function getInput(name, options) {
                const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
                if (options && options.required && !val) {
                    throw new Error(`Input required and not supplied: ${name}`);
                }
                if (options && options.trimWhitespace === false) {
                    return val;
                }
                return val.trim();
            }

            exports.getInput = getInput;

            /**
             * Gets the values of an multiline input.  Each value is also trimmed.
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   string[]
             *
             */
            function getMultilineInput(name, options) {
                const inputs = getInput(name, options)
                    .split('\n')
                    .filter(x => x !== '');
                return inputs;
            }

            exports.getMultilineInput = getMultilineInput;

            /**
             * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
             * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
             * The return value is also in boolean type.
             * ref: https://yaml.org/spec/1.2/spec.html#id2804923
             *
             * @param     name     name of the input to get
             * @param     options  optional. See InputOptions.
             * @returns   boolean
             */
            function getBooleanInput(name, options) {
                const trueValue = ['true', 'True', 'TRUE'];
                const falseValue = ['false', 'False', 'FALSE'];
                const val = getInput(name, options);
                if (trueValue.includes(val))
                    return true;
                if (falseValue.includes(val))
                    return false;
                throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
                    `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
            }

            exports.getBooleanInput = getBooleanInput;

            /**
             * Sets the value of an output.
             *
             * @param     name     name of the output to set
             * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
             */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
            function setOutput(name, value) {
                process.stdout.write(os.EOL);
                command_1.issueCommand('set-output', {name}, value);
            }

            exports.setOutput = setOutput;

            /**
             * Enables or disables the echoing of commands into stdout for the rest of the step.
             * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
             *
             */
            function setCommandEcho(enabled) {
                command_1.issue('echo', enabled ? 'on' : 'off');
            }

            exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
            /**
             * Sets the action status to failed.
             * When the action exits it will be with an exit code of 1
             * @param message add error issue message
             */
            function setFailed(message) {
                process.exitCode = ExitCode.Failure;
                error(message);
            }

            exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
            /**
             * Gets whether Actions Step Debug is on or not
             */
            function isDebug() {
                return process.env['RUNNER_DEBUG'] === '1';
            }

            exports.isDebug = isDebug;

            /**
             * Writes debug message to user log
             * @param message debug message
             */
            function debug(message) {
                command_1.issueCommand('debug', {}, message);
            }

            exports.debug = debug;

            /**
             * Adds an error issue
             * @param message error issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function error(message, properties = {}) {
                command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
            }

            exports.error = error;

            /**
             * Adds a warning issue
             * @param message warning issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function warning(message, properties = {}) {
                command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
            }

            exports.warning = warning;

            /**
             * Adds a notice issue
             * @param message notice issue message. Errors will be converted to string via toString()
             * @param properties optional properties to add to the annotation.
             */
            function notice(message, properties = {}) {
                command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
            }

            exports.notice = notice;

            /**
             * Writes info to log with console.log.
             * @param message info message
             */
            function info(message) {
                process.stdout.write(message + os.EOL);
            }

            exports.info = info;

            /**
             * Begin an output group.
             *
             * Output until the next `groupEnd` will be foldable in this group
             *
             * @param name The name of the output group
             */
            function startGroup(name) {
                command_1.issue('group', name);
            }

            exports.startGroup = startGroup;

            /**
             * End an output group.
             */
            function endGroup() {
                command_1.issue('endgroup');
            }

            exports.endGroup = endGroup;

            /**
             * Wrap an asynchronous function call in a group.
             *
             * Returns the same type as the function itself.
             *
             * @param name The name of the group
             * @param fn The function to wrap in the group
             */
            function group(name, fn) {
                return __awaiter(this, void 0, void 0, function* () {
                    startGroup(name);
                    let result;
                    try {
                        result = yield fn();
                    } finally {
                        endGroup();
                    }
                    return result;
                });
            }

            exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
            /**
             * Saves state for current action, the state can only be retrieved by this action's post job execution.
             *
             * @param     name     name of the state to store
             * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
             */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
            function saveState(name, value) {
                command_1.issueCommand('save-state', {name}, value);
            }

            exports.saveState = saveState;

            /**
             * Gets the value of an state set by this action's main execution.
             *
             * @param     name     name of the state to get
             * @returns   string
             */
            function getState(name) {
                return process.env[`STATE_${name}`] || '';
            }

            exports.getState = getState;

            function getIDToken(aud) {
                return __awaiter(this, void 0, void 0, function* () {
                    return yield oidc_utils_1.OidcClient.getIDToken(aud);
                });
            }

            exports.getIDToken = getIDToken;
//# sourceMappingURL=core.js.map

            /***/
        }),
        /* 358 */,
        /* 359 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            var punycode = __webpack_require__(213);
            var mappingTable = __webpack_require__(870);

            var PROCESSING_OPTIONS = {
                TRANSITIONAL: 0,
                NONTRANSITIONAL: 1
            };

            function normalize(str) { // fix bug in v8
                return str.split('\u0000').map(function (s) {
                    return s.normalize('NFC');
                }).join('\u0000');
            }

            function findStatus(val) {
                var start = 0;
                var end = mappingTable.length - 1;

                while (start <= end) {
                    var mid = Math.floor((start + end) / 2);

                    var target = mappingTable[mid];
                    if (target[0][0] <= val && target[0][1] >= val) {
                        return target;
                    } else if (target[0][0] > val) {
                        end = mid - 1;
                    } else {
                        start = mid + 1;
                    }
                }

                return null;
            }

            var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

            function countSymbols(string) {
                return string
                    // replace every surrogate pair with a BMP symbol
                    .replace(regexAstralSymbols, '_')
                    // then get the length
                    .length;
            }

            function mapChars(domain_name, useSTD3, processing_option) {
                var hasError = false;
                var processed = "";

                var len = countSymbols(domain_name);
                for (var i = 0; i < len; ++i) {
                    var codePoint = domain_name.codePointAt(i);
                    var status = findStatus(codePoint);

                    switch (status[1]) {
                        case "disallowed":
                            hasError = true;
                            processed += String.fromCodePoint(codePoint);
                            break;
                        case "ignored":
                            break;
                        case "mapped":
                            processed += String.fromCodePoint.apply(String, status[2]);
                            break;
                        case "deviation":
                            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
                                processed += String.fromCodePoint.apply(String, status[2]);
                            } else {
                                processed += String.fromCodePoint(codePoint);
                            }
                            break;
                        case "valid":
                            processed += String.fromCodePoint(codePoint);
                            break;
                        case "disallowed_STD3_mapped":
                            if (useSTD3) {
                                hasError = true;
                                processed += String.fromCodePoint(codePoint);
                            } else {
                                processed += String.fromCodePoint.apply(String, status[2]);
                            }
                            break;
                        case "disallowed_STD3_valid":
                            if (useSTD3) {
                                hasError = true;
                            }

                            processed += String.fromCodePoint(codePoint);
                            break;
                    }
                }

                return {
                    string: processed,
                    error: hasError
                };
            }

            var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;

            function validateLabel(label, processing_option) {
                if (label.substr(0, 4) === "xn--") {
                    label = punycode.toUnicode(label);
                    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
                }

                var error = false;

                if (normalize(label) !== label ||
                    (label[3] === "-" && label[4] === "-") ||
                    label[0] === "-" || label[label.length - 1] === "-" ||
                    label.indexOf(".") !== -1 ||
                    label.search(combiningMarksRegex) === 0) {
                    error = true;
                }

                var len = countSymbols(label);
                for (var i = 0; i < len; ++i) {
                    var status = findStatus(label.codePointAt(i));
                    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid") ||
                        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&
                            status[1] !== "valid" && status[1] !== "deviation")) {
                        error = true;
                        break;
                    }
                }

                return {
                    label: label,
                    error: error
                };
            }

            function processing(domain_name, useSTD3, processing_option) {
                var result = mapChars(domain_name, useSTD3, processing_option);
                result.string = normalize(result.string);

                var labels = result.string.split(".");
                for (var i = 0; i < labels.length; ++i) {
                    try {
                        var validation = validateLabel(labels[i]);
                        labels[i] = validation.label;
                        result.error = result.error || validation.error;
                    } catch (e) {
                        result.error = true;
                    }
                }

                return {
                    string: labels.join("."),
                    error: result.error
                };
            }

            module.exports.toASCII = function (domain_name, useSTD3, processing_option, verifyDnsLength) {
                var result = processing(domain_name, useSTD3, processing_option);
                var labels = result.string.split(".");
                labels = labels.map(function (l) {
                    try {
                        return punycode.toASCII(l);
                    } catch (e) {
                        result.error = true;
                        return l;
                    }
                });

                if (verifyDnsLength) {
                    var total = labels.slice(0, labels.length - 1).join(".").length;
                    if (total.length > 253 || total.length === 0) {
                        result.error = true;
                    }

                    for (var i = 0; i < labels.length; ++i) {
                        if (labels.length > 63 || labels.length === 0) {
                            result.error = true;
                            break;
                        }
                    }
                }

                if (result.error) return null;
                return labels.join(".");
            };

            module.exports.toUnicode = function (domain_name, useSTD3) {
                var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);

                return {
                    domain: result.string,
                    error: result.error
                };
            };

            module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;


            /***/
        }),
        /* 360 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});

            function getProxyUrl(reqUrl) {
                let usingSsl = reqUrl.protocol === 'https:';
                let proxyUrl;
                if (checkBypass(reqUrl)) {
                    return proxyUrl;
                }
                let proxyVar;
                if (usingSsl) {
                    proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];
                } else {
                    proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];
                }
                if (proxyVar) {
                    proxyUrl = new URL(proxyVar);
                }
                return proxyUrl;
            }

            exports.getProxyUrl = getProxyUrl;

            function checkBypass(reqUrl) {
                if (!reqUrl.hostname) {
                    return false;
                }
                let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
                if (!noProxy) {
                    return false;
                }
                // Determine the request port
                let reqPort;
                if (reqUrl.port) {
                    reqPort = Number(reqUrl.port);
                } else if (reqUrl.protocol === 'http:') {
                    reqPort = 80;
                } else if (reqUrl.protocol === 'https:') {
                    reqPort = 443;
                }
                // Format the request hostname and hostname with port
                let upperReqHosts = [reqUrl.hostname.toUpperCase()];
                if (typeof reqPort === 'number') {
                    upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
                }
                // Compare request host against noproxy
                for (let upperNoProxyItem of noProxy
                    .split(',')
                    .map(x => x.trim().toUpperCase())
                    .filter(x => x)) {
                    if (upperReqHosts.some(x => x === upperNoProxyItem)) {
                        return true;
                    }
                }
                return false;
            }

            exports.checkBypass = checkBypass;


            /***/
        }),
        /* 361 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(939), exports);


            /***/
        }),
        /* 362 */,
        /* 363 */,
        /* 364 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
            var decode_1 = __webpack_require__(477);
            var encode_1 = __webpack_require__(559);

            /**
             * Decodes a string with entities.
             *
             * @param data String to decode.
             * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
             * @deprecated Use `decodeXML` or `decodeHTML` directly.
             */
            function decode(data, level) {
                return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
            }

            exports.decode = decode;

            /**
             * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
             *
             * @param data String to decode.
             * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
             * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
             */
            function decodeStrict(data, level) {
                return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
            }

            exports.decodeStrict = decodeStrict;

            /**
             * Encodes a string with entities.
             *
             * @param data String to encode.
             * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
             * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
             */
            function encode(data, level) {
                return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
            }

            exports.encode = encode;
            var encode_2 = __webpack_require__(559);
            Object.defineProperty(exports, "encodeXML", {
                enumerable: true, get: function () {
                    return encode_2.encodeXML;
                }
            });
            Object.defineProperty(exports, "encodeHTML", {
                enumerable: true, get: function () {
                    return encode_2.encodeHTML;
                }
            });
            Object.defineProperty(exports, "encodeNonAsciiHTML", {
                enumerable: true, get: function () {
                    return encode_2.encodeNonAsciiHTML;
                }
            });
            Object.defineProperty(exports, "escape", {
                enumerable: true, get: function () {
                    return encode_2.escape;
                }
            });
            Object.defineProperty(exports, "escapeUTF8", {
                enumerable: true, get: function () {
                    return encode_2.escapeUTF8;
                }
            });
// Legacy aliases (deprecated)
            Object.defineProperty(exports, "encodeHTML4", {
                enumerable: true, get: function () {
                    return encode_2.encodeHTML;
                }
            });
            Object.defineProperty(exports, "encodeHTML5", {
                enumerable: true, get: function () {
                    return encode_2.encodeHTML;
                }
            });
            var decode_2 = __webpack_require__(477);
            Object.defineProperty(exports, "decodeXML", {
                enumerable: true, get: function () {
                    return decode_2.decodeXML;
                }
            });
            Object.defineProperty(exports, "decodeHTML", {
                enumerable: true, get: function () {
                    return decode_2.decodeHTML;
                }
            });
            Object.defineProperty(exports, "decodeHTMLStrict", {
                enumerable: true, get: function () {
                    return decode_2.decodeHTMLStrict;
                }
            });
// Legacy aliases (deprecated)
            Object.defineProperty(exports, "decodeHTML4", {
                enumerable: true, get: function () {
                    return decode_2.decodeHTML;
                }
            });
            Object.defineProperty(exports, "decodeHTML5", {
                enumerable: true, get: function () {
                    return decode_2.decodeHTML;
                }
            });
            Object.defineProperty(exports, "decodeHTML4Strict", {
                enumerable: true, get: function () {
                    return decode_2.decodeHTMLStrict;
                }
            });
            Object.defineProperty(exports, "decodeHTML5Strict", {
                enumerable: true, get: function () {
                    return decode_2.decodeHTMLStrict;
                }
            });
            Object.defineProperty(exports, "decodeXMLStrict", {
                enumerable: true, get: function () {
                    return decode_2.decodeXML;
                }
            });


            /***/
        }),
        /* 365 */,
        /* 366 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(513), exports);
            tslib_1.__exportStar(__webpack_require__(223), exports);
            tslib_1.__exportStar(__webpack_require__(994), exports);
            tslib_1.__exportStar(__webpack_require__(904), exports);


            /***/
        }),
        /* 367 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.writeRequestBody = void 0;
            const stream_1 = __webpack_require__(413);

            function writeRequestBody(httpRequest, request) {
                const expect = request.headers["Expect"] || request.headers["expect"];
                if (expect === "100-continue") {
                    httpRequest.on("continue", () => {
                        writeBody(httpRequest, request.body);
                    });
                } else {
                    writeBody(httpRequest, request.body);
                }
            }

            exports.writeRequestBody = writeRequestBody;

            function writeBody(httpRequest, body) {
                if (body instanceof stream_1.Readable) {
                    body.pipe(httpRequest);
                } else if (body) {
                    httpRequest.end(Buffer.from(body));
                } else {
                    httpRequest.end();
                }
            }


            /***/
        }),
        /* 368 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const http = __webpack_require__(605);
            const https = __webpack_require__(211);
            const pm = __webpack_require__(360);
            let tunnel;
            var HttpCodes;
            (function (HttpCodes) {
                HttpCodes[HttpCodes["OK"] = 200] = "OK";
                HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
                HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
                HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
                HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
                HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
                HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
                HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
                HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
                HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
                HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
                HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
                HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
                HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
                HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
                HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
                HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
                HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
                HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
                HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
                HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
                HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
                HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
                HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
                HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
                HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
                HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
            })(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
            var Headers;
            (function (Headers) {
                Headers["Accept"] = "accept";
                Headers["ContentType"] = "content-type";
            })(Headers = exports.Headers || (exports.Headers = {}));
            var MediaTypes;
            (function (MediaTypes) {
                MediaTypes["ApplicationJson"] = "application/json";
            })(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));

            /**
             * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
             * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
             */
            function getProxyUrl(serverUrl) {
                let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
                return proxyUrl ? proxyUrl.href : '';
            }

            exports.getProxyUrl = getProxyUrl;
            const HttpRedirectCodes = [
                HttpCodes.MovedPermanently,
                HttpCodes.ResourceMoved,
                HttpCodes.SeeOther,
                HttpCodes.TemporaryRedirect,
                HttpCodes.PermanentRedirect
            ];
            const HttpResponseRetryCodes = [
                HttpCodes.BadGateway,
                HttpCodes.ServiceUnavailable,
                HttpCodes.GatewayTimeout
            ];
            const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
            const ExponentialBackoffCeiling = 10;
            const ExponentialBackoffTimeSlice = 5;

            class HttpClientError extends Error {
                constructor(message, statusCode) {
                    super(message);
                    this.name = 'HttpClientError';
                    this.statusCode = statusCode;
                    Object.setPrototypeOf(this, HttpClientError.prototype);
                }
            }

            exports.HttpClientError = HttpClientError;

            class HttpClientResponse {
                constructor(message) {
                    this.message = message;
                }

                readBody() {
                    return new Promise(async (resolve, reject) => {
                        let output = Buffer.alloc(0);
                        this.message.on('data', (chunk) => {
                            output = Buffer.concat([output, chunk]);
                        });
                        this.message.on('end', () => {
                            resolve(output.toString());
                        });
                    });
                }
            }

            exports.HttpClientResponse = HttpClientResponse;

            function isHttps(requestUrl) {
                let parsedUrl = new URL(requestUrl);
                return parsedUrl.protocol === 'https:';
            }

            exports.isHttps = isHttps;

            class HttpClient {
                constructor(userAgent, handlers, requestOptions) {
                    this._ignoreSslError = false;
                    this._allowRedirects = true;
                    this._allowRedirectDowngrade = false;
                    this._maxRedirects = 50;
                    this._allowRetries = false;
                    this._maxRetries = 1;
                    this._keepAlive = false;
                    this._disposed = false;
                    this.userAgent = userAgent;
                    this.handlers = handlers || [];
                    this.requestOptions = requestOptions;
                    if (requestOptions) {
                        if (requestOptions.ignoreSslError != null) {
                            this._ignoreSslError = requestOptions.ignoreSslError;
                        }
                        this._socketTimeout = requestOptions.socketTimeout;
                        if (requestOptions.allowRedirects != null) {
                            this._allowRedirects = requestOptions.allowRedirects;
                        }
                        if (requestOptions.allowRedirectDowngrade != null) {
                            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
                        }
                        if (requestOptions.maxRedirects != null) {
                            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
                        }
                        if (requestOptions.keepAlive != null) {
                            this._keepAlive = requestOptions.keepAlive;
                        }
                        if (requestOptions.allowRetries != null) {
                            this._allowRetries = requestOptions.allowRetries;
                        }
                        if (requestOptions.maxRetries != null) {
                            this._maxRetries = requestOptions.maxRetries;
                        }
                    }
                }

                static dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        let a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }

                options(requestUrl, additionalHeaders) {
                    return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
                }

                get(requestUrl, additionalHeaders) {
                    return this.request('GET', requestUrl, null, additionalHeaders || {});
                }

                del(requestUrl, additionalHeaders) {
                    return this.request('DELETE', requestUrl, null, additionalHeaders || {});
                }

                post(requestUrl, data, additionalHeaders) {
                    return this.request('POST', requestUrl, data, additionalHeaders || {});
                }

                patch(requestUrl, data, additionalHeaders) {
                    return this.request('PATCH', requestUrl, data, additionalHeaders || {});
                }

                put(requestUrl, data, additionalHeaders) {
                    return this.request('PUT', requestUrl, data, additionalHeaders || {});
                }

                head(requestUrl, additionalHeaders) {
                    return this.request('HEAD', requestUrl, null, additionalHeaders || {});
                }

                sendStream(verb, requestUrl, stream, additionalHeaders) {
                    return this.request(verb, requestUrl, stream, additionalHeaders);
                }

                /**
                 * Gets a typed object from an endpoint
                 * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
                 */
                async getJson(requestUrl, additionalHeaders = {}) {
                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                    let res = await this.get(requestUrl, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                }

                async postJson(requestUrl, obj, additionalHeaders = {}) {
                    let data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                    let res = await this.post(requestUrl, data, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                }

                async putJson(requestUrl, obj, additionalHeaders = {}) {
                    let data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                    let res = await this.put(requestUrl, data, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                }

                async patchJson(requestUrl, obj, additionalHeaders = {}) {
                    let data = JSON.stringify(obj, null, 2);
                    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
                    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
                    let res = await this.patch(requestUrl, data, additionalHeaders);
                    return this._processResponse(res, this.requestOptions);
                }

                /**
                 * Makes a raw http request.
                 * All other methods such as get, post, patch, and request ultimately call this.
                 * Prefer get, del, post and patch
                 */
                async request(verb, requestUrl, data, headers) {
                    if (this._disposed) {
                        throw new Error('Client has already been disposed.');
                    }
                    let parsedUrl = new URL(requestUrl);
                    let info = this._prepareRequest(verb, parsedUrl, headers);
                    // Only perform retries on reads since writes may not be idempotent.
                    let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1
                        ? this._maxRetries + 1
                        : 1;
                    let numTries = 0;
                    let response;
                    while (numTries < maxTries) {
                        response = await this.requestRaw(info, data);
                        // Check if it's an authentication challenge
                        if (response &&
                            response.message &&
                            response.message.statusCode === HttpCodes.Unauthorized) {
                            let authenticationHandler;
                            for (let i = 0; i < this.handlers.length; i++) {
                                if (this.handlers[i].canHandleAuthentication(response)) {
                                    authenticationHandler = this.handlers[i];
                                    break;
                                }
                            }
                            if (authenticationHandler) {
                                return authenticationHandler.handleAuthentication(this, info, data);
                            } else {
                                // We have received an unauthorized response but have no handlers to handle it.
                                // Let the response return to the caller.
                                return response;
                            }
                        }
                        let redirectsRemaining = this._maxRedirects;
                        while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&
                        this._allowRedirects &&
                        redirectsRemaining > 0) {
                            const redirectUrl = response.message.headers['location'];
                            if (!redirectUrl) {
                                // if there's no location to redirect to, we won't
                                break;
                            }
                            let parsedRedirectUrl = new URL(redirectUrl);
                            if (parsedUrl.protocol == 'https:' &&
                                parsedUrl.protocol != parsedRedirectUrl.protocol &&
                                !this._allowRedirectDowngrade) {
                                throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                            }
                            // we need to finish reading the response before reassigning response
                            // which will leak the open socket.
                            await response.readBody();
                            // strip authorization header if redirected to a different hostname
                            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                                for (let header in headers) {
                                    // header names are case insensitive
                                    if (header.toLowerCase() === 'authorization') {
                                        delete headers[header];
                                    }
                                }
                            }
                            // let's make the request with the new redirectUrl
                            info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                            response = await this.requestRaw(info, data);
                            redirectsRemaining--;
                        }
                        if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
                            // If not a retry code, return immediately instead of retrying
                            return response;
                        }
                        numTries += 1;
                        if (numTries < maxTries) {
                            await response.readBody();
                            await this._performExponentialBackoff(numTries);
                        }
                    }
                    return response;
                }

                /**
                 * Needs to be called if keepAlive is set to true in request options.
                 */
                dispose() {
                    if (this._agent) {
                        this._agent.destroy();
                    }
                    this._disposed = true;
                }

                /**
                 * Raw request.
                 * @param info
                 * @param data
                 */
                requestRaw(info, data) {
                    return new Promise((resolve, reject) => {
                        let callbackForResult = function (err, res) {
                            if (err) {
                                reject(err);
                            }
                            resolve(res);
                        };
                        this.requestRawWithCallback(info, data, callbackForResult);
                    });
                }

                /**
                 * Raw request with callback.
                 * @param info
                 * @param data
                 * @param onResult
                 */
                requestRawWithCallback(info, data, onResult) {
                    let socket;
                    if (typeof data === 'string') {
                        info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
                    }
                    let callbackCalled = false;
                    let handleResult = (err, res) => {
                        if (!callbackCalled) {
                            callbackCalled = true;
                            onResult(err, res);
                        }
                    };
                    let req = info.httpModule.request(info.options, (msg) => {
                        let res = new HttpClientResponse(msg);
                        handleResult(null, res);
                    });
                    req.on('socket', sock => {
                        socket = sock;
                    });
                    // If we ever get disconnected, we want the socket to timeout eventually
                    req.setTimeout(this._socketTimeout || 3 * 60000, () => {
                        if (socket) {
                            socket.end();
                        }
                        handleResult(new Error('Request timeout: ' + info.options.path), null);
                    });
                    req.on('error', function (err) {
                        // err has statusCode property
                        // res should have headers
                        handleResult(err, null);
                    });
                    if (data && typeof data === 'string') {
                        req.write(data, 'utf8');
                    }
                    if (data && typeof data !== 'string') {
                        data.on('close', function () {
                            req.end();
                        });
                        data.pipe(req);
                    } else {
                        req.end();
                    }
                }

                /**
                 * Gets an http agent. This function is useful when you need an http agent that handles
                 * routing through a proxy server - depending upon the url and proxy environment variables.
                 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
                 */
                getAgent(serverUrl) {
                    let parsedUrl = new URL(serverUrl);
                    return this._getAgent(parsedUrl);
                }

                _prepareRequest(method, requestUrl, headers) {
                    const info = {};
                    info.parsedUrl = requestUrl;
                    const usingSsl = info.parsedUrl.protocol === 'https:';
                    info.httpModule = usingSsl ? https : http;
                    const defaultPort = usingSsl ? 443 : 80;
                    info.options = {};
                    info.options.host = info.parsedUrl.hostname;
                    info.options.port = info.parsedUrl.port
                        ? parseInt(info.parsedUrl.port)
                        : defaultPort;
                    info.options.path =
                        (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
                    info.options.method = method;
                    info.options.headers = this._mergeHeaders(headers);
                    if (this.userAgent != null) {
                        info.options.headers['user-agent'] = this.userAgent;
                    }
                    info.options.agent = this._getAgent(info.parsedUrl);
                    // gives handlers an opportunity to participate
                    if (this.handlers) {
                        this.handlers.forEach(handler => {
                            handler.prepareRequest(info.options);
                        });
                    }
                    return info;
                }

                _mergeHeaders(headers) {
                    const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
                    if (this.requestOptions && this.requestOptions.headers) {
                        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
                    }
                    return lowercaseKeys(headers || {});
                }

                _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
                    const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
                    let clientHeader;
                    if (this.requestOptions && this.requestOptions.headers) {
                        clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
                    }
                    return additionalHeaders[header] || clientHeader || _default;
                }

                _getAgent(parsedUrl) {
                    let agent;
                    let proxyUrl = pm.getProxyUrl(parsedUrl);
                    let useProxy = proxyUrl && proxyUrl.hostname;
                    if (this._keepAlive && useProxy) {
                        agent = this._proxyAgent;
                    }
                    if (this._keepAlive && !useProxy) {
                        agent = this._agent;
                    }
                    // if agent is already assigned use that agent.
                    if (!!agent) {
                        return agent;
                    }
                    const usingSsl = parsedUrl.protocol === 'https:';
                    let maxSockets = 100;
                    if (!!this.requestOptions) {
                        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
                    }
                    if (useProxy) {
                        // If using proxy, need tunnel
                        if (!tunnel) {
                            tunnel = __webpack_require__(299);
                        }
                        const agentOptions = {
                            maxSockets: maxSockets,
                            keepAlive: this._keepAlive,
                            proxy: {
                                ...((proxyUrl.username || proxyUrl.password) && {
                                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                                }),
                                host: proxyUrl.hostname,
                                port: proxyUrl.port
                            }
                        };
                        let tunnelAgent;
                        const overHttps = proxyUrl.protocol === 'https:';
                        if (usingSsl) {
                            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
                        } else {
                            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
                        }
                        agent = tunnelAgent(agentOptions);
                        this._proxyAgent = agent;
                    }
                    // if reusing agent across request and tunneling agent isn't assigned create a new agent
                    if (this._keepAlive && !agent) {
                        const options = {keepAlive: this._keepAlive, maxSockets: maxSockets};
                        agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
                        this._agent = agent;
                    }
                    // if not using private agent and tunnel agent isn't setup then use global agent
                    if (!agent) {
                        agent = usingSsl ? https.globalAgent : http.globalAgent;
                    }
                    if (usingSsl && this._ignoreSslError) {
                        // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
                        // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
                        // we have to cast it to any and change it directly
                        agent.options = Object.assign(agent.options || {}, {
                            rejectUnauthorized: false
                        });
                    }
                    return agent;
                }

                _performExponentialBackoff(retryNumber) {
                    retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
                    const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
                    return new Promise(resolve => setTimeout(() => resolve(), ms));
                }

                async _processResponse(res, options) {
                    return new Promise(async (resolve, reject) => {
                        const statusCode = res.message.statusCode;
                        const response = {
                            statusCode: statusCode,
                            result: null,
                            headers: {}
                        };
                        // not found leads to null obj returned
                        if (statusCode == HttpCodes.NotFound) {
                            resolve(response);
                        }
                        let obj;
                        let contents;
                        // get the result from the body
                        try {
                            contents = await res.readBody();
                            if (contents && contents.length > 0) {
                                if (options && options.deserializeDates) {
                                    obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);
                                } else {
                                    obj = JSON.parse(contents);
                                }
                                response.result = obj;
                            }
                            response.headers = res.message.headers;
                        } catch (err) {
                            // Invalid resource (contents not json);  leaving result obj null
                        }
                        // note that 3xx redirects are handled by the http layer.
                        if (statusCode > 299) {
                            let msg;
                            // if exception/error in body, attempt to get better error
                            if (obj && obj.message) {
                                msg = obj.message;
                            } else if (contents && contents.length > 0) {
                                // it may be the case that the exception is in the body message as string
                                msg = contents;
                            } else {
                                msg = 'Failed request: (' + statusCode + ')';
                            }
                            let err = new HttpClientError(msg, statusCode);
                            err.result = response.result;
                            reject(err);
                        } else {
                            resolve(response);
                        }
                    });
                }
            }

            exports.HttpClient = HttpClient;


            /***/
        }),
        /* 369 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DescribeReceiptRuleSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DescribeReceiptRuleSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DescribeReceiptRuleSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DescribeReceiptRuleSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DescribeReceiptRuleSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDescribeReceiptRuleSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDescribeReceiptRuleSetCommand)(output, context);
                }
            }

            exports.DescribeReceiptRuleSetCommand = DescribeReceiptRuleSetCommand;


            /***/
        }),
        /* 370 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetIdentityVerificationAttributesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetIdentityVerificationAttributesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetIdentityVerificationAttributesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetIdentityVerificationAttributesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetIdentityVerificationAttributesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetIdentityVerificationAttributesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetIdentityVerificationAttributesCommand)(output, context);
                }
            }

            exports.GetIdentityVerificationAttributesCommand = GetIdentityVerificationAttributesCommand;


            /***/
        }),
        /* 371 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(222), exports);


            /***/
        }),
        /* 372 */,
        /* 373 */,
        /* 374 */,
        /* 375 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UpdateCustomVerificationEmailTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class UpdateCustomVerificationEmailTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "UpdateCustomVerificationEmailTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.UpdateCustomVerificationEmailTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryUpdateCustomVerificationEmailTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryUpdateCustomVerificationEmailTemplateCommand)(output, context);
                }
            }

            exports.UpdateCustomVerificationEmailTemplateCommand = UpdateCustomVerificationEmailTemplateCommand;


            /***/
        }),
        /* 376 */,
        /* 377 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(278), exports);


            /***/
        }),
        /* 378 */,
        /* 379 */,
        /* 380 */,
        /* 381 */,
        /* 382 */,
        /* 383 */,
        /* 384 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteIdentityPolicyCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteIdentityPolicyCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteIdentityPolicyCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteIdentityPolicyRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteIdentityPolicyResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteIdentityPolicyCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteIdentityPolicyCommand)(output, context);
                }
            }

            exports.DeleteIdentityPolicyCommand = DeleteIdentityPolicyCommand;


            /***/
        }),
        /* 385 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromEnv = exports.ENV_EXPIRATION = exports.ENV_SESSION = exports.ENV_SECRET = exports.ENV_KEY = void 0;
            const property_provider_1 = __webpack_require__(118);
            exports.ENV_KEY = "AWS_ACCESS_KEY_ID";
            exports.ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
            exports.ENV_SESSION = "AWS_SESSION_TOKEN";
            exports.ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
            const fromEnv = () => async () => {
                const accessKeyId = process.env[exports.ENV_KEY];
                const secretAccessKey = process.env[exports.ENV_SECRET];
                const sessionToken = process.env[exports.ENV_SESSION];
                const expiry = process.env[exports.ENV_EXPIRATION];
                if (accessKeyId && secretAccessKey) {
                    return {
                        accessKeyId,
                        secretAccessKey,
                        ...(sessionToken && {sessionToken}),
                        ...(expiry && {expiration: new Date(expiry)}),
                    };
                }
                throw new property_provider_1.CredentialsProviderError("Unable to find environment variable credentials.");
            };
            exports.fromEnv = fromEnv;


            /***/
        }),
        /* 386 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.slurpFile = void 0;
            const fs_1 = __webpack_require__(747);
            const {readFile} = fs_1.promises;
            const fileStatusHash = {};
            const slurpFile = (path) => new Promise((resolve, reject) => {
                if (!fileStatusHash[path]) {
                    fileStatusHash[path] = {isReading: true, contents: "", requestQueue: []};
                    fileStatusHash[path].requestQueue.push({resolve, reject});
                    readFile(path, "utf8")
                        .then((data) => {
                            fileStatusHash[path].isReading = false;
                            fileStatusHash[path].contents = data;
                            const {requestQueue} = fileStatusHash[path];
                            while (requestQueue.length) {
                                const {resolve} = requestQueue.pop();
                                resolve(data);
                            }
                        })
                        .catch((err) => {
                            fileStatusHash[path].isReading = false;
                            const {requestQueue} = fileStatusHash[path];
                            while (requestQueue.length) {
                                const {reject} = requestQueue.pop();
                                reject(err);
                            }
                        });
                } else if (fileStatusHash[path].isReading) {
                    fileStatusHash[path].requestQueue.push({resolve, reject});
                } else {
                    resolve(fileStatusHash[path].contents);
                }
            });
            exports.slurpFile = slurpFile;


            /***/
        }),
        /* 387 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ENDPOINT_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_NAME = exports.ENV_ENDPOINT_NAME = void 0;
            exports.ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
            exports.CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
            exports.ENDPOINT_CONFIG_OPTIONS = {
                environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_NAME],
                configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_NAME],
                default: undefined,
            };


            /***/
        }),
        /* 388 */,
        /* 389 */,
        /* 390 */,
        /* 391 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetIdentityPoliciesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetIdentityPoliciesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetIdentityPoliciesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetIdentityPoliciesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetIdentityPoliciesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetIdentityPoliciesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetIdentityPoliciesCommand)(output, context);
                }
            }

            exports.GetIdentityPoliciesCommand = GetIdentityPoliciesCommand;


            /***/
        }),
        /* 392 */,
        /* 393 */,
        /* 394 */,
        /* 395 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListVerifiedEmailAddressesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ListVerifiedEmailAddressesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ListVerifiedEmailAddressesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: (input) => input,
                        outputFilterSensitiveLog: models_0_1.ListVerifiedEmailAddressesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryListVerifiedEmailAddressesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryListVerifiedEmailAddressesCommand)(output, context);
                }
            }

            exports.ListVerifiedEmailAddressesCommand = ListVerifiedEmailAddressesCommand;


            /***/
        }),
        /* 396 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRealRegion = void 0;
            const isFipsRegion_1 = __webpack_require__(403);
            const getRealRegion = (region) => (0, isFipsRegion_1.isFipsRegion)(region)
                ? ["fips-aws-global", "aws-fips"].includes(region)
                    ? "us-east-1"
                    : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
                : region;
            exports.getRealRegion = getRealRegion;


            /***/
        }),
        /* 397 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.streamCollector = void 0;
            const collector_1 = __webpack_require__(179);
            const streamCollector = (stream) => new Promise((resolve, reject) => {
                const collector = new collector_1.Collector();
                stream.pipe(collector);
                stream.on("error", (err) => {
                    collector.end();
                    reject(err);
                });
                collector.on("error", reject);
                collector.on("finish", function () {
                    const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
                    resolve(bytes);
                });
            });
            exports.streamCollector = streamCollector;


            /***/
        }),
        /* 398 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SetIdentityHeadersInNotificationsEnabledCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SetIdentityHeadersInNotificationsEnabledCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SetIdentityHeadersInNotificationsEnabledCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SetIdentityHeadersInNotificationsEnabledRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SetIdentityHeadersInNotificationsEnabledResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySetIdentityHeadersInNotificationsEnabledCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySetIdentityHeadersInNotificationsEnabledCommand)(output, context);
                }
            }

            exports.SetIdentityHeadersInNotificationsEnabledCommand = SetIdentityHeadersInNotificationsEnabledCommand;


            /***/
        }),
        /* 399 */,
        /* 400 */,
        /* 401 */,
        /* 402 */,
        /* 403 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.isFipsRegion = void 0;
            const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
            exports.isFipsRegion = isFipsRegion;


            /***/
        }),
        /* 404 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.AssumeRoleWithSAMLCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(575);
            const Aws_query_1 = __webpack_require__(139);

            class AssumeRoleWithSAMLCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "STSClient";
                    const commandName = "AssumeRoleWithSAMLCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryAssumeRoleWithSAMLCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryAssumeRoleWithSAMLCommand)(output, context);
                }
            }

            exports.AssumeRoleWithSAMLCommand = AssumeRoleWithSAMLCommand;


            /***/
        }),
        /* 405 */,
        /* 406 */,
        /* 407 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.serializeAws_querySendRawEmailCommand = exports.serializeAws_querySendEmailCommand = exports.serializeAws_querySendCustomVerificationEmailCommand = exports.serializeAws_querySendBulkTemplatedEmailCommand = exports.serializeAws_querySendBounceCommand = exports.serializeAws_queryReorderReceiptRuleSetCommand = exports.serializeAws_queryPutIdentityPolicyCommand = exports.serializeAws_queryPutConfigurationSetDeliveryOptionsCommand = exports.serializeAws_queryListVerifiedEmailAddressesCommand = exports.serializeAws_queryListTemplatesCommand = exports.serializeAws_queryListReceiptRuleSetsCommand = exports.serializeAws_queryListReceiptFiltersCommand = exports.serializeAws_queryListIdentityPoliciesCommand = exports.serializeAws_queryListIdentitiesCommand = exports.serializeAws_queryListCustomVerificationEmailTemplatesCommand = exports.serializeAws_queryListConfigurationSetsCommand = exports.serializeAws_queryGetTemplateCommand = exports.serializeAws_queryGetSendStatisticsCommand = exports.serializeAws_queryGetSendQuotaCommand = exports.serializeAws_queryGetIdentityVerificationAttributesCommand = exports.serializeAws_queryGetIdentityPoliciesCommand = exports.serializeAws_queryGetIdentityNotificationAttributesCommand = exports.serializeAws_queryGetIdentityMailFromDomainAttributesCommand = exports.serializeAws_queryGetIdentityDkimAttributesCommand = exports.serializeAws_queryGetCustomVerificationEmailTemplateCommand = exports.serializeAws_queryGetAccountSendingEnabledCommand = exports.serializeAws_queryDescribeReceiptRuleSetCommand = exports.serializeAws_queryDescribeReceiptRuleCommand = exports.serializeAws_queryDescribeConfigurationSetCommand = exports.serializeAws_queryDescribeActiveReceiptRuleSetCommand = exports.serializeAws_queryDeleteVerifiedEmailAddressCommand = exports.serializeAws_queryDeleteTemplateCommand = exports.serializeAws_queryDeleteReceiptRuleSetCommand = exports.serializeAws_queryDeleteReceiptRuleCommand = exports.serializeAws_queryDeleteReceiptFilterCommand = exports.serializeAws_queryDeleteIdentityPolicyCommand = exports.serializeAws_queryDeleteIdentityCommand = exports.serializeAws_queryDeleteCustomVerificationEmailTemplateCommand = exports.serializeAws_queryDeleteConfigurationSetTrackingOptionsCommand = exports.serializeAws_queryDeleteConfigurationSetEventDestinationCommand = exports.serializeAws_queryDeleteConfigurationSetCommand = exports.serializeAws_queryCreateTemplateCommand = exports.serializeAws_queryCreateReceiptRuleSetCommand = exports.serializeAws_queryCreateReceiptRuleCommand = exports.serializeAws_queryCreateReceiptFilterCommand = exports.serializeAws_queryCreateCustomVerificationEmailTemplateCommand = exports.serializeAws_queryCreateConfigurationSetTrackingOptionsCommand = exports.serializeAws_queryCreateConfigurationSetEventDestinationCommand = exports.serializeAws_queryCreateConfigurationSetCommand = exports.serializeAws_queryCloneReceiptRuleSetCommand = void 0;
            exports.deserializeAws_queryGetIdentityNotificationAttributesCommand = exports.deserializeAws_queryGetIdentityMailFromDomainAttributesCommand = exports.deserializeAws_queryGetIdentityDkimAttributesCommand = exports.deserializeAws_queryGetCustomVerificationEmailTemplateCommand = exports.deserializeAws_queryGetAccountSendingEnabledCommand = exports.deserializeAws_queryDescribeReceiptRuleSetCommand = exports.deserializeAws_queryDescribeReceiptRuleCommand = exports.deserializeAws_queryDescribeConfigurationSetCommand = exports.deserializeAws_queryDescribeActiveReceiptRuleSetCommand = exports.deserializeAws_queryDeleteVerifiedEmailAddressCommand = exports.deserializeAws_queryDeleteTemplateCommand = exports.deserializeAws_queryDeleteReceiptRuleSetCommand = exports.deserializeAws_queryDeleteReceiptRuleCommand = exports.deserializeAws_queryDeleteReceiptFilterCommand = exports.deserializeAws_queryDeleteIdentityPolicyCommand = exports.deserializeAws_queryDeleteIdentityCommand = exports.deserializeAws_queryDeleteCustomVerificationEmailTemplateCommand = exports.deserializeAws_queryDeleteConfigurationSetTrackingOptionsCommand = exports.deserializeAws_queryDeleteConfigurationSetEventDestinationCommand = exports.deserializeAws_queryDeleteConfigurationSetCommand = exports.deserializeAws_queryCreateTemplateCommand = exports.deserializeAws_queryCreateReceiptRuleSetCommand = exports.deserializeAws_queryCreateReceiptRuleCommand = exports.deserializeAws_queryCreateReceiptFilterCommand = exports.deserializeAws_queryCreateCustomVerificationEmailTemplateCommand = exports.deserializeAws_queryCreateConfigurationSetTrackingOptionsCommand = exports.deserializeAws_queryCreateConfigurationSetEventDestinationCommand = exports.deserializeAws_queryCreateConfigurationSetCommand = exports.deserializeAws_queryCloneReceiptRuleSetCommand = exports.serializeAws_queryVerifyEmailIdentityCommand = exports.serializeAws_queryVerifyEmailAddressCommand = exports.serializeAws_queryVerifyDomainIdentityCommand = exports.serializeAws_queryVerifyDomainDkimCommand = exports.serializeAws_queryUpdateTemplateCommand = exports.serializeAws_queryUpdateReceiptRuleCommand = exports.serializeAws_queryUpdateCustomVerificationEmailTemplateCommand = exports.serializeAws_queryUpdateConfigurationSetTrackingOptionsCommand = exports.serializeAws_queryUpdateConfigurationSetSendingEnabledCommand = exports.serializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand = exports.serializeAws_queryUpdateConfigurationSetEventDestinationCommand = exports.serializeAws_queryUpdateAccountSendingEnabledCommand = exports.serializeAws_queryTestRenderTemplateCommand = exports.serializeAws_querySetReceiptRulePositionCommand = exports.serializeAws_querySetIdentityNotificationTopicCommand = exports.serializeAws_querySetIdentityMailFromDomainCommand = exports.serializeAws_querySetIdentityHeadersInNotificationsEnabledCommand = exports.serializeAws_querySetIdentityFeedbackForwardingEnabledCommand = exports.serializeAws_querySetIdentityDkimEnabledCommand = exports.serializeAws_querySetActiveReceiptRuleSetCommand = exports.serializeAws_querySendTemplatedEmailCommand = void 0;
            exports.deserializeAws_queryVerifyEmailIdentityCommand = exports.deserializeAws_queryVerifyEmailAddressCommand = exports.deserializeAws_queryVerifyDomainIdentityCommand = exports.deserializeAws_queryVerifyDomainDkimCommand = exports.deserializeAws_queryUpdateTemplateCommand = exports.deserializeAws_queryUpdateReceiptRuleCommand = exports.deserializeAws_queryUpdateCustomVerificationEmailTemplateCommand = exports.deserializeAws_queryUpdateConfigurationSetTrackingOptionsCommand = exports.deserializeAws_queryUpdateConfigurationSetSendingEnabledCommand = exports.deserializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand = exports.deserializeAws_queryUpdateConfigurationSetEventDestinationCommand = exports.deserializeAws_queryUpdateAccountSendingEnabledCommand = exports.deserializeAws_queryTestRenderTemplateCommand = exports.deserializeAws_querySetReceiptRulePositionCommand = exports.deserializeAws_querySetIdentityNotificationTopicCommand = exports.deserializeAws_querySetIdentityMailFromDomainCommand = exports.deserializeAws_querySetIdentityHeadersInNotificationsEnabledCommand = exports.deserializeAws_querySetIdentityFeedbackForwardingEnabledCommand = exports.deserializeAws_querySetIdentityDkimEnabledCommand = exports.deserializeAws_querySetActiveReceiptRuleSetCommand = exports.deserializeAws_querySendTemplatedEmailCommand = exports.deserializeAws_querySendRawEmailCommand = exports.deserializeAws_querySendEmailCommand = exports.deserializeAws_querySendCustomVerificationEmailCommand = exports.deserializeAws_querySendBulkTemplatedEmailCommand = exports.deserializeAws_querySendBounceCommand = exports.deserializeAws_queryReorderReceiptRuleSetCommand = exports.deserializeAws_queryPutIdentityPolicyCommand = exports.deserializeAws_queryPutConfigurationSetDeliveryOptionsCommand = exports.deserializeAws_queryListVerifiedEmailAddressesCommand = exports.deserializeAws_queryListTemplatesCommand = exports.deserializeAws_queryListReceiptRuleSetsCommand = exports.deserializeAws_queryListReceiptFiltersCommand = exports.deserializeAws_queryListIdentityPoliciesCommand = exports.deserializeAws_queryListIdentitiesCommand = exports.deserializeAws_queryListCustomVerificationEmailTemplatesCommand = exports.deserializeAws_queryListConfigurationSetsCommand = exports.deserializeAws_queryGetTemplateCommand = exports.deserializeAws_queryGetSendStatisticsCommand = exports.deserializeAws_queryGetSendQuotaCommand = exports.deserializeAws_queryGetIdentityVerificationAttributesCommand = exports.deserializeAws_queryGetIdentityPoliciesCommand = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const smithy_client_1 = __webpack_require__(449);
            const entities_1 = __webpack_require__(364);
            const fast_xml_parser_1 = __webpack_require__(446);
            const models_0_1 = __webpack_require__(222);
            const SESServiceException_1 = __webpack_require__(353);
            const serializeAws_queryCloneReceiptRuleSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCloneReceiptRuleSetRequest(input, context),
                    Action: "CloneReceiptRuleSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCloneReceiptRuleSetCommand = serializeAws_queryCloneReceiptRuleSetCommand;
            const serializeAws_queryCreateConfigurationSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCreateConfigurationSetRequest(input, context),
                    Action: "CreateConfigurationSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCreateConfigurationSetCommand = serializeAws_queryCreateConfigurationSetCommand;
            const serializeAws_queryCreateConfigurationSetEventDestinationCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCreateConfigurationSetEventDestinationRequest(input, context),
                    Action: "CreateConfigurationSetEventDestination",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCreateConfigurationSetEventDestinationCommand = serializeAws_queryCreateConfigurationSetEventDestinationCommand;
            const serializeAws_queryCreateConfigurationSetTrackingOptionsCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCreateConfigurationSetTrackingOptionsRequest(input, context),
                    Action: "CreateConfigurationSetTrackingOptions",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCreateConfigurationSetTrackingOptionsCommand = serializeAws_queryCreateConfigurationSetTrackingOptionsCommand;
            const serializeAws_queryCreateCustomVerificationEmailTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCreateCustomVerificationEmailTemplateRequest(input, context),
                    Action: "CreateCustomVerificationEmailTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCreateCustomVerificationEmailTemplateCommand = serializeAws_queryCreateCustomVerificationEmailTemplateCommand;
            const serializeAws_queryCreateReceiptFilterCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCreateReceiptFilterRequest(input, context),
                    Action: "CreateReceiptFilter",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCreateReceiptFilterCommand = serializeAws_queryCreateReceiptFilterCommand;
            const serializeAws_queryCreateReceiptRuleCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCreateReceiptRuleRequest(input, context),
                    Action: "CreateReceiptRule",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCreateReceiptRuleCommand = serializeAws_queryCreateReceiptRuleCommand;
            const serializeAws_queryCreateReceiptRuleSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCreateReceiptRuleSetRequest(input, context),
                    Action: "CreateReceiptRuleSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCreateReceiptRuleSetCommand = serializeAws_queryCreateReceiptRuleSetCommand;
            const serializeAws_queryCreateTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryCreateTemplateRequest(input, context),
                    Action: "CreateTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryCreateTemplateCommand = serializeAws_queryCreateTemplateCommand;
            const serializeAws_queryDeleteConfigurationSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteConfigurationSetRequest(input, context),
                    Action: "DeleteConfigurationSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteConfigurationSetCommand = serializeAws_queryDeleteConfigurationSetCommand;
            const serializeAws_queryDeleteConfigurationSetEventDestinationCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteConfigurationSetEventDestinationRequest(input, context),
                    Action: "DeleteConfigurationSetEventDestination",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteConfigurationSetEventDestinationCommand = serializeAws_queryDeleteConfigurationSetEventDestinationCommand;
            const serializeAws_queryDeleteConfigurationSetTrackingOptionsCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteConfigurationSetTrackingOptionsRequest(input, context),
                    Action: "DeleteConfigurationSetTrackingOptions",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteConfigurationSetTrackingOptionsCommand = serializeAws_queryDeleteConfigurationSetTrackingOptionsCommand;
            const serializeAws_queryDeleteCustomVerificationEmailTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteCustomVerificationEmailTemplateRequest(input, context),
                    Action: "DeleteCustomVerificationEmailTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteCustomVerificationEmailTemplateCommand = serializeAws_queryDeleteCustomVerificationEmailTemplateCommand;
            const serializeAws_queryDeleteIdentityCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteIdentityRequest(input, context),
                    Action: "DeleteIdentity",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteIdentityCommand = serializeAws_queryDeleteIdentityCommand;
            const serializeAws_queryDeleteIdentityPolicyCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteIdentityPolicyRequest(input, context),
                    Action: "DeleteIdentityPolicy",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteIdentityPolicyCommand = serializeAws_queryDeleteIdentityPolicyCommand;
            const serializeAws_queryDeleteReceiptFilterCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteReceiptFilterRequest(input, context),
                    Action: "DeleteReceiptFilter",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteReceiptFilterCommand = serializeAws_queryDeleteReceiptFilterCommand;
            const serializeAws_queryDeleteReceiptRuleCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteReceiptRuleRequest(input, context),
                    Action: "DeleteReceiptRule",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteReceiptRuleCommand = serializeAws_queryDeleteReceiptRuleCommand;
            const serializeAws_queryDeleteReceiptRuleSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteReceiptRuleSetRequest(input, context),
                    Action: "DeleteReceiptRuleSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteReceiptRuleSetCommand = serializeAws_queryDeleteReceiptRuleSetCommand;
            const serializeAws_queryDeleteTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteTemplateRequest(input, context),
                    Action: "DeleteTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteTemplateCommand = serializeAws_queryDeleteTemplateCommand;
            const serializeAws_queryDeleteVerifiedEmailAddressCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDeleteVerifiedEmailAddressRequest(input, context),
                    Action: "DeleteVerifiedEmailAddress",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDeleteVerifiedEmailAddressCommand = serializeAws_queryDeleteVerifiedEmailAddressCommand;
            const serializeAws_queryDescribeActiveReceiptRuleSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDescribeActiveReceiptRuleSetRequest(input, context),
                    Action: "DescribeActiveReceiptRuleSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDescribeActiveReceiptRuleSetCommand = serializeAws_queryDescribeActiveReceiptRuleSetCommand;
            const serializeAws_queryDescribeConfigurationSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDescribeConfigurationSetRequest(input, context),
                    Action: "DescribeConfigurationSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDescribeConfigurationSetCommand = serializeAws_queryDescribeConfigurationSetCommand;
            const serializeAws_queryDescribeReceiptRuleCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDescribeReceiptRuleRequest(input, context),
                    Action: "DescribeReceiptRule",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDescribeReceiptRuleCommand = serializeAws_queryDescribeReceiptRuleCommand;
            const serializeAws_queryDescribeReceiptRuleSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryDescribeReceiptRuleSetRequest(input, context),
                    Action: "DescribeReceiptRuleSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryDescribeReceiptRuleSetCommand = serializeAws_queryDescribeReceiptRuleSetCommand;
            const serializeAws_queryGetAccountSendingEnabledCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                const body = buildFormUrlencodedString({
                    Action: "GetAccountSendingEnabled",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetAccountSendingEnabledCommand = serializeAws_queryGetAccountSendingEnabledCommand;
            const serializeAws_queryGetCustomVerificationEmailTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetCustomVerificationEmailTemplateRequest(input, context),
                    Action: "GetCustomVerificationEmailTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetCustomVerificationEmailTemplateCommand = serializeAws_queryGetCustomVerificationEmailTemplateCommand;
            const serializeAws_queryGetIdentityDkimAttributesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetIdentityDkimAttributesRequest(input, context),
                    Action: "GetIdentityDkimAttributes",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetIdentityDkimAttributesCommand = serializeAws_queryGetIdentityDkimAttributesCommand;
            const serializeAws_queryGetIdentityMailFromDomainAttributesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetIdentityMailFromDomainAttributesRequest(input, context),
                    Action: "GetIdentityMailFromDomainAttributes",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetIdentityMailFromDomainAttributesCommand = serializeAws_queryGetIdentityMailFromDomainAttributesCommand;
            const serializeAws_queryGetIdentityNotificationAttributesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetIdentityNotificationAttributesRequest(input, context),
                    Action: "GetIdentityNotificationAttributes",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetIdentityNotificationAttributesCommand = serializeAws_queryGetIdentityNotificationAttributesCommand;
            const serializeAws_queryGetIdentityPoliciesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetIdentityPoliciesRequest(input, context),
                    Action: "GetIdentityPolicies",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetIdentityPoliciesCommand = serializeAws_queryGetIdentityPoliciesCommand;
            const serializeAws_queryGetIdentityVerificationAttributesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetIdentityVerificationAttributesRequest(input, context),
                    Action: "GetIdentityVerificationAttributes",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetIdentityVerificationAttributesCommand = serializeAws_queryGetIdentityVerificationAttributesCommand;
            const serializeAws_queryGetSendQuotaCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                const body = buildFormUrlencodedString({
                    Action: "GetSendQuota",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetSendQuotaCommand = serializeAws_queryGetSendQuotaCommand;
            const serializeAws_queryGetSendStatisticsCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                const body = buildFormUrlencodedString({
                    Action: "GetSendStatistics",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetSendStatisticsCommand = serializeAws_queryGetSendStatisticsCommand;
            const serializeAws_queryGetTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryGetTemplateRequest(input, context),
                    Action: "GetTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryGetTemplateCommand = serializeAws_queryGetTemplateCommand;
            const serializeAws_queryListConfigurationSetsCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryListConfigurationSetsRequest(input, context),
                    Action: "ListConfigurationSets",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryListConfigurationSetsCommand = serializeAws_queryListConfigurationSetsCommand;
            const serializeAws_queryListCustomVerificationEmailTemplatesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryListCustomVerificationEmailTemplatesRequest(input, context),
                    Action: "ListCustomVerificationEmailTemplates",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryListCustomVerificationEmailTemplatesCommand = serializeAws_queryListCustomVerificationEmailTemplatesCommand;
            const serializeAws_queryListIdentitiesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryListIdentitiesRequest(input, context),
                    Action: "ListIdentities",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryListIdentitiesCommand = serializeAws_queryListIdentitiesCommand;
            const serializeAws_queryListIdentityPoliciesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryListIdentityPoliciesRequest(input, context),
                    Action: "ListIdentityPolicies",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryListIdentityPoliciesCommand = serializeAws_queryListIdentityPoliciesCommand;
            const serializeAws_queryListReceiptFiltersCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryListReceiptFiltersRequest(input, context),
                    Action: "ListReceiptFilters",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryListReceiptFiltersCommand = serializeAws_queryListReceiptFiltersCommand;
            const serializeAws_queryListReceiptRuleSetsCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryListReceiptRuleSetsRequest(input, context),
                    Action: "ListReceiptRuleSets",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryListReceiptRuleSetsCommand = serializeAws_queryListReceiptRuleSetsCommand;
            const serializeAws_queryListTemplatesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryListTemplatesRequest(input, context),
                    Action: "ListTemplates",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryListTemplatesCommand = serializeAws_queryListTemplatesCommand;
            const serializeAws_queryListVerifiedEmailAddressesCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                const body = buildFormUrlencodedString({
                    Action: "ListVerifiedEmailAddresses",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryListVerifiedEmailAddressesCommand = serializeAws_queryListVerifiedEmailAddressesCommand;
            const serializeAws_queryPutConfigurationSetDeliveryOptionsCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryPutConfigurationSetDeliveryOptionsRequest(input, context),
                    Action: "PutConfigurationSetDeliveryOptions",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryPutConfigurationSetDeliveryOptionsCommand = serializeAws_queryPutConfigurationSetDeliveryOptionsCommand;
            const serializeAws_queryPutIdentityPolicyCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryPutIdentityPolicyRequest(input, context),
                    Action: "PutIdentityPolicy",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryPutIdentityPolicyCommand = serializeAws_queryPutIdentityPolicyCommand;
            const serializeAws_queryReorderReceiptRuleSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryReorderReceiptRuleSetRequest(input, context),
                    Action: "ReorderReceiptRuleSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryReorderReceiptRuleSetCommand = serializeAws_queryReorderReceiptRuleSetCommand;
            const serializeAws_querySendBounceCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySendBounceRequest(input, context),
                    Action: "SendBounce",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySendBounceCommand = serializeAws_querySendBounceCommand;
            const serializeAws_querySendBulkTemplatedEmailCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySendBulkTemplatedEmailRequest(input, context),
                    Action: "SendBulkTemplatedEmail",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySendBulkTemplatedEmailCommand = serializeAws_querySendBulkTemplatedEmailCommand;
            const serializeAws_querySendCustomVerificationEmailCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySendCustomVerificationEmailRequest(input, context),
                    Action: "SendCustomVerificationEmail",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySendCustomVerificationEmailCommand = serializeAws_querySendCustomVerificationEmailCommand;
            const serializeAws_querySendEmailCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySendEmailRequest(input, context),
                    Action: "SendEmail",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySendEmailCommand = serializeAws_querySendEmailCommand;
            const serializeAws_querySendRawEmailCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySendRawEmailRequest(input, context),
                    Action: "SendRawEmail",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySendRawEmailCommand = serializeAws_querySendRawEmailCommand;
            const serializeAws_querySendTemplatedEmailCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySendTemplatedEmailRequest(input, context),
                    Action: "SendTemplatedEmail",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySendTemplatedEmailCommand = serializeAws_querySendTemplatedEmailCommand;
            const serializeAws_querySetActiveReceiptRuleSetCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySetActiveReceiptRuleSetRequest(input, context),
                    Action: "SetActiveReceiptRuleSet",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySetActiveReceiptRuleSetCommand = serializeAws_querySetActiveReceiptRuleSetCommand;
            const serializeAws_querySetIdentityDkimEnabledCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySetIdentityDkimEnabledRequest(input, context),
                    Action: "SetIdentityDkimEnabled",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySetIdentityDkimEnabledCommand = serializeAws_querySetIdentityDkimEnabledCommand;
            const serializeAws_querySetIdentityFeedbackForwardingEnabledCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySetIdentityFeedbackForwardingEnabledRequest(input, context),
                    Action: "SetIdentityFeedbackForwardingEnabled",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySetIdentityFeedbackForwardingEnabledCommand = serializeAws_querySetIdentityFeedbackForwardingEnabledCommand;
            const serializeAws_querySetIdentityHeadersInNotificationsEnabledCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySetIdentityHeadersInNotificationsEnabledRequest(input, context),
                    Action: "SetIdentityHeadersInNotificationsEnabled",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySetIdentityHeadersInNotificationsEnabledCommand = serializeAws_querySetIdentityHeadersInNotificationsEnabledCommand;
            const serializeAws_querySetIdentityMailFromDomainCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySetIdentityMailFromDomainRequest(input, context),
                    Action: "SetIdentityMailFromDomain",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySetIdentityMailFromDomainCommand = serializeAws_querySetIdentityMailFromDomainCommand;
            const serializeAws_querySetIdentityNotificationTopicCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySetIdentityNotificationTopicRequest(input, context),
                    Action: "SetIdentityNotificationTopic",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySetIdentityNotificationTopicCommand = serializeAws_querySetIdentityNotificationTopicCommand;
            const serializeAws_querySetReceiptRulePositionCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_querySetReceiptRulePositionRequest(input, context),
                    Action: "SetReceiptRulePosition",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_querySetReceiptRulePositionCommand = serializeAws_querySetReceiptRulePositionCommand;
            const serializeAws_queryTestRenderTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryTestRenderTemplateRequest(input, context),
                    Action: "TestRenderTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryTestRenderTemplateCommand = serializeAws_queryTestRenderTemplateCommand;
            const serializeAws_queryUpdateAccountSendingEnabledCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryUpdateAccountSendingEnabledRequest(input, context),
                    Action: "UpdateAccountSendingEnabled",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryUpdateAccountSendingEnabledCommand = serializeAws_queryUpdateAccountSendingEnabledCommand;
            const serializeAws_queryUpdateConfigurationSetEventDestinationCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryUpdateConfigurationSetEventDestinationRequest(input, context),
                    Action: "UpdateConfigurationSetEventDestination",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryUpdateConfigurationSetEventDestinationCommand = serializeAws_queryUpdateConfigurationSetEventDestinationCommand;
            const serializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryUpdateConfigurationSetReputationMetricsEnabledRequest(input, context),
                    Action: "UpdateConfigurationSetReputationMetricsEnabled",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand = serializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand;
            const serializeAws_queryUpdateConfigurationSetSendingEnabledCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryUpdateConfigurationSetSendingEnabledRequest(input, context),
                    Action: "UpdateConfigurationSetSendingEnabled",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryUpdateConfigurationSetSendingEnabledCommand = serializeAws_queryUpdateConfigurationSetSendingEnabledCommand;
            const serializeAws_queryUpdateConfigurationSetTrackingOptionsCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryUpdateConfigurationSetTrackingOptionsRequest(input, context),
                    Action: "UpdateConfigurationSetTrackingOptions",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryUpdateConfigurationSetTrackingOptionsCommand = serializeAws_queryUpdateConfigurationSetTrackingOptionsCommand;
            const serializeAws_queryUpdateCustomVerificationEmailTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryUpdateCustomVerificationEmailTemplateRequest(input, context),
                    Action: "UpdateCustomVerificationEmailTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryUpdateCustomVerificationEmailTemplateCommand = serializeAws_queryUpdateCustomVerificationEmailTemplateCommand;
            const serializeAws_queryUpdateReceiptRuleCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryUpdateReceiptRuleRequest(input, context),
                    Action: "UpdateReceiptRule",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryUpdateReceiptRuleCommand = serializeAws_queryUpdateReceiptRuleCommand;
            const serializeAws_queryUpdateTemplateCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryUpdateTemplateRequest(input, context),
                    Action: "UpdateTemplate",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryUpdateTemplateCommand = serializeAws_queryUpdateTemplateCommand;
            const serializeAws_queryVerifyDomainDkimCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryVerifyDomainDkimRequest(input, context),
                    Action: "VerifyDomainDkim",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryVerifyDomainDkimCommand = serializeAws_queryVerifyDomainDkimCommand;
            const serializeAws_queryVerifyDomainIdentityCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryVerifyDomainIdentityRequest(input, context),
                    Action: "VerifyDomainIdentity",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryVerifyDomainIdentityCommand = serializeAws_queryVerifyDomainIdentityCommand;
            const serializeAws_queryVerifyEmailAddressCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryVerifyEmailAddressRequest(input, context),
                    Action: "VerifyEmailAddress",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryVerifyEmailAddressCommand = serializeAws_queryVerifyEmailAddressCommand;
            const serializeAws_queryVerifyEmailIdentityCommand = async (input, context) => {
                const headers = {
                    "content-type": "application/x-www-form-urlencoded",
                };
                let body;
                body = buildFormUrlencodedString({
                    ...serializeAws_queryVerifyEmailIdentityRequest(input, context),
                    Action: "VerifyEmailIdentity",
                    Version: "2010-12-01",
                });
                return buildHttpRpcRequest(context, headers, "/", undefined, body);
            };
            exports.serializeAws_queryVerifyEmailIdentityCommand = serializeAws_queryVerifyEmailIdentityCommand;
            const deserializeAws_queryCloneReceiptRuleSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCloneReceiptRuleSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryCloneReceiptRuleSetResponse(data.CloneReceiptRuleSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCloneReceiptRuleSetCommand = deserializeAws_queryCloneReceiptRuleSetCommand;
            const deserializeAws_queryCloneReceiptRuleSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AlreadyExistsException":
                    case "com.amazonaws.ses#AlreadyExistsException":
                        throw await deserializeAws_queryAlreadyExistsExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryCreateConfigurationSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCreateConfigurationSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryCreateConfigurationSetResponse(data.CreateConfigurationSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCreateConfigurationSetCommand = deserializeAws_queryCreateConfigurationSetCommand;
            const deserializeAws_queryCreateConfigurationSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetAlreadyExistsException":
                    case "com.amazonaws.ses#ConfigurationSetAlreadyExistsException":
                        throw await deserializeAws_queryConfigurationSetAlreadyExistsExceptionResponse(parsedOutput, context);
                    case "InvalidConfigurationSetException":
                    case "com.amazonaws.ses#InvalidConfigurationSetException":
                        throw await deserializeAws_queryInvalidConfigurationSetExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryCreateConfigurationSetEventDestinationCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCreateConfigurationSetEventDestinationCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryCreateConfigurationSetEventDestinationResponse(data.CreateConfigurationSetEventDestinationResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCreateConfigurationSetEventDestinationCommand = deserializeAws_queryCreateConfigurationSetEventDestinationCommand;
            const deserializeAws_queryCreateConfigurationSetEventDestinationCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "EventDestinationAlreadyExistsException":
                    case "com.amazonaws.ses#EventDestinationAlreadyExistsException":
                        throw await deserializeAws_queryEventDestinationAlreadyExistsExceptionResponse(parsedOutput, context);
                    case "InvalidCloudWatchDestinationException":
                    case "com.amazonaws.ses#InvalidCloudWatchDestinationException":
                        throw await deserializeAws_queryInvalidCloudWatchDestinationExceptionResponse(parsedOutput, context);
                    case "InvalidFirehoseDestinationException":
                    case "com.amazonaws.ses#InvalidFirehoseDestinationException":
                        throw await deserializeAws_queryInvalidFirehoseDestinationExceptionResponse(parsedOutput, context);
                    case "InvalidSNSDestinationException":
                    case "com.amazonaws.ses#InvalidSNSDestinationException":
                        throw await deserializeAws_queryInvalidSNSDestinationExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryCreateConfigurationSetTrackingOptionsCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCreateConfigurationSetTrackingOptionsCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryCreateConfigurationSetTrackingOptionsResponse(data.CreateConfigurationSetTrackingOptionsResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCreateConfigurationSetTrackingOptionsCommand = deserializeAws_queryCreateConfigurationSetTrackingOptionsCommand;
            const deserializeAws_queryCreateConfigurationSetTrackingOptionsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "InvalidTrackingOptionsException":
                    case "com.amazonaws.ses#InvalidTrackingOptionsException":
                        throw await deserializeAws_queryInvalidTrackingOptionsExceptionResponse(parsedOutput, context);
                    case "TrackingOptionsAlreadyExistsException":
                    case "com.amazonaws.ses#TrackingOptionsAlreadyExistsException":
                        throw await deserializeAws_queryTrackingOptionsAlreadyExistsExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryCreateCustomVerificationEmailTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCreateCustomVerificationEmailTemplateCommandError(output, context);
                }
                await collectBody(output.body, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCreateCustomVerificationEmailTemplateCommand = deserializeAws_queryCreateCustomVerificationEmailTemplateCommand;
            const deserializeAws_queryCreateCustomVerificationEmailTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "CustomVerificationEmailInvalidContentException":
                    case "com.amazonaws.ses#CustomVerificationEmailInvalidContentException":
                        throw await deserializeAws_queryCustomVerificationEmailInvalidContentExceptionResponse(parsedOutput, context);
                    case "CustomVerificationEmailTemplateAlreadyExistsException":
                    case "com.amazonaws.ses#CustomVerificationEmailTemplateAlreadyExistsException":
                        throw await deserializeAws_queryCustomVerificationEmailTemplateAlreadyExistsExceptionResponse(parsedOutput, context);
                    case "FromEmailAddressNotVerifiedException":
                    case "com.amazonaws.ses#FromEmailAddressNotVerifiedException":
                        throw await deserializeAws_queryFromEmailAddressNotVerifiedExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryCreateReceiptFilterCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCreateReceiptFilterCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryCreateReceiptFilterResponse(data.CreateReceiptFilterResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCreateReceiptFilterCommand = deserializeAws_queryCreateReceiptFilterCommand;
            const deserializeAws_queryCreateReceiptFilterCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AlreadyExistsException":
                    case "com.amazonaws.ses#AlreadyExistsException":
                        throw await deserializeAws_queryAlreadyExistsExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryCreateReceiptRuleCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCreateReceiptRuleCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryCreateReceiptRuleResponse(data.CreateReceiptRuleResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCreateReceiptRuleCommand = deserializeAws_queryCreateReceiptRuleCommand;
            const deserializeAws_queryCreateReceiptRuleCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AlreadyExistsException":
                    case "com.amazonaws.ses#AlreadyExistsException":
                        throw await deserializeAws_queryAlreadyExistsExceptionResponse(parsedOutput, context);
                    case "InvalidLambdaFunctionException":
                    case "com.amazonaws.ses#InvalidLambdaFunctionException":
                        throw await deserializeAws_queryInvalidLambdaFunctionExceptionResponse(parsedOutput, context);
                    case "InvalidS3ConfigurationException":
                    case "com.amazonaws.ses#InvalidS3ConfigurationException":
                        throw await deserializeAws_queryInvalidS3ConfigurationExceptionResponse(parsedOutput, context);
                    case "InvalidSnsTopicException":
                    case "com.amazonaws.ses#InvalidSnsTopicException":
                        throw await deserializeAws_queryInvalidSnsTopicExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    case "RuleDoesNotExistException":
                    case "com.amazonaws.ses#RuleDoesNotExistException":
                        throw await deserializeAws_queryRuleDoesNotExistExceptionResponse(parsedOutput, context);
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryCreateReceiptRuleSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCreateReceiptRuleSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryCreateReceiptRuleSetResponse(data.CreateReceiptRuleSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCreateReceiptRuleSetCommand = deserializeAws_queryCreateReceiptRuleSetCommand;
            const deserializeAws_queryCreateReceiptRuleSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AlreadyExistsException":
                    case "com.amazonaws.ses#AlreadyExistsException":
                        throw await deserializeAws_queryAlreadyExistsExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryCreateTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryCreateTemplateCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryCreateTemplateResponse(data.CreateTemplateResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryCreateTemplateCommand = deserializeAws_queryCreateTemplateCommand;
            const deserializeAws_queryCreateTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AlreadyExistsException":
                    case "com.amazonaws.ses#AlreadyExistsException":
                        throw await deserializeAws_queryAlreadyExistsExceptionResponse(parsedOutput, context);
                    case "InvalidTemplateException":
                    case "com.amazonaws.ses#InvalidTemplateException":
                        throw await deserializeAws_queryInvalidTemplateExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteConfigurationSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteConfigurationSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteConfigurationSetResponse(data.DeleteConfigurationSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteConfigurationSetCommand = deserializeAws_queryDeleteConfigurationSetCommand;
            const deserializeAws_queryDeleteConfigurationSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteConfigurationSetEventDestinationCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteConfigurationSetEventDestinationCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteConfigurationSetEventDestinationResponse(data.DeleteConfigurationSetEventDestinationResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteConfigurationSetEventDestinationCommand = deserializeAws_queryDeleteConfigurationSetEventDestinationCommand;
            const deserializeAws_queryDeleteConfigurationSetEventDestinationCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "EventDestinationDoesNotExistException":
                    case "com.amazonaws.ses#EventDestinationDoesNotExistException":
                        throw await deserializeAws_queryEventDestinationDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteConfigurationSetTrackingOptionsCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteConfigurationSetTrackingOptionsCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteConfigurationSetTrackingOptionsResponse(data.DeleteConfigurationSetTrackingOptionsResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteConfigurationSetTrackingOptionsCommand = deserializeAws_queryDeleteConfigurationSetTrackingOptionsCommand;
            const deserializeAws_queryDeleteConfigurationSetTrackingOptionsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "TrackingOptionsDoesNotExistException":
                    case "com.amazonaws.ses#TrackingOptionsDoesNotExistException":
                        throw await deserializeAws_queryTrackingOptionsDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteCustomVerificationEmailTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteCustomVerificationEmailTemplateCommandError(output, context);
                }
                await collectBody(output.body, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteCustomVerificationEmailTemplateCommand = deserializeAws_queryDeleteCustomVerificationEmailTemplateCommand;
            const deserializeAws_queryDeleteCustomVerificationEmailTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteIdentityCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteIdentityCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteIdentityResponse(data.DeleteIdentityResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteIdentityCommand = deserializeAws_queryDeleteIdentityCommand;
            const deserializeAws_queryDeleteIdentityCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteIdentityPolicyCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteIdentityPolicyCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteIdentityPolicyResponse(data.DeleteIdentityPolicyResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteIdentityPolicyCommand = deserializeAws_queryDeleteIdentityPolicyCommand;
            const deserializeAws_queryDeleteIdentityPolicyCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteReceiptFilterCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteReceiptFilterCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteReceiptFilterResponse(data.DeleteReceiptFilterResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteReceiptFilterCommand = deserializeAws_queryDeleteReceiptFilterCommand;
            const deserializeAws_queryDeleteReceiptFilterCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteReceiptRuleCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteReceiptRuleCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteReceiptRuleResponse(data.DeleteReceiptRuleResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteReceiptRuleCommand = deserializeAws_queryDeleteReceiptRuleCommand;
            const deserializeAws_queryDeleteReceiptRuleCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteReceiptRuleSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteReceiptRuleSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteReceiptRuleSetResponse(data.DeleteReceiptRuleSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteReceiptRuleSetCommand = deserializeAws_queryDeleteReceiptRuleSetCommand;
            const deserializeAws_queryDeleteReceiptRuleSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "CannotDeleteException":
                    case "com.amazonaws.ses#CannotDeleteException":
                        throw await deserializeAws_queryCannotDeleteExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteTemplateCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDeleteTemplateResponse(data.DeleteTemplateResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteTemplateCommand = deserializeAws_queryDeleteTemplateCommand;
            const deserializeAws_queryDeleteTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDeleteVerifiedEmailAddressCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDeleteVerifiedEmailAddressCommandError(output, context);
                }
                await collectBody(output.body, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDeleteVerifiedEmailAddressCommand = deserializeAws_queryDeleteVerifiedEmailAddressCommand;
            const deserializeAws_queryDeleteVerifiedEmailAddressCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDescribeActiveReceiptRuleSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDescribeActiveReceiptRuleSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDescribeActiveReceiptRuleSetResponse(data.DescribeActiveReceiptRuleSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDescribeActiveReceiptRuleSetCommand = deserializeAws_queryDescribeActiveReceiptRuleSetCommand;
            const deserializeAws_queryDescribeActiveReceiptRuleSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDescribeConfigurationSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDescribeConfigurationSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDescribeConfigurationSetResponse(data.DescribeConfigurationSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDescribeConfigurationSetCommand = deserializeAws_queryDescribeConfigurationSetCommand;
            const deserializeAws_queryDescribeConfigurationSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDescribeReceiptRuleCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDescribeReceiptRuleCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDescribeReceiptRuleResponse(data.DescribeReceiptRuleResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDescribeReceiptRuleCommand = deserializeAws_queryDescribeReceiptRuleCommand;
            const deserializeAws_queryDescribeReceiptRuleCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "RuleDoesNotExistException":
                    case "com.amazonaws.ses#RuleDoesNotExistException":
                        throw await deserializeAws_queryRuleDoesNotExistExceptionResponse(parsedOutput, context);
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryDescribeReceiptRuleSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryDescribeReceiptRuleSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryDescribeReceiptRuleSetResponse(data.DescribeReceiptRuleSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryDescribeReceiptRuleSetCommand = deserializeAws_queryDescribeReceiptRuleSetCommand;
            const deserializeAws_queryDescribeReceiptRuleSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetAccountSendingEnabledCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetAccountSendingEnabledCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetAccountSendingEnabledResponse(data.GetAccountSendingEnabledResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetAccountSendingEnabledCommand = deserializeAws_queryGetAccountSendingEnabledCommand;
            const deserializeAws_queryGetAccountSendingEnabledCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetCustomVerificationEmailTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetCustomVerificationEmailTemplateCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetCustomVerificationEmailTemplateResponse(data.GetCustomVerificationEmailTemplateResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetCustomVerificationEmailTemplateCommand = deserializeAws_queryGetCustomVerificationEmailTemplateCommand;
            const deserializeAws_queryGetCustomVerificationEmailTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "CustomVerificationEmailTemplateDoesNotExistException":
                    case "com.amazonaws.ses#CustomVerificationEmailTemplateDoesNotExistException":
                        throw await deserializeAws_queryCustomVerificationEmailTemplateDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetIdentityDkimAttributesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetIdentityDkimAttributesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetIdentityDkimAttributesResponse(data.GetIdentityDkimAttributesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetIdentityDkimAttributesCommand = deserializeAws_queryGetIdentityDkimAttributesCommand;
            const deserializeAws_queryGetIdentityDkimAttributesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetIdentityMailFromDomainAttributesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetIdentityMailFromDomainAttributesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetIdentityMailFromDomainAttributesResponse(data.GetIdentityMailFromDomainAttributesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetIdentityMailFromDomainAttributesCommand = deserializeAws_queryGetIdentityMailFromDomainAttributesCommand;
            const deserializeAws_queryGetIdentityMailFromDomainAttributesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetIdentityNotificationAttributesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetIdentityNotificationAttributesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetIdentityNotificationAttributesResponse(data.GetIdentityNotificationAttributesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetIdentityNotificationAttributesCommand = deserializeAws_queryGetIdentityNotificationAttributesCommand;
            const deserializeAws_queryGetIdentityNotificationAttributesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetIdentityPoliciesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetIdentityPoliciesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetIdentityPoliciesResponse(data.GetIdentityPoliciesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetIdentityPoliciesCommand = deserializeAws_queryGetIdentityPoliciesCommand;
            const deserializeAws_queryGetIdentityPoliciesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetIdentityVerificationAttributesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetIdentityVerificationAttributesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetIdentityVerificationAttributesResponse(data.GetIdentityVerificationAttributesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetIdentityVerificationAttributesCommand = deserializeAws_queryGetIdentityVerificationAttributesCommand;
            const deserializeAws_queryGetIdentityVerificationAttributesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetSendQuotaCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetSendQuotaCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetSendQuotaResponse(data.GetSendQuotaResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetSendQuotaCommand = deserializeAws_queryGetSendQuotaCommand;
            const deserializeAws_queryGetSendQuotaCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetSendStatisticsCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetSendStatisticsCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetSendStatisticsResponse(data.GetSendStatisticsResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetSendStatisticsCommand = deserializeAws_queryGetSendStatisticsCommand;
            const deserializeAws_queryGetSendStatisticsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryGetTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryGetTemplateCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryGetTemplateResponse(data.GetTemplateResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryGetTemplateCommand = deserializeAws_queryGetTemplateCommand;
            const deserializeAws_queryGetTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "TemplateDoesNotExistException":
                    case "com.amazonaws.ses#TemplateDoesNotExistException":
                        throw await deserializeAws_queryTemplateDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryListConfigurationSetsCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryListConfigurationSetsCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryListConfigurationSetsResponse(data.ListConfigurationSetsResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryListConfigurationSetsCommand = deserializeAws_queryListConfigurationSetsCommand;
            const deserializeAws_queryListConfigurationSetsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryListCustomVerificationEmailTemplatesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryListCustomVerificationEmailTemplatesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryListCustomVerificationEmailTemplatesResponse(data.ListCustomVerificationEmailTemplatesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryListCustomVerificationEmailTemplatesCommand = deserializeAws_queryListCustomVerificationEmailTemplatesCommand;
            const deserializeAws_queryListCustomVerificationEmailTemplatesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryListIdentitiesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryListIdentitiesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryListIdentitiesResponse(data.ListIdentitiesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryListIdentitiesCommand = deserializeAws_queryListIdentitiesCommand;
            const deserializeAws_queryListIdentitiesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryListIdentityPoliciesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryListIdentityPoliciesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryListIdentityPoliciesResponse(data.ListIdentityPoliciesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryListIdentityPoliciesCommand = deserializeAws_queryListIdentityPoliciesCommand;
            const deserializeAws_queryListIdentityPoliciesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryListReceiptFiltersCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryListReceiptFiltersCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryListReceiptFiltersResponse(data.ListReceiptFiltersResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryListReceiptFiltersCommand = deserializeAws_queryListReceiptFiltersCommand;
            const deserializeAws_queryListReceiptFiltersCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryListReceiptRuleSetsCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryListReceiptRuleSetsCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryListReceiptRuleSetsResponse(data.ListReceiptRuleSetsResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryListReceiptRuleSetsCommand = deserializeAws_queryListReceiptRuleSetsCommand;
            const deserializeAws_queryListReceiptRuleSetsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryListTemplatesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryListTemplatesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryListTemplatesResponse(data.ListTemplatesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryListTemplatesCommand = deserializeAws_queryListTemplatesCommand;
            const deserializeAws_queryListTemplatesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryListVerifiedEmailAddressesCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryListVerifiedEmailAddressesCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryListVerifiedEmailAddressesResponse(data.ListVerifiedEmailAddressesResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryListVerifiedEmailAddressesCommand = deserializeAws_queryListVerifiedEmailAddressesCommand;
            const deserializeAws_queryListVerifiedEmailAddressesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryPutConfigurationSetDeliveryOptionsCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryPutConfigurationSetDeliveryOptionsCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryPutConfigurationSetDeliveryOptionsResponse(data.PutConfigurationSetDeliveryOptionsResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryPutConfigurationSetDeliveryOptionsCommand = deserializeAws_queryPutConfigurationSetDeliveryOptionsCommand;
            const deserializeAws_queryPutConfigurationSetDeliveryOptionsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "InvalidDeliveryOptionsException":
                    case "com.amazonaws.ses#InvalidDeliveryOptionsException":
                        throw await deserializeAws_queryInvalidDeliveryOptionsExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryPutIdentityPolicyCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryPutIdentityPolicyCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryPutIdentityPolicyResponse(data.PutIdentityPolicyResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryPutIdentityPolicyCommand = deserializeAws_queryPutIdentityPolicyCommand;
            const deserializeAws_queryPutIdentityPolicyCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidPolicyException":
                    case "com.amazonaws.ses#InvalidPolicyException":
                        throw await deserializeAws_queryInvalidPolicyExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryReorderReceiptRuleSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryReorderReceiptRuleSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryReorderReceiptRuleSetResponse(data.ReorderReceiptRuleSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryReorderReceiptRuleSetCommand = deserializeAws_queryReorderReceiptRuleSetCommand;
            const deserializeAws_queryReorderReceiptRuleSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "RuleDoesNotExistException":
                    case "com.amazonaws.ses#RuleDoesNotExistException":
                        throw await deserializeAws_queryRuleDoesNotExistExceptionResponse(parsedOutput, context);
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySendBounceCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySendBounceCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySendBounceResponse(data.SendBounceResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySendBounceCommand = deserializeAws_querySendBounceCommand;
            const deserializeAws_querySendBounceCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "MessageRejected":
                    case "com.amazonaws.ses#MessageRejected":
                        throw await deserializeAws_queryMessageRejectedResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySendBulkTemplatedEmailCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySendBulkTemplatedEmailCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySendBulkTemplatedEmailResponse(data.SendBulkTemplatedEmailResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySendBulkTemplatedEmailCommand = deserializeAws_querySendBulkTemplatedEmailCommand;
            const deserializeAws_querySendBulkTemplatedEmailCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AccountSendingPausedException":
                    case "com.amazonaws.ses#AccountSendingPausedException":
                        throw await deserializeAws_queryAccountSendingPausedExceptionResponse(parsedOutput, context);
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "ConfigurationSetSendingPausedException":
                    case "com.amazonaws.ses#ConfigurationSetSendingPausedException":
                        throw await deserializeAws_queryConfigurationSetSendingPausedExceptionResponse(parsedOutput, context);
                    case "MailFromDomainNotVerifiedException":
                    case "com.amazonaws.ses#MailFromDomainNotVerifiedException":
                        throw await deserializeAws_queryMailFromDomainNotVerifiedExceptionResponse(parsedOutput, context);
                    case "MessageRejected":
                    case "com.amazonaws.ses#MessageRejected":
                        throw await deserializeAws_queryMessageRejectedResponse(parsedOutput, context);
                    case "TemplateDoesNotExistException":
                    case "com.amazonaws.ses#TemplateDoesNotExistException":
                        throw await deserializeAws_queryTemplateDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySendCustomVerificationEmailCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySendCustomVerificationEmailCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySendCustomVerificationEmailResponse(data.SendCustomVerificationEmailResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySendCustomVerificationEmailCommand = deserializeAws_querySendCustomVerificationEmailCommand;
            const deserializeAws_querySendCustomVerificationEmailCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "CustomVerificationEmailTemplateDoesNotExistException":
                    case "com.amazonaws.ses#CustomVerificationEmailTemplateDoesNotExistException":
                        throw await deserializeAws_queryCustomVerificationEmailTemplateDoesNotExistExceptionResponse(parsedOutput, context);
                    case "FromEmailAddressNotVerifiedException":
                    case "com.amazonaws.ses#FromEmailAddressNotVerifiedException":
                        throw await deserializeAws_queryFromEmailAddressNotVerifiedExceptionResponse(parsedOutput, context);
                    case "MessageRejected":
                    case "com.amazonaws.ses#MessageRejected":
                        throw await deserializeAws_queryMessageRejectedResponse(parsedOutput, context);
                    case "ProductionAccessNotGrantedException":
                    case "com.amazonaws.ses#ProductionAccessNotGrantedException":
                        throw await deserializeAws_queryProductionAccessNotGrantedExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySendEmailCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySendEmailCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySendEmailResponse(data.SendEmailResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySendEmailCommand = deserializeAws_querySendEmailCommand;
            const deserializeAws_querySendEmailCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AccountSendingPausedException":
                    case "com.amazonaws.ses#AccountSendingPausedException":
                        throw await deserializeAws_queryAccountSendingPausedExceptionResponse(parsedOutput, context);
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "ConfigurationSetSendingPausedException":
                    case "com.amazonaws.ses#ConfigurationSetSendingPausedException":
                        throw await deserializeAws_queryConfigurationSetSendingPausedExceptionResponse(parsedOutput, context);
                    case "MailFromDomainNotVerifiedException":
                    case "com.amazonaws.ses#MailFromDomainNotVerifiedException":
                        throw await deserializeAws_queryMailFromDomainNotVerifiedExceptionResponse(parsedOutput, context);
                    case "MessageRejected":
                    case "com.amazonaws.ses#MessageRejected":
                        throw await deserializeAws_queryMessageRejectedResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySendRawEmailCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySendRawEmailCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySendRawEmailResponse(data.SendRawEmailResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySendRawEmailCommand = deserializeAws_querySendRawEmailCommand;
            const deserializeAws_querySendRawEmailCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AccountSendingPausedException":
                    case "com.amazonaws.ses#AccountSendingPausedException":
                        throw await deserializeAws_queryAccountSendingPausedExceptionResponse(parsedOutput, context);
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "ConfigurationSetSendingPausedException":
                    case "com.amazonaws.ses#ConfigurationSetSendingPausedException":
                        throw await deserializeAws_queryConfigurationSetSendingPausedExceptionResponse(parsedOutput, context);
                    case "MailFromDomainNotVerifiedException":
                    case "com.amazonaws.ses#MailFromDomainNotVerifiedException":
                        throw await deserializeAws_queryMailFromDomainNotVerifiedExceptionResponse(parsedOutput, context);
                    case "MessageRejected":
                    case "com.amazonaws.ses#MessageRejected":
                        throw await deserializeAws_queryMessageRejectedResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySendTemplatedEmailCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySendTemplatedEmailCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySendTemplatedEmailResponse(data.SendTemplatedEmailResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySendTemplatedEmailCommand = deserializeAws_querySendTemplatedEmailCommand;
            const deserializeAws_querySendTemplatedEmailCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "AccountSendingPausedException":
                    case "com.amazonaws.ses#AccountSendingPausedException":
                        throw await deserializeAws_queryAccountSendingPausedExceptionResponse(parsedOutput, context);
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "ConfigurationSetSendingPausedException":
                    case "com.amazonaws.ses#ConfigurationSetSendingPausedException":
                        throw await deserializeAws_queryConfigurationSetSendingPausedExceptionResponse(parsedOutput, context);
                    case "MailFromDomainNotVerifiedException":
                    case "com.amazonaws.ses#MailFromDomainNotVerifiedException":
                        throw await deserializeAws_queryMailFromDomainNotVerifiedExceptionResponse(parsedOutput, context);
                    case "MessageRejected":
                    case "com.amazonaws.ses#MessageRejected":
                        throw await deserializeAws_queryMessageRejectedResponse(parsedOutput, context);
                    case "TemplateDoesNotExistException":
                    case "com.amazonaws.ses#TemplateDoesNotExistException":
                        throw await deserializeAws_queryTemplateDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySetActiveReceiptRuleSetCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySetActiveReceiptRuleSetCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySetActiveReceiptRuleSetResponse(data.SetActiveReceiptRuleSetResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySetActiveReceiptRuleSetCommand = deserializeAws_querySetActiveReceiptRuleSetCommand;
            const deserializeAws_querySetActiveReceiptRuleSetCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySetIdentityDkimEnabledCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySetIdentityDkimEnabledCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySetIdentityDkimEnabledResponse(data.SetIdentityDkimEnabledResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySetIdentityDkimEnabledCommand = deserializeAws_querySetIdentityDkimEnabledCommand;
            const deserializeAws_querySetIdentityDkimEnabledCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySetIdentityFeedbackForwardingEnabledCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySetIdentityFeedbackForwardingEnabledCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySetIdentityFeedbackForwardingEnabledResponse(data.SetIdentityFeedbackForwardingEnabledResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySetIdentityFeedbackForwardingEnabledCommand = deserializeAws_querySetIdentityFeedbackForwardingEnabledCommand;
            const deserializeAws_querySetIdentityFeedbackForwardingEnabledCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySetIdentityHeadersInNotificationsEnabledCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySetIdentityHeadersInNotificationsEnabledCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySetIdentityHeadersInNotificationsEnabledResponse(data.SetIdentityHeadersInNotificationsEnabledResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySetIdentityHeadersInNotificationsEnabledCommand = deserializeAws_querySetIdentityHeadersInNotificationsEnabledCommand;
            const deserializeAws_querySetIdentityHeadersInNotificationsEnabledCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySetIdentityMailFromDomainCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySetIdentityMailFromDomainCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySetIdentityMailFromDomainResponse(data.SetIdentityMailFromDomainResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySetIdentityMailFromDomainCommand = deserializeAws_querySetIdentityMailFromDomainCommand;
            const deserializeAws_querySetIdentityMailFromDomainCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySetIdentityNotificationTopicCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySetIdentityNotificationTopicCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySetIdentityNotificationTopicResponse(data.SetIdentityNotificationTopicResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySetIdentityNotificationTopicCommand = deserializeAws_querySetIdentityNotificationTopicCommand;
            const deserializeAws_querySetIdentityNotificationTopicCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_querySetReceiptRulePositionCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_querySetReceiptRulePositionCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_querySetReceiptRulePositionResponse(data.SetReceiptRulePositionResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_querySetReceiptRulePositionCommand = deserializeAws_querySetReceiptRulePositionCommand;
            const deserializeAws_querySetReceiptRulePositionCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "RuleDoesNotExistException":
                    case "com.amazonaws.ses#RuleDoesNotExistException":
                        throw await deserializeAws_queryRuleDoesNotExistExceptionResponse(parsedOutput, context);
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryTestRenderTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryTestRenderTemplateCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryTestRenderTemplateResponse(data.TestRenderTemplateResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryTestRenderTemplateCommand = deserializeAws_queryTestRenderTemplateCommand;
            const deserializeAws_queryTestRenderTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidRenderingParameterException":
                    case "com.amazonaws.ses#InvalidRenderingParameterException":
                        throw await deserializeAws_queryInvalidRenderingParameterExceptionResponse(parsedOutput, context);
                    case "MissingRenderingAttributeException":
                    case "com.amazonaws.ses#MissingRenderingAttributeException":
                        throw await deserializeAws_queryMissingRenderingAttributeExceptionResponse(parsedOutput, context);
                    case "TemplateDoesNotExistException":
                    case "com.amazonaws.ses#TemplateDoesNotExistException":
                        throw await deserializeAws_queryTemplateDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryUpdateAccountSendingEnabledCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryUpdateAccountSendingEnabledCommandError(output, context);
                }
                await collectBody(output.body, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryUpdateAccountSendingEnabledCommand = deserializeAws_queryUpdateAccountSendingEnabledCommand;
            const deserializeAws_queryUpdateAccountSendingEnabledCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryUpdateConfigurationSetEventDestinationCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryUpdateConfigurationSetEventDestinationCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryUpdateConfigurationSetEventDestinationResponse(data.UpdateConfigurationSetEventDestinationResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryUpdateConfigurationSetEventDestinationCommand = deserializeAws_queryUpdateConfigurationSetEventDestinationCommand;
            const deserializeAws_queryUpdateConfigurationSetEventDestinationCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "EventDestinationDoesNotExistException":
                    case "com.amazonaws.ses#EventDestinationDoesNotExistException":
                        throw await deserializeAws_queryEventDestinationDoesNotExistExceptionResponse(parsedOutput, context);
                    case "InvalidCloudWatchDestinationException":
                    case "com.amazonaws.ses#InvalidCloudWatchDestinationException":
                        throw await deserializeAws_queryInvalidCloudWatchDestinationExceptionResponse(parsedOutput, context);
                    case "InvalidFirehoseDestinationException":
                    case "com.amazonaws.ses#InvalidFirehoseDestinationException":
                        throw await deserializeAws_queryInvalidFirehoseDestinationExceptionResponse(parsedOutput, context);
                    case "InvalidSNSDestinationException":
                    case "com.amazonaws.ses#InvalidSNSDestinationException":
                        throw await deserializeAws_queryInvalidSNSDestinationExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommandError(output, context);
                }
                await collectBody(output.body, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand = deserializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommand;
            const deserializeAws_queryUpdateConfigurationSetReputationMetricsEnabledCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryUpdateConfigurationSetSendingEnabledCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryUpdateConfigurationSetSendingEnabledCommandError(output, context);
                }
                await collectBody(output.body, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryUpdateConfigurationSetSendingEnabledCommand = deserializeAws_queryUpdateConfigurationSetSendingEnabledCommand;
            const deserializeAws_queryUpdateConfigurationSetSendingEnabledCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryUpdateConfigurationSetTrackingOptionsCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryUpdateConfigurationSetTrackingOptionsCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryUpdateConfigurationSetTrackingOptionsResponse(data.UpdateConfigurationSetTrackingOptionsResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryUpdateConfigurationSetTrackingOptionsCommand = deserializeAws_queryUpdateConfigurationSetTrackingOptionsCommand;
            const deserializeAws_queryUpdateConfigurationSetTrackingOptionsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "ConfigurationSetDoesNotExistException":
                    case "com.amazonaws.ses#ConfigurationSetDoesNotExistException":
                        throw await deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse(parsedOutput, context);
                    case "InvalidTrackingOptionsException":
                    case "com.amazonaws.ses#InvalidTrackingOptionsException":
                        throw await deserializeAws_queryInvalidTrackingOptionsExceptionResponse(parsedOutput, context);
                    case "TrackingOptionsDoesNotExistException":
                    case "com.amazonaws.ses#TrackingOptionsDoesNotExistException":
                        throw await deserializeAws_queryTrackingOptionsDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryUpdateCustomVerificationEmailTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryUpdateCustomVerificationEmailTemplateCommandError(output, context);
                }
                await collectBody(output.body, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryUpdateCustomVerificationEmailTemplateCommand = deserializeAws_queryUpdateCustomVerificationEmailTemplateCommand;
            const deserializeAws_queryUpdateCustomVerificationEmailTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "CustomVerificationEmailInvalidContentException":
                    case "com.amazonaws.ses#CustomVerificationEmailInvalidContentException":
                        throw await deserializeAws_queryCustomVerificationEmailInvalidContentExceptionResponse(parsedOutput, context);
                    case "CustomVerificationEmailTemplateDoesNotExistException":
                    case "com.amazonaws.ses#CustomVerificationEmailTemplateDoesNotExistException":
                        throw await deserializeAws_queryCustomVerificationEmailTemplateDoesNotExistExceptionResponse(parsedOutput, context);
                    case "FromEmailAddressNotVerifiedException":
                    case "com.amazonaws.ses#FromEmailAddressNotVerifiedException":
                        throw await deserializeAws_queryFromEmailAddressNotVerifiedExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryUpdateReceiptRuleCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryUpdateReceiptRuleCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryUpdateReceiptRuleResponse(data.UpdateReceiptRuleResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryUpdateReceiptRuleCommand = deserializeAws_queryUpdateReceiptRuleCommand;
            const deserializeAws_queryUpdateReceiptRuleCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidLambdaFunctionException":
                    case "com.amazonaws.ses#InvalidLambdaFunctionException":
                        throw await deserializeAws_queryInvalidLambdaFunctionExceptionResponse(parsedOutput, context);
                    case "InvalidS3ConfigurationException":
                    case "com.amazonaws.ses#InvalidS3ConfigurationException":
                        throw await deserializeAws_queryInvalidS3ConfigurationExceptionResponse(parsedOutput, context);
                    case "InvalidSnsTopicException":
                    case "com.amazonaws.ses#InvalidSnsTopicException":
                        throw await deserializeAws_queryInvalidSnsTopicExceptionResponse(parsedOutput, context);
                    case "LimitExceededException":
                    case "com.amazonaws.ses#LimitExceededException":
                        throw await deserializeAws_queryLimitExceededExceptionResponse(parsedOutput, context);
                    case "RuleDoesNotExistException":
                    case "com.amazonaws.ses#RuleDoesNotExistException":
                        throw await deserializeAws_queryRuleDoesNotExistExceptionResponse(parsedOutput, context);
                    case "RuleSetDoesNotExistException":
                    case "com.amazonaws.ses#RuleSetDoesNotExistException":
                        throw await deserializeAws_queryRuleSetDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryUpdateTemplateCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryUpdateTemplateCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryUpdateTemplateResponse(data.UpdateTemplateResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryUpdateTemplateCommand = deserializeAws_queryUpdateTemplateCommand;
            const deserializeAws_queryUpdateTemplateCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidTemplateException":
                    case "com.amazonaws.ses#InvalidTemplateException":
                        throw await deserializeAws_queryInvalidTemplateExceptionResponse(parsedOutput, context);
                    case "TemplateDoesNotExistException":
                    case "com.amazonaws.ses#TemplateDoesNotExistException":
                        throw await deserializeAws_queryTemplateDoesNotExistExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryVerifyDomainDkimCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryVerifyDomainDkimCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryVerifyDomainDkimResponse(data.VerifyDomainDkimResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryVerifyDomainDkimCommand = deserializeAws_queryVerifyDomainDkimCommand;
            const deserializeAws_queryVerifyDomainDkimCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryVerifyDomainIdentityCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryVerifyDomainIdentityCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryVerifyDomainIdentityResponse(data.VerifyDomainIdentityResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryVerifyDomainIdentityCommand = deserializeAws_queryVerifyDomainIdentityCommand;
            const deserializeAws_queryVerifyDomainIdentityCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryVerifyEmailAddressCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryVerifyEmailAddressCommandError(output, context);
                }
                await collectBody(output.body, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryVerifyEmailAddressCommand = deserializeAws_queryVerifyEmailAddressCommand;
            const deserializeAws_queryVerifyEmailAddressCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryVerifyEmailIdentityCommand = async (output, context) => {
                if (output.statusCode >= 300) {
                    return deserializeAws_queryVerifyEmailIdentityCommandError(output, context);
                }
                const data = await parseBody(output.body, context);
                let contents = {};
                contents = deserializeAws_queryVerifyEmailIdentityResponse(data.VerifyEmailIdentityResult, context);
                const response = {
                    $metadata: deserializeMetadata(output),
                    ...contents,
                };
                return Promise.resolve(response);
            };
            exports.deserializeAws_queryVerifyEmailIdentityCommand = deserializeAws_queryVerifyEmailIdentityCommand;
            const deserializeAws_queryVerifyEmailIdentityCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadQueryErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SESServiceException_1.SESServiceException({
                            name: parsedBody.Error.code || parsedBody.Error.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody.Error);
                }
            };
            const deserializeAws_queryAccountSendingPausedExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryAccountSendingPausedException(body.Error, context);
                const exception = new models_0_1.AccountSendingPausedException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryAlreadyExistsException(body.Error, context);
                const exception = new models_0_1.AlreadyExistsException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryCannotDeleteExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryCannotDeleteException(body.Error, context);
                const exception = new models_0_1.CannotDeleteException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryConfigurationSetAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryConfigurationSetAlreadyExistsException(body.Error, context);
                const exception = new models_0_1.ConfigurationSetAlreadyExistsException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryConfigurationSetDoesNotExistExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryConfigurationSetDoesNotExistException(body.Error, context);
                const exception = new models_0_1.ConfigurationSetDoesNotExistException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryConfigurationSetSendingPausedExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryConfigurationSetSendingPausedException(body.Error, context);
                const exception = new models_0_1.ConfigurationSetSendingPausedException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryCustomVerificationEmailInvalidContentExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryCustomVerificationEmailInvalidContentException(body.Error, context);
                const exception = new models_0_1.CustomVerificationEmailInvalidContentException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryCustomVerificationEmailTemplateAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryCustomVerificationEmailTemplateAlreadyExistsException(body.Error, context);
                const exception = new models_0_1.CustomVerificationEmailTemplateAlreadyExistsException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryCustomVerificationEmailTemplateDoesNotExistExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryCustomVerificationEmailTemplateDoesNotExistException(body.Error, context);
                const exception = new models_0_1.CustomVerificationEmailTemplateDoesNotExistException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryEventDestinationAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryEventDestinationAlreadyExistsException(body.Error, context);
                const exception = new models_0_1.EventDestinationAlreadyExistsException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryEventDestinationDoesNotExistExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryEventDestinationDoesNotExistException(body.Error, context);
                const exception = new models_0_1.EventDestinationDoesNotExistException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryFromEmailAddressNotVerifiedExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryFromEmailAddressNotVerifiedException(body.Error, context);
                const exception = new models_0_1.FromEmailAddressNotVerifiedException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidCloudWatchDestinationExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidCloudWatchDestinationException(body.Error, context);
                const exception = new models_0_1.InvalidCloudWatchDestinationException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidConfigurationSetExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidConfigurationSetException(body.Error, context);
                const exception = new models_0_1.InvalidConfigurationSetException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidDeliveryOptionsExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidDeliveryOptionsException(body.Error, context);
                const exception = new models_0_1.InvalidDeliveryOptionsException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidFirehoseDestinationExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidFirehoseDestinationException(body.Error, context);
                const exception = new models_0_1.InvalidFirehoseDestinationException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidLambdaFunctionExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidLambdaFunctionException(body.Error, context);
                const exception = new models_0_1.InvalidLambdaFunctionException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidPolicyExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidPolicyException(body.Error, context);
                const exception = new models_0_1.InvalidPolicyException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidRenderingParameterExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidRenderingParameterException(body.Error, context);
                const exception = new models_0_1.InvalidRenderingParameterException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidS3ConfigurationExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidS3ConfigurationException(body.Error, context);
                const exception = new models_0_1.InvalidS3ConfigurationException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidSNSDestinationExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidSNSDestinationException(body.Error, context);
                const exception = new models_0_1.InvalidSNSDestinationException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidSnsTopicExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidSnsTopicException(body.Error, context);
                const exception = new models_0_1.InvalidSnsTopicException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidTemplateExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidTemplateException(body.Error, context);
                const exception = new models_0_1.InvalidTemplateException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryInvalidTrackingOptionsExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryInvalidTrackingOptionsException(body.Error, context);
                const exception = new models_0_1.InvalidTrackingOptionsException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryLimitExceededExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryLimitExceededException(body.Error, context);
                const exception = new models_0_1.LimitExceededException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryMailFromDomainNotVerifiedExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryMailFromDomainNotVerifiedException(body.Error, context);
                const exception = new models_0_1.MailFromDomainNotVerifiedException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryMessageRejectedResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryMessageRejected(body.Error, context);
                const exception = new models_0_1.MessageRejected({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryMissingRenderingAttributeExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryMissingRenderingAttributeException(body.Error, context);
                const exception = new models_0_1.MissingRenderingAttributeException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryProductionAccessNotGrantedExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryProductionAccessNotGrantedException(body.Error, context);
                const exception = new models_0_1.ProductionAccessNotGrantedException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryRuleDoesNotExistExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryRuleDoesNotExistException(body.Error, context);
                const exception = new models_0_1.RuleDoesNotExistException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryRuleSetDoesNotExistExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryRuleSetDoesNotExistException(body.Error, context);
                const exception = new models_0_1.RuleSetDoesNotExistException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryTemplateDoesNotExistExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryTemplateDoesNotExistException(body.Error, context);
                const exception = new models_0_1.TemplateDoesNotExistException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryTrackingOptionsAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryTrackingOptionsAlreadyExistsException(body.Error, context);
                const exception = new models_0_1.TrackingOptionsAlreadyExistsException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const deserializeAws_queryTrackingOptionsDoesNotExistExceptionResponse = async (parsedOutput, context) => {
                const body = parsedOutput.body;
                const deserialized = deserializeAws_queryTrackingOptionsDoesNotExistException(body.Error, context);
                const exception = new models_0_1.TrackingOptionsDoesNotExistException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...deserialized,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, body);
            };
            const serializeAws_queryAddHeaderAction = (input, context) => {
                const entries = {};
                if (input.HeaderName !== undefined && input.HeaderName !== null) {
                    entries["HeaderName"] = input.HeaderName;
                }
                if (input.HeaderValue !== undefined && input.HeaderValue !== null) {
                    entries["HeaderValue"] = input.HeaderValue;
                }
                return entries;
            };
            const serializeAws_queryAddressList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    entries[`member.${counter}`] = entry;
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryBody = (input, context) => {
                const entries = {};
                if (input.Text !== undefined && input.Text !== null) {
                    const memberEntries = serializeAws_queryContent(input.Text, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Text.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.Html !== undefined && input.Html !== null) {
                    const memberEntries = serializeAws_queryContent(input.Html, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Html.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryBounceAction = (input, context) => {
                const entries = {};
                if (input.TopicArn !== undefined && input.TopicArn !== null) {
                    entries["TopicArn"] = input.TopicArn;
                }
                if (input.SmtpReplyCode !== undefined && input.SmtpReplyCode !== null) {
                    entries["SmtpReplyCode"] = input.SmtpReplyCode;
                }
                if (input.StatusCode !== undefined && input.StatusCode !== null) {
                    entries["StatusCode"] = input.StatusCode;
                }
                if (input.Message !== undefined && input.Message !== null) {
                    entries["Message"] = input.Message;
                }
                if (input.Sender !== undefined && input.Sender !== null) {
                    entries["Sender"] = input.Sender;
                }
                return entries;
            };
            const serializeAws_queryBouncedRecipientInfo = (input, context) => {
                const entries = {};
                if (input.Recipient !== undefined && input.Recipient !== null) {
                    entries["Recipient"] = input.Recipient;
                }
                if (input.RecipientArn !== undefined && input.RecipientArn !== null) {
                    entries["RecipientArn"] = input.RecipientArn;
                }
                if (input.BounceType !== undefined && input.BounceType !== null) {
                    entries["BounceType"] = input.BounceType;
                }
                if (input.RecipientDsnFields !== undefined && input.RecipientDsnFields !== null) {
                    const memberEntries = serializeAws_queryRecipientDsnFields(input.RecipientDsnFields, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `RecipientDsnFields.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryBouncedRecipientInfoList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    const memberEntries = serializeAws_queryBouncedRecipientInfo(entry, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        entries[`member.${counter}.${key}`] = value;
                    });
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryBulkEmailDestination = (input, context) => {
                const entries = {};
                if (input.Destination !== undefined && input.Destination !== null) {
                    const memberEntries = serializeAws_queryDestination(input.Destination, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Destination.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ReplacementTags !== undefined && input.ReplacementTags !== null) {
                    const memberEntries = serializeAws_queryMessageTagList(input.ReplacementTags, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ReplacementTags.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ReplacementTemplateData !== undefined && input.ReplacementTemplateData !== null) {
                    entries["ReplacementTemplateData"] = input.ReplacementTemplateData;
                }
                return entries;
            };
            const serializeAws_queryBulkEmailDestinationList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    const memberEntries = serializeAws_queryBulkEmailDestination(entry, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        entries[`member.${counter}.${key}`] = value;
                    });
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryCloneReceiptRuleSetRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                if (input.OriginalRuleSetName !== undefined && input.OriginalRuleSetName !== null) {
                    entries["OriginalRuleSetName"] = input.OriginalRuleSetName;
                }
                return entries;
            };
            const serializeAws_queryCloudWatchDestination = (input, context) => {
                const entries = {};
                if (input.DimensionConfigurations !== undefined && input.DimensionConfigurations !== null) {
                    const memberEntries = serializeAws_queryCloudWatchDimensionConfigurations(input.DimensionConfigurations, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `DimensionConfigurations.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryCloudWatchDimensionConfiguration = (input, context) => {
                const entries = {};
                if (input.DimensionName !== undefined && input.DimensionName !== null) {
                    entries["DimensionName"] = input.DimensionName;
                }
                if (input.DimensionValueSource !== undefined && input.DimensionValueSource !== null) {
                    entries["DimensionValueSource"] = input.DimensionValueSource;
                }
                if (input.DefaultDimensionValue !== undefined && input.DefaultDimensionValue !== null) {
                    entries["DefaultDimensionValue"] = input.DefaultDimensionValue;
                }
                return entries;
            };
            const serializeAws_queryCloudWatchDimensionConfigurations = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    const memberEntries = serializeAws_queryCloudWatchDimensionConfiguration(entry, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        entries[`member.${counter}.${key}`] = value;
                    });
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryConfigurationSet = (input, context) => {
                const entries = {};
                if (input.Name !== undefined && input.Name !== null) {
                    entries["Name"] = input.Name;
                }
                return entries;
            };
            const serializeAws_queryConfigurationSetAttributeList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    entries[`member.${counter}`] = entry;
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryContent = (input, context) => {
                const entries = {};
                if (input.Data !== undefined && input.Data !== null) {
                    entries["Data"] = input.Data;
                }
                if (input.Charset !== undefined && input.Charset !== null) {
                    entries["Charset"] = input.Charset;
                }
                return entries;
            };
            const serializeAws_queryCreateConfigurationSetEventDestinationRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.EventDestination !== undefined && input.EventDestination !== null) {
                    const memberEntries = serializeAws_queryEventDestination(input.EventDestination, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `EventDestination.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryCreateConfigurationSetRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSet !== undefined && input.ConfigurationSet !== null) {
                    const memberEntries = serializeAws_queryConfigurationSet(input.ConfigurationSet, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ConfigurationSet.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryCreateConfigurationSetTrackingOptionsRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.TrackingOptions !== undefined && input.TrackingOptions !== null) {
                    const memberEntries = serializeAws_queryTrackingOptions(input.TrackingOptions, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `TrackingOptions.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryCreateCustomVerificationEmailTemplateRequest = (input, context) => {
                const entries = {};
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                if (input.FromEmailAddress !== undefined && input.FromEmailAddress !== null) {
                    entries["FromEmailAddress"] = input.FromEmailAddress;
                }
                if (input.TemplateSubject !== undefined && input.TemplateSubject !== null) {
                    entries["TemplateSubject"] = input.TemplateSubject;
                }
                if (input.TemplateContent !== undefined && input.TemplateContent !== null) {
                    entries["TemplateContent"] = input.TemplateContent;
                }
                if (input.SuccessRedirectionURL !== undefined && input.SuccessRedirectionURL !== null) {
                    entries["SuccessRedirectionURL"] = input.SuccessRedirectionURL;
                }
                if (input.FailureRedirectionURL !== undefined && input.FailureRedirectionURL !== null) {
                    entries["FailureRedirectionURL"] = input.FailureRedirectionURL;
                }
                return entries;
            };
            const serializeAws_queryCreateReceiptFilterRequest = (input, context) => {
                const entries = {};
                if (input.Filter !== undefined && input.Filter !== null) {
                    const memberEntries = serializeAws_queryReceiptFilter(input.Filter, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Filter.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryCreateReceiptRuleRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                if (input.After !== undefined && input.After !== null) {
                    entries["After"] = input.After;
                }
                if (input.Rule !== undefined && input.Rule !== null) {
                    const memberEntries = serializeAws_queryReceiptRule(input.Rule, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Rule.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryCreateReceiptRuleSetRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                return entries;
            };
            const serializeAws_queryCreateTemplateRequest = (input, context) => {
                const entries = {};
                if (input.Template !== undefined && input.Template !== null) {
                    const memberEntries = serializeAws_queryTemplate(input.Template, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Template.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryDeleteConfigurationSetEventDestinationRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.EventDestinationName !== undefined && input.EventDestinationName !== null) {
                    entries["EventDestinationName"] = input.EventDestinationName;
                }
                return entries;
            };
            const serializeAws_queryDeleteConfigurationSetRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                return entries;
            };
            const serializeAws_queryDeleteConfigurationSetTrackingOptionsRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                return entries;
            };
            const serializeAws_queryDeleteCustomVerificationEmailTemplateRequest = (input, context) => {
                const entries = {};
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                return entries;
            };
            const serializeAws_queryDeleteIdentityPolicyRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                if (input.PolicyName !== undefined && input.PolicyName !== null) {
                    entries["PolicyName"] = input.PolicyName;
                }
                return entries;
            };
            const serializeAws_queryDeleteIdentityRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                return entries;
            };
            const serializeAws_queryDeleteReceiptFilterRequest = (input, context) => {
                const entries = {};
                if (input.FilterName !== undefined && input.FilterName !== null) {
                    entries["FilterName"] = input.FilterName;
                }
                return entries;
            };
            const serializeAws_queryDeleteReceiptRuleRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                if (input.RuleName !== undefined && input.RuleName !== null) {
                    entries["RuleName"] = input.RuleName;
                }
                return entries;
            };
            const serializeAws_queryDeleteReceiptRuleSetRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                return entries;
            };
            const serializeAws_queryDeleteTemplateRequest = (input, context) => {
                const entries = {};
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                return entries;
            };
            const serializeAws_queryDeleteVerifiedEmailAddressRequest = (input, context) => {
                const entries = {};
                if (input.EmailAddress !== undefined && input.EmailAddress !== null) {
                    entries["EmailAddress"] = input.EmailAddress;
                }
                return entries;
            };
            const serializeAws_queryDeliveryOptions = (input, context) => {
                const entries = {};
                if (input.TlsPolicy !== undefined && input.TlsPolicy !== null) {
                    entries["TlsPolicy"] = input.TlsPolicy;
                }
                return entries;
            };
            const serializeAws_queryDescribeActiveReceiptRuleSetRequest = (input, context) => {
                const entries = {};
                return entries;
            };
            const serializeAws_queryDescribeConfigurationSetRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.ConfigurationSetAttributeNames !== undefined && input.ConfigurationSetAttributeNames !== null) {
                    const memberEntries = serializeAws_queryConfigurationSetAttributeList(input.ConfigurationSetAttributeNames, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ConfigurationSetAttributeNames.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryDescribeReceiptRuleRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                if (input.RuleName !== undefined && input.RuleName !== null) {
                    entries["RuleName"] = input.RuleName;
                }
                return entries;
            };
            const serializeAws_queryDescribeReceiptRuleSetRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                return entries;
            };
            const serializeAws_queryDestination = (input, context) => {
                const entries = {};
                if (input.ToAddresses !== undefined && input.ToAddresses !== null) {
                    const memberEntries = serializeAws_queryAddressList(input.ToAddresses, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ToAddresses.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.CcAddresses !== undefined && input.CcAddresses !== null) {
                    const memberEntries = serializeAws_queryAddressList(input.CcAddresses, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `CcAddresses.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.BccAddresses !== undefined && input.BccAddresses !== null) {
                    const memberEntries = serializeAws_queryAddressList(input.BccAddresses, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `BccAddresses.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryEventDestination = (input, context) => {
                const entries = {};
                if (input.Name !== undefined && input.Name !== null) {
                    entries["Name"] = input.Name;
                }
                if (input.Enabled !== undefined && input.Enabled !== null) {
                    entries["Enabled"] = input.Enabled;
                }
                if (input.MatchingEventTypes !== undefined && input.MatchingEventTypes !== null) {
                    const memberEntries = serializeAws_queryEventTypes(input.MatchingEventTypes, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `MatchingEventTypes.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.KinesisFirehoseDestination !== undefined && input.KinesisFirehoseDestination !== null) {
                    const memberEntries = serializeAws_queryKinesisFirehoseDestination(input.KinesisFirehoseDestination, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `KinesisFirehoseDestination.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.CloudWatchDestination !== undefined && input.CloudWatchDestination !== null) {
                    const memberEntries = serializeAws_queryCloudWatchDestination(input.CloudWatchDestination, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `CloudWatchDestination.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.SNSDestination !== undefined && input.SNSDestination !== null) {
                    const memberEntries = serializeAws_querySNSDestination(input.SNSDestination, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `SNSDestination.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryEventTypes = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    entries[`member.${counter}`] = entry;
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryExtensionField = (input, context) => {
                const entries = {};
                if (input.Name !== undefined && input.Name !== null) {
                    entries["Name"] = input.Name;
                }
                if (input.Value !== undefined && input.Value !== null) {
                    entries["Value"] = input.Value;
                }
                return entries;
            };
            const serializeAws_queryExtensionFieldList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    const memberEntries = serializeAws_queryExtensionField(entry, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        entries[`member.${counter}.${key}`] = value;
                    });
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryGetCustomVerificationEmailTemplateRequest = (input, context) => {
                const entries = {};
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                return entries;
            };
            const serializeAws_queryGetIdentityDkimAttributesRequest = (input, context) => {
                const entries = {};
                if (input.Identities !== undefined && input.Identities !== null) {
                    const memberEntries = serializeAws_queryIdentityList(input.Identities, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Identities.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryGetIdentityMailFromDomainAttributesRequest = (input, context) => {
                const entries = {};
                if (input.Identities !== undefined && input.Identities !== null) {
                    const memberEntries = serializeAws_queryIdentityList(input.Identities, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Identities.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryGetIdentityNotificationAttributesRequest = (input, context) => {
                const entries = {};
                if (input.Identities !== undefined && input.Identities !== null) {
                    const memberEntries = serializeAws_queryIdentityList(input.Identities, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Identities.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryGetIdentityPoliciesRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                if (input.PolicyNames !== undefined && input.PolicyNames !== null) {
                    const memberEntries = serializeAws_queryPolicyNameList(input.PolicyNames, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `PolicyNames.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryGetIdentityVerificationAttributesRequest = (input, context) => {
                const entries = {};
                if (input.Identities !== undefined && input.Identities !== null) {
                    const memberEntries = serializeAws_queryIdentityList(input.Identities, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Identities.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryGetTemplateRequest = (input, context) => {
                const entries = {};
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                return entries;
            };
            const serializeAws_queryIdentityList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    entries[`member.${counter}`] = entry;
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryKinesisFirehoseDestination = (input, context) => {
                const entries = {};
                if (input.IAMRoleARN !== undefined && input.IAMRoleARN !== null) {
                    entries["IAMRoleARN"] = input.IAMRoleARN;
                }
                if (input.DeliveryStreamARN !== undefined && input.DeliveryStreamARN !== null) {
                    entries["DeliveryStreamARN"] = input.DeliveryStreamARN;
                }
                return entries;
            };
            const serializeAws_queryLambdaAction = (input, context) => {
                const entries = {};
                if (input.TopicArn !== undefined && input.TopicArn !== null) {
                    entries["TopicArn"] = input.TopicArn;
                }
                if (input.FunctionArn !== undefined && input.FunctionArn !== null) {
                    entries["FunctionArn"] = input.FunctionArn;
                }
                if (input.InvocationType !== undefined && input.InvocationType !== null) {
                    entries["InvocationType"] = input.InvocationType;
                }
                return entries;
            };
            const serializeAws_queryListConfigurationSetsRequest = (input, context) => {
                const entries = {};
                if (input.NextToken !== undefined && input.NextToken !== null) {
                    entries["NextToken"] = input.NextToken;
                }
                if (input.MaxItems !== undefined && input.MaxItems !== null) {
                    entries["MaxItems"] = input.MaxItems;
                }
                return entries;
            };
            const serializeAws_queryListCustomVerificationEmailTemplatesRequest = (input, context) => {
                const entries = {};
                if (input.NextToken !== undefined && input.NextToken !== null) {
                    entries["NextToken"] = input.NextToken;
                }
                if (input.MaxResults !== undefined && input.MaxResults !== null) {
                    entries["MaxResults"] = input.MaxResults;
                }
                return entries;
            };
            const serializeAws_queryListIdentitiesRequest = (input, context) => {
                const entries = {};
                if (input.IdentityType !== undefined && input.IdentityType !== null) {
                    entries["IdentityType"] = input.IdentityType;
                }
                if (input.NextToken !== undefined && input.NextToken !== null) {
                    entries["NextToken"] = input.NextToken;
                }
                if (input.MaxItems !== undefined && input.MaxItems !== null) {
                    entries["MaxItems"] = input.MaxItems;
                }
                return entries;
            };
            const serializeAws_queryListIdentityPoliciesRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                return entries;
            };
            const serializeAws_queryListReceiptFiltersRequest = (input, context) => {
                const entries = {};
                return entries;
            };
            const serializeAws_queryListReceiptRuleSetsRequest = (input, context) => {
                const entries = {};
                if (input.NextToken !== undefined && input.NextToken !== null) {
                    entries["NextToken"] = input.NextToken;
                }
                return entries;
            };
            const serializeAws_queryListTemplatesRequest = (input, context) => {
                const entries = {};
                if (input.NextToken !== undefined && input.NextToken !== null) {
                    entries["NextToken"] = input.NextToken;
                }
                if (input.MaxItems !== undefined && input.MaxItems !== null) {
                    entries["MaxItems"] = input.MaxItems;
                }
                return entries;
            };
            const serializeAws_queryMessage = (input, context) => {
                const entries = {};
                if (input.Subject !== undefined && input.Subject !== null) {
                    const memberEntries = serializeAws_queryContent(input.Subject, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Subject.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.Body !== undefined && input.Body !== null) {
                    const memberEntries = serializeAws_queryBody(input.Body, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Body.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryMessageDsn = (input, context) => {
                const entries = {};
                if (input.ReportingMta !== undefined && input.ReportingMta !== null) {
                    entries["ReportingMta"] = input.ReportingMta;
                }
                if (input.ArrivalDate !== undefined && input.ArrivalDate !== null) {
                    entries["ArrivalDate"] = input.ArrivalDate.toISOString().split(".")[0] + "Z";
                }
                if (input.ExtensionFields !== undefined && input.ExtensionFields !== null) {
                    const memberEntries = serializeAws_queryExtensionFieldList(input.ExtensionFields, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ExtensionFields.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryMessageTag = (input, context) => {
                const entries = {};
                if (input.Name !== undefined && input.Name !== null) {
                    entries["Name"] = input.Name;
                }
                if (input.Value !== undefined && input.Value !== null) {
                    entries["Value"] = input.Value;
                }
                return entries;
            };
            const serializeAws_queryMessageTagList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    const memberEntries = serializeAws_queryMessageTag(entry, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        entries[`member.${counter}.${key}`] = value;
                    });
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryPolicyNameList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    entries[`member.${counter}`] = entry;
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryPutConfigurationSetDeliveryOptionsRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.DeliveryOptions !== undefined && input.DeliveryOptions !== null) {
                    const memberEntries = serializeAws_queryDeliveryOptions(input.DeliveryOptions, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `DeliveryOptions.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryPutIdentityPolicyRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                if (input.PolicyName !== undefined && input.PolicyName !== null) {
                    entries["PolicyName"] = input.PolicyName;
                }
                if (input.Policy !== undefined && input.Policy !== null) {
                    entries["Policy"] = input.Policy;
                }
                return entries;
            };
            const serializeAws_queryRawMessage = (input, context) => {
                const entries = {};
                if (input.Data !== undefined && input.Data !== null) {
                    entries["Data"] = context.base64Encoder(input.Data);
                }
                return entries;
            };
            const serializeAws_queryReceiptAction = (input, context) => {
                const entries = {};
                if (input.S3Action !== undefined && input.S3Action !== null) {
                    const memberEntries = serializeAws_queryS3Action(input.S3Action, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `S3Action.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.BounceAction !== undefined && input.BounceAction !== null) {
                    const memberEntries = serializeAws_queryBounceAction(input.BounceAction, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `BounceAction.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.WorkmailAction !== undefined && input.WorkmailAction !== null) {
                    const memberEntries = serializeAws_queryWorkmailAction(input.WorkmailAction, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `WorkmailAction.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.LambdaAction !== undefined && input.LambdaAction !== null) {
                    const memberEntries = serializeAws_queryLambdaAction(input.LambdaAction, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `LambdaAction.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.StopAction !== undefined && input.StopAction !== null) {
                    const memberEntries = serializeAws_queryStopAction(input.StopAction, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `StopAction.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.AddHeaderAction !== undefined && input.AddHeaderAction !== null) {
                    const memberEntries = serializeAws_queryAddHeaderAction(input.AddHeaderAction, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `AddHeaderAction.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.SNSAction !== undefined && input.SNSAction !== null) {
                    const memberEntries = serializeAws_querySNSAction(input.SNSAction, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `SNSAction.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryReceiptActionsList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    const memberEntries = serializeAws_queryReceiptAction(entry, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        entries[`member.${counter}.${key}`] = value;
                    });
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryReceiptFilter = (input, context) => {
                const entries = {};
                if (input.Name !== undefined && input.Name !== null) {
                    entries["Name"] = input.Name;
                }
                if (input.IpFilter !== undefined && input.IpFilter !== null) {
                    const memberEntries = serializeAws_queryReceiptIpFilter(input.IpFilter, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `IpFilter.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryReceiptIpFilter = (input, context) => {
                const entries = {};
                if (input.Policy !== undefined && input.Policy !== null) {
                    entries["Policy"] = input.Policy;
                }
                if (input.Cidr !== undefined && input.Cidr !== null) {
                    entries["Cidr"] = input.Cidr;
                }
                return entries;
            };
            const serializeAws_queryReceiptRule = (input, context) => {
                const entries = {};
                if (input.Name !== undefined && input.Name !== null) {
                    entries["Name"] = input.Name;
                }
                if (input.Enabled !== undefined && input.Enabled !== null) {
                    entries["Enabled"] = input.Enabled;
                }
                if (input.TlsPolicy !== undefined && input.TlsPolicy !== null) {
                    entries["TlsPolicy"] = input.TlsPolicy;
                }
                if (input.Recipients !== undefined && input.Recipients !== null) {
                    const memberEntries = serializeAws_queryRecipientsList(input.Recipients, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Recipients.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.Actions !== undefined && input.Actions !== null) {
                    const memberEntries = serializeAws_queryReceiptActionsList(input.Actions, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Actions.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ScanEnabled !== undefined && input.ScanEnabled !== null) {
                    entries["ScanEnabled"] = input.ScanEnabled;
                }
                return entries;
            };
            const serializeAws_queryReceiptRuleNamesList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    entries[`member.${counter}`] = entry;
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryRecipientDsnFields = (input, context) => {
                const entries = {};
                if (input.FinalRecipient !== undefined && input.FinalRecipient !== null) {
                    entries["FinalRecipient"] = input.FinalRecipient;
                }
                if (input.Action !== undefined && input.Action !== null) {
                    entries["Action"] = input.Action;
                }
                if (input.RemoteMta !== undefined && input.RemoteMta !== null) {
                    entries["RemoteMta"] = input.RemoteMta;
                }
                if (input.Status !== undefined && input.Status !== null) {
                    entries["Status"] = input.Status;
                }
                if (input.DiagnosticCode !== undefined && input.DiagnosticCode !== null) {
                    entries["DiagnosticCode"] = input.DiagnosticCode;
                }
                if (input.LastAttemptDate !== undefined && input.LastAttemptDate !== null) {
                    entries["LastAttemptDate"] = input.LastAttemptDate.toISOString().split(".")[0] + "Z";
                }
                if (input.ExtensionFields !== undefined && input.ExtensionFields !== null) {
                    const memberEntries = serializeAws_queryExtensionFieldList(input.ExtensionFields, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ExtensionFields.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryRecipientsList = (input, context) => {
                const entries = {};
                let counter = 1;
                for (const entry of input) {
                    if (entry === null) {
                        continue;
                    }
                    entries[`member.${counter}`] = entry;
                    counter++;
                }
                return entries;
            };
            const serializeAws_queryReorderReceiptRuleSetRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                if (input.RuleNames !== undefined && input.RuleNames !== null) {
                    const memberEntries = serializeAws_queryReceiptRuleNamesList(input.RuleNames, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `RuleNames.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryS3Action = (input, context) => {
                const entries = {};
                if (input.TopicArn !== undefined && input.TopicArn !== null) {
                    entries["TopicArn"] = input.TopicArn;
                }
                if (input.BucketName !== undefined && input.BucketName !== null) {
                    entries["BucketName"] = input.BucketName;
                }
                if (input.ObjectKeyPrefix !== undefined && input.ObjectKeyPrefix !== null) {
                    entries["ObjectKeyPrefix"] = input.ObjectKeyPrefix;
                }
                if (input.KmsKeyArn !== undefined && input.KmsKeyArn !== null) {
                    entries["KmsKeyArn"] = input.KmsKeyArn;
                }
                return entries;
            };
            const serializeAws_querySendBounceRequest = (input, context) => {
                const entries = {};
                if (input.OriginalMessageId !== undefined && input.OriginalMessageId !== null) {
                    entries["OriginalMessageId"] = input.OriginalMessageId;
                }
                if (input.BounceSender !== undefined && input.BounceSender !== null) {
                    entries["BounceSender"] = input.BounceSender;
                }
                if (input.Explanation !== undefined && input.Explanation !== null) {
                    entries["Explanation"] = input.Explanation;
                }
                if (input.MessageDsn !== undefined && input.MessageDsn !== null) {
                    const memberEntries = serializeAws_queryMessageDsn(input.MessageDsn, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `MessageDsn.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.BouncedRecipientInfoList !== undefined && input.BouncedRecipientInfoList !== null) {
                    const memberEntries = serializeAws_queryBouncedRecipientInfoList(input.BouncedRecipientInfoList, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `BouncedRecipientInfoList.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.BounceSenderArn !== undefined && input.BounceSenderArn !== null) {
                    entries["BounceSenderArn"] = input.BounceSenderArn;
                }
                return entries;
            };
            const serializeAws_querySendBulkTemplatedEmailRequest = (input, context) => {
                const entries = {};
                if (input.Source !== undefined && input.Source !== null) {
                    entries["Source"] = input.Source;
                }
                if (input.SourceArn !== undefined && input.SourceArn !== null) {
                    entries["SourceArn"] = input.SourceArn;
                }
                if (input.ReplyToAddresses !== undefined && input.ReplyToAddresses !== null) {
                    const memberEntries = serializeAws_queryAddressList(input.ReplyToAddresses, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ReplyToAddresses.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ReturnPath !== undefined && input.ReturnPath !== null) {
                    entries["ReturnPath"] = input.ReturnPath;
                }
                if (input.ReturnPathArn !== undefined && input.ReturnPathArn !== null) {
                    entries["ReturnPathArn"] = input.ReturnPathArn;
                }
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.DefaultTags !== undefined && input.DefaultTags !== null) {
                    const memberEntries = serializeAws_queryMessageTagList(input.DefaultTags, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `DefaultTags.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.Template !== undefined && input.Template !== null) {
                    entries["Template"] = input.Template;
                }
                if (input.TemplateArn !== undefined && input.TemplateArn !== null) {
                    entries["TemplateArn"] = input.TemplateArn;
                }
                if (input.DefaultTemplateData !== undefined && input.DefaultTemplateData !== null) {
                    entries["DefaultTemplateData"] = input.DefaultTemplateData;
                }
                if (input.Destinations !== undefined && input.Destinations !== null) {
                    const memberEntries = serializeAws_queryBulkEmailDestinationList(input.Destinations, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Destinations.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_querySendCustomVerificationEmailRequest = (input, context) => {
                const entries = {};
                if (input.EmailAddress !== undefined && input.EmailAddress !== null) {
                    entries["EmailAddress"] = input.EmailAddress;
                }
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                return entries;
            };
            const serializeAws_querySendEmailRequest = (input, context) => {
                const entries = {};
                if (input.Source !== undefined && input.Source !== null) {
                    entries["Source"] = input.Source;
                }
                if (input.Destination !== undefined && input.Destination !== null) {
                    const memberEntries = serializeAws_queryDestination(input.Destination, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Destination.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.Message !== undefined && input.Message !== null) {
                    const memberEntries = serializeAws_queryMessage(input.Message, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Message.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ReplyToAddresses !== undefined && input.ReplyToAddresses !== null) {
                    const memberEntries = serializeAws_queryAddressList(input.ReplyToAddresses, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ReplyToAddresses.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ReturnPath !== undefined && input.ReturnPath !== null) {
                    entries["ReturnPath"] = input.ReturnPath;
                }
                if (input.SourceArn !== undefined && input.SourceArn !== null) {
                    entries["SourceArn"] = input.SourceArn;
                }
                if (input.ReturnPathArn !== undefined && input.ReturnPathArn !== null) {
                    entries["ReturnPathArn"] = input.ReturnPathArn;
                }
                if (input.Tags !== undefined && input.Tags !== null) {
                    const memberEntries = serializeAws_queryMessageTagList(input.Tags, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Tags.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                return entries;
            };
            const serializeAws_querySendRawEmailRequest = (input, context) => {
                const entries = {};
                if (input.Source !== undefined && input.Source !== null) {
                    entries["Source"] = input.Source;
                }
                if (input.Destinations !== undefined && input.Destinations !== null) {
                    const memberEntries = serializeAws_queryAddressList(input.Destinations, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Destinations.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.RawMessage !== undefined && input.RawMessage !== null) {
                    const memberEntries = serializeAws_queryRawMessage(input.RawMessage, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `RawMessage.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.FromArn !== undefined && input.FromArn !== null) {
                    entries["FromArn"] = input.FromArn;
                }
                if (input.SourceArn !== undefined && input.SourceArn !== null) {
                    entries["SourceArn"] = input.SourceArn;
                }
                if (input.ReturnPathArn !== undefined && input.ReturnPathArn !== null) {
                    entries["ReturnPathArn"] = input.ReturnPathArn;
                }
                if (input.Tags !== undefined && input.Tags !== null) {
                    const memberEntries = serializeAws_queryMessageTagList(input.Tags, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Tags.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                return entries;
            };
            const serializeAws_querySendTemplatedEmailRequest = (input, context) => {
                const entries = {};
                if (input.Source !== undefined && input.Source !== null) {
                    entries["Source"] = input.Source;
                }
                if (input.Destination !== undefined && input.Destination !== null) {
                    const memberEntries = serializeAws_queryDestination(input.Destination, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Destination.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ReplyToAddresses !== undefined && input.ReplyToAddresses !== null) {
                    const memberEntries = serializeAws_queryAddressList(input.ReplyToAddresses, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `ReplyToAddresses.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ReturnPath !== undefined && input.ReturnPath !== null) {
                    entries["ReturnPath"] = input.ReturnPath;
                }
                if (input.SourceArn !== undefined && input.SourceArn !== null) {
                    entries["SourceArn"] = input.SourceArn;
                }
                if (input.ReturnPathArn !== undefined && input.ReturnPathArn !== null) {
                    entries["ReturnPathArn"] = input.ReturnPathArn;
                }
                if (input.Tags !== undefined && input.Tags !== null) {
                    const memberEntries = serializeAws_queryMessageTagList(input.Tags, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Tags.${key}`;
                        entries[loc] = value;
                    });
                }
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.Template !== undefined && input.Template !== null) {
                    entries["Template"] = input.Template;
                }
                if (input.TemplateArn !== undefined && input.TemplateArn !== null) {
                    entries["TemplateArn"] = input.TemplateArn;
                }
                if (input.TemplateData !== undefined && input.TemplateData !== null) {
                    entries["TemplateData"] = input.TemplateData;
                }
                return entries;
            };
            const serializeAws_querySetActiveReceiptRuleSetRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                return entries;
            };
            const serializeAws_querySetIdentityDkimEnabledRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                if (input.DkimEnabled !== undefined && input.DkimEnabled !== null) {
                    entries["DkimEnabled"] = input.DkimEnabled;
                }
                return entries;
            };
            const serializeAws_querySetIdentityFeedbackForwardingEnabledRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                if (input.ForwardingEnabled !== undefined && input.ForwardingEnabled !== null) {
                    entries["ForwardingEnabled"] = input.ForwardingEnabled;
                }
                return entries;
            };
            const serializeAws_querySetIdentityHeadersInNotificationsEnabledRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                if (input.NotificationType !== undefined && input.NotificationType !== null) {
                    entries["NotificationType"] = input.NotificationType;
                }
                if (input.Enabled !== undefined && input.Enabled !== null) {
                    entries["Enabled"] = input.Enabled;
                }
                return entries;
            };
            const serializeAws_querySetIdentityMailFromDomainRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                if (input.MailFromDomain !== undefined && input.MailFromDomain !== null) {
                    entries["MailFromDomain"] = input.MailFromDomain;
                }
                if (input.BehaviorOnMXFailure !== undefined && input.BehaviorOnMXFailure !== null) {
                    entries["BehaviorOnMXFailure"] = input.BehaviorOnMXFailure;
                }
                return entries;
            };
            const serializeAws_querySetIdentityNotificationTopicRequest = (input, context) => {
                const entries = {};
                if (input.Identity !== undefined && input.Identity !== null) {
                    entries["Identity"] = input.Identity;
                }
                if (input.NotificationType !== undefined && input.NotificationType !== null) {
                    entries["NotificationType"] = input.NotificationType;
                }
                if (input.SnsTopic !== undefined && input.SnsTopic !== null) {
                    entries["SnsTopic"] = input.SnsTopic;
                }
                return entries;
            };
            const serializeAws_querySetReceiptRulePositionRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                if (input.RuleName !== undefined && input.RuleName !== null) {
                    entries["RuleName"] = input.RuleName;
                }
                if (input.After !== undefined && input.After !== null) {
                    entries["After"] = input.After;
                }
                return entries;
            };
            const serializeAws_querySNSAction = (input, context) => {
                const entries = {};
                if (input.TopicArn !== undefined && input.TopicArn !== null) {
                    entries["TopicArn"] = input.TopicArn;
                }
                if (input.Encoding !== undefined && input.Encoding !== null) {
                    entries["Encoding"] = input.Encoding;
                }
                return entries;
            };
            const serializeAws_querySNSDestination = (input, context) => {
                const entries = {};
                if (input.TopicARN !== undefined && input.TopicARN !== null) {
                    entries["TopicARN"] = input.TopicARN;
                }
                return entries;
            };
            const serializeAws_queryStopAction = (input, context) => {
                const entries = {};
                if (input.Scope !== undefined && input.Scope !== null) {
                    entries["Scope"] = input.Scope;
                }
                if (input.TopicArn !== undefined && input.TopicArn !== null) {
                    entries["TopicArn"] = input.TopicArn;
                }
                return entries;
            };
            const serializeAws_queryTemplate = (input, context) => {
                const entries = {};
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                if (input.SubjectPart !== undefined && input.SubjectPart !== null) {
                    entries["SubjectPart"] = input.SubjectPart;
                }
                if (input.TextPart !== undefined && input.TextPart !== null) {
                    entries["TextPart"] = input.TextPart;
                }
                if (input.HtmlPart !== undefined && input.HtmlPart !== null) {
                    entries["HtmlPart"] = input.HtmlPart;
                }
                return entries;
            };
            const serializeAws_queryTestRenderTemplateRequest = (input, context) => {
                const entries = {};
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                if (input.TemplateData !== undefined && input.TemplateData !== null) {
                    entries["TemplateData"] = input.TemplateData;
                }
                return entries;
            };
            const serializeAws_queryTrackingOptions = (input, context) => {
                const entries = {};
                if (input.CustomRedirectDomain !== undefined && input.CustomRedirectDomain !== null) {
                    entries["CustomRedirectDomain"] = input.CustomRedirectDomain;
                }
                return entries;
            };
            const serializeAws_queryUpdateAccountSendingEnabledRequest = (input, context) => {
                const entries = {};
                if (input.Enabled !== undefined && input.Enabled !== null) {
                    entries["Enabled"] = input.Enabled;
                }
                return entries;
            };
            const serializeAws_queryUpdateConfigurationSetEventDestinationRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.EventDestination !== undefined && input.EventDestination !== null) {
                    const memberEntries = serializeAws_queryEventDestination(input.EventDestination, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `EventDestination.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryUpdateConfigurationSetReputationMetricsEnabledRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.Enabled !== undefined && input.Enabled !== null) {
                    entries["Enabled"] = input.Enabled;
                }
                return entries;
            };
            const serializeAws_queryUpdateConfigurationSetSendingEnabledRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.Enabled !== undefined && input.Enabled !== null) {
                    entries["Enabled"] = input.Enabled;
                }
                return entries;
            };
            const serializeAws_queryUpdateConfigurationSetTrackingOptionsRequest = (input, context) => {
                const entries = {};
                if (input.ConfigurationSetName !== undefined && input.ConfigurationSetName !== null) {
                    entries["ConfigurationSetName"] = input.ConfigurationSetName;
                }
                if (input.TrackingOptions !== undefined && input.TrackingOptions !== null) {
                    const memberEntries = serializeAws_queryTrackingOptions(input.TrackingOptions, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `TrackingOptions.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryUpdateCustomVerificationEmailTemplateRequest = (input, context) => {
                const entries = {};
                if (input.TemplateName !== undefined && input.TemplateName !== null) {
                    entries["TemplateName"] = input.TemplateName;
                }
                if (input.FromEmailAddress !== undefined && input.FromEmailAddress !== null) {
                    entries["FromEmailAddress"] = input.FromEmailAddress;
                }
                if (input.TemplateSubject !== undefined && input.TemplateSubject !== null) {
                    entries["TemplateSubject"] = input.TemplateSubject;
                }
                if (input.TemplateContent !== undefined && input.TemplateContent !== null) {
                    entries["TemplateContent"] = input.TemplateContent;
                }
                if (input.SuccessRedirectionURL !== undefined && input.SuccessRedirectionURL !== null) {
                    entries["SuccessRedirectionURL"] = input.SuccessRedirectionURL;
                }
                if (input.FailureRedirectionURL !== undefined && input.FailureRedirectionURL !== null) {
                    entries["FailureRedirectionURL"] = input.FailureRedirectionURL;
                }
                return entries;
            };
            const serializeAws_queryUpdateReceiptRuleRequest = (input, context) => {
                const entries = {};
                if (input.RuleSetName !== undefined && input.RuleSetName !== null) {
                    entries["RuleSetName"] = input.RuleSetName;
                }
                if (input.Rule !== undefined && input.Rule !== null) {
                    const memberEntries = serializeAws_queryReceiptRule(input.Rule, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Rule.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryUpdateTemplateRequest = (input, context) => {
                const entries = {};
                if (input.Template !== undefined && input.Template !== null) {
                    const memberEntries = serializeAws_queryTemplate(input.Template, context);
                    Object.entries(memberEntries).forEach(([key, value]) => {
                        const loc = `Template.${key}`;
                        entries[loc] = value;
                    });
                }
                return entries;
            };
            const serializeAws_queryVerifyDomainDkimRequest = (input, context) => {
                const entries = {};
                if (input.Domain !== undefined && input.Domain !== null) {
                    entries["Domain"] = input.Domain;
                }
                return entries;
            };
            const serializeAws_queryVerifyDomainIdentityRequest = (input, context) => {
                const entries = {};
                if (input.Domain !== undefined && input.Domain !== null) {
                    entries["Domain"] = input.Domain;
                }
                return entries;
            };
            const serializeAws_queryVerifyEmailAddressRequest = (input, context) => {
                const entries = {};
                if (input.EmailAddress !== undefined && input.EmailAddress !== null) {
                    entries["EmailAddress"] = input.EmailAddress;
                }
                return entries;
            };
            const serializeAws_queryVerifyEmailIdentityRequest = (input, context) => {
                const entries = {};
                if (input.EmailAddress !== undefined && input.EmailAddress !== null) {
                    entries["EmailAddress"] = input.EmailAddress;
                }
                return entries;
            };
            const serializeAws_queryWorkmailAction = (input, context) => {
                const entries = {};
                if (input.TopicArn !== undefined && input.TopicArn !== null) {
                    entries["TopicArn"] = input.TopicArn;
                }
                if (input.OrganizationArn !== undefined && input.OrganizationArn !== null) {
                    entries["OrganizationArn"] = input.OrganizationArn;
                }
                return entries;
            };
            const deserializeAws_queryAccountSendingPausedException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryAddHeaderAction = (output, context) => {
                const contents = {
                    HeaderName: undefined,
                    HeaderValue: undefined,
                };
                if (output["HeaderName"] !== undefined) {
                    contents.HeaderName = (0, smithy_client_1.expectString)(output["HeaderName"]);
                }
                if (output["HeaderValue"] !== undefined) {
                    contents.HeaderValue = (0, smithy_client_1.expectString)(output["HeaderValue"]);
                }
                return contents;
            };
            const deserializeAws_queryAddressList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return (0, smithy_client_1.expectString)(entry);
                    });
            };
            const deserializeAws_queryAlreadyExistsException = (output, context) => {
                const contents = {
                    Name: undefined,
                    message: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryBounceAction = (output, context) => {
                const contents = {
                    TopicArn: undefined,
                    SmtpReplyCode: undefined,
                    StatusCode: undefined,
                    Message: undefined,
                    Sender: undefined,
                };
                if (output["TopicArn"] !== undefined) {
                    contents.TopicArn = (0, smithy_client_1.expectString)(output["TopicArn"]);
                }
                if (output["SmtpReplyCode"] !== undefined) {
                    contents.SmtpReplyCode = (0, smithy_client_1.expectString)(output["SmtpReplyCode"]);
                }
                if (output["StatusCode"] !== undefined) {
                    contents.StatusCode = (0, smithy_client_1.expectString)(output["StatusCode"]);
                }
                if (output["Message"] !== undefined) {
                    contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
                }
                if (output["Sender"] !== undefined) {
                    contents.Sender = (0, smithy_client_1.expectString)(output["Sender"]);
                }
                return contents;
            };
            const deserializeAws_queryBulkEmailDestinationStatus = (output, context) => {
                const contents = {
                    Status: undefined,
                    Error: undefined,
                    MessageId: undefined,
                };
                if (output["Status"] !== undefined) {
                    contents.Status = (0, smithy_client_1.expectString)(output["Status"]);
                }
                if (output["Error"] !== undefined) {
                    contents.Error = (0, smithy_client_1.expectString)(output["Error"]);
                }
                if (output["MessageId"] !== undefined) {
                    contents.MessageId = (0, smithy_client_1.expectString)(output["MessageId"]);
                }
                return contents;
            };
            const deserializeAws_queryBulkEmailDestinationStatusList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryBulkEmailDestinationStatus(entry, context);
                    });
            };
            const deserializeAws_queryCannotDeleteException = (output, context) => {
                const contents = {
                    Name: undefined,
                    message: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryCloneReceiptRuleSetResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryCloudWatchDestination = (output, context) => {
                const contents = {
                    DimensionConfigurations: undefined,
                };
                if (output.DimensionConfigurations === "") {
                    contents.DimensionConfigurations = [];
                }
                if (output["DimensionConfigurations"] !== undefined && output["DimensionConfigurations"]["member"] !== undefined) {
                    contents.DimensionConfigurations = deserializeAws_queryCloudWatchDimensionConfigurations((0, smithy_client_1.getArrayIfSingleItem)(output["DimensionConfigurations"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryCloudWatchDimensionConfiguration = (output, context) => {
                const contents = {
                    DimensionName: undefined,
                    DimensionValueSource: undefined,
                    DefaultDimensionValue: undefined,
                };
                if (output["DimensionName"] !== undefined) {
                    contents.DimensionName = (0, smithy_client_1.expectString)(output["DimensionName"]);
                }
                if (output["DimensionValueSource"] !== undefined) {
                    contents.DimensionValueSource = (0, smithy_client_1.expectString)(output["DimensionValueSource"]);
                }
                if (output["DefaultDimensionValue"] !== undefined) {
                    contents.DefaultDimensionValue = (0, smithy_client_1.expectString)(output["DefaultDimensionValue"]);
                }
                return contents;
            };
            const deserializeAws_queryCloudWatchDimensionConfigurations = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryCloudWatchDimensionConfiguration(entry, context);
                    });
            };
            const deserializeAws_queryConfigurationSet = (output, context) => {
                const contents = {
                    Name: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                return contents;
            };
            const deserializeAws_queryConfigurationSetAlreadyExistsException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryConfigurationSetDoesNotExistException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryConfigurationSets = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryConfigurationSet(entry, context);
                    });
            };
            const deserializeAws_queryConfigurationSetSendingPausedException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryCreateConfigurationSetEventDestinationResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryCreateConfigurationSetResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryCreateConfigurationSetTrackingOptionsResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryCreateReceiptFilterResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryCreateReceiptRuleResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryCreateReceiptRuleSetResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryCreateTemplateResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryCustomVerificationEmailInvalidContentException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryCustomVerificationEmailTemplate = (output, context) => {
                const contents = {
                    TemplateName: undefined,
                    FromEmailAddress: undefined,
                    TemplateSubject: undefined,
                    SuccessRedirectionURL: undefined,
                    FailureRedirectionURL: undefined,
                };
                if (output["TemplateName"] !== undefined) {
                    contents.TemplateName = (0, smithy_client_1.expectString)(output["TemplateName"]);
                }
                if (output["FromEmailAddress"] !== undefined) {
                    contents.FromEmailAddress = (0, smithy_client_1.expectString)(output["FromEmailAddress"]);
                }
                if (output["TemplateSubject"] !== undefined) {
                    contents.TemplateSubject = (0, smithy_client_1.expectString)(output["TemplateSubject"]);
                }
                if (output["SuccessRedirectionURL"] !== undefined) {
                    contents.SuccessRedirectionURL = (0, smithy_client_1.expectString)(output["SuccessRedirectionURL"]);
                }
                if (output["FailureRedirectionURL"] !== undefined) {
                    contents.FailureRedirectionURL = (0, smithy_client_1.expectString)(output["FailureRedirectionURL"]);
                }
                return contents;
            };
            const deserializeAws_queryCustomVerificationEmailTemplateAlreadyExistsException = (output, context) => {
                const contents = {
                    CustomVerificationEmailTemplateName: undefined,
                    message: undefined,
                };
                if (output["CustomVerificationEmailTemplateName"] !== undefined) {
                    contents.CustomVerificationEmailTemplateName = (0, smithy_client_1.expectString)(output["CustomVerificationEmailTemplateName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryCustomVerificationEmailTemplateDoesNotExistException = (output, context) => {
                const contents = {
                    CustomVerificationEmailTemplateName: undefined,
                    message: undefined,
                };
                if (output["CustomVerificationEmailTemplateName"] !== undefined) {
                    contents.CustomVerificationEmailTemplateName = (0, smithy_client_1.expectString)(output["CustomVerificationEmailTemplateName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryCustomVerificationEmailTemplates = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryCustomVerificationEmailTemplate(entry, context);
                    });
            };
            const deserializeAws_queryDeleteConfigurationSetEventDestinationResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeleteConfigurationSetResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeleteConfigurationSetTrackingOptionsResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeleteIdentityPolicyResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeleteIdentityResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeleteReceiptFilterResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeleteReceiptRuleResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeleteReceiptRuleSetResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeleteTemplateResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryDeliveryOptions = (output, context) => {
                const contents = {
                    TlsPolicy: undefined,
                };
                if (output["TlsPolicy"] !== undefined) {
                    contents.TlsPolicy = (0, smithy_client_1.expectString)(output["TlsPolicy"]);
                }
                return contents;
            };
            const deserializeAws_queryDescribeActiveReceiptRuleSetResponse = (output, context) => {
                const contents = {
                    Metadata: undefined,
                    Rules: undefined,
                };
                if (output["Metadata"] !== undefined) {
                    contents.Metadata = deserializeAws_queryReceiptRuleSetMetadata(output["Metadata"], context);
                }
                if (output.Rules === "") {
                    contents.Rules = [];
                }
                if (output["Rules"] !== undefined && output["Rules"]["member"] !== undefined) {
                    contents.Rules = deserializeAws_queryReceiptRulesList((0, smithy_client_1.getArrayIfSingleItem)(output["Rules"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryDescribeConfigurationSetResponse = (output, context) => {
                const contents = {
                    ConfigurationSet: undefined,
                    EventDestinations: undefined,
                    TrackingOptions: undefined,
                    DeliveryOptions: undefined,
                    ReputationOptions: undefined,
                };
                if (output["ConfigurationSet"] !== undefined) {
                    contents.ConfigurationSet = deserializeAws_queryConfigurationSet(output["ConfigurationSet"], context);
                }
                if (output.EventDestinations === "") {
                    contents.EventDestinations = [];
                }
                if (output["EventDestinations"] !== undefined && output["EventDestinations"]["member"] !== undefined) {
                    contents.EventDestinations = deserializeAws_queryEventDestinations((0, smithy_client_1.getArrayIfSingleItem)(output["EventDestinations"]["member"]), context);
                }
                if (output["TrackingOptions"] !== undefined) {
                    contents.TrackingOptions = deserializeAws_queryTrackingOptions(output["TrackingOptions"], context);
                }
                if (output["DeliveryOptions"] !== undefined) {
                    contents.DeliveryOptions = deserializeAws_queryDeliveryOptions(output["DeliveryOptions"], context);
                }
                if (output["ReputationOptions"] !== undefined) {
                    contents.ReputationOptions = deserializeAws_queryReputationOptions(output["ReputationOptions"], context);
                }
                return contents;
            };
            const deserializeAws_queryDescribeReceiptRuleResponse = (output, context) => {
                const contents = {
                    Rule: undefined,
                };
                if (output["Rule"] !== undefined) {
                    contents.Rule = deserializeAws_queryReceiptRule(output["Rule"], context);
                }
                return contents;
            };
            const deserializeAws_queryDescribeReceiptRuleSetResponse = (output, context) => {
                const contents = {
                    Metadata: undefined,
                    Rules: undefined,
                };
                if (output["Metadata"] !== undefined) {
                    contents.Metadata = deserializeAws_queryReceiptRuleSetMetadata(output["Metadata"], context);
                }
                if (output.Rules === "") {
                    contents.Rules = [];
                }
                if (output["Rules"] !== undefined && output["Rules"]["member"] !== undefined) {
                    contents.Rules = deserializeAws_queryReceiptRulesList((0, smithy_client_1.getArrayIfSingleItem)(output["Rules"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryDkimAttributes = (output, context) => {
                return output.reduce((acc, pair) => {
                    if (pair["value"] === null) {
                        return acc;
                    }
                    return {
                        ...acc,
                        [pair["key"]]: deserializeAws_queryIdentityDkimAttributes(pair["value"], context),
                    };
                }, {});
            };
            const deserializeAws_queryEventDestination = (output, context) => {
                const contents = {
                    Name: undefined,
                    Enabled: undefined,
                    MatchingEventTypes: undefined,
                    KinesisFirehoseDestination: undefined,
                    CloudWatchDestination: undefined,
                    SNSDestination: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["Enabled"] !== undefined) {
                    contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
                }
                if (output.MatchingEventTypes === "") {
                    contents.MatchingEventTypes = [];
                }
                if (output["MatchingEventTypes"] !== undefined && output["MatchingEventTypes"]["member"] !== undefined) {
                    contents.MatchingEventTypes = deserializeAws_queryEventTypes((0, smithy_client_1.getArrayIfSingleItem)(output["MatchingEventTypes"]["member"]), context);
                }
                if (output["KinesisFirehoseDestination"] !== undefined) {
                    contents.KinesisFirehoseDestination = deserializeAws_queryKinesisFirehoseDestination(output["KinesisFirehoseDestination"], context);
                }
                if (output["CloudWatchDestination"] !== undefined) {
                    contents.CloudWatchDestination = deserializeAws_queryCloudWatchDestination(output["CloudWatchDestination"], context);
                }
                if (output["SNSDestination"] !== undefined) {
                    contents.SNSDestination = deserializeAws_querySNSDestination(output["SNSDestination"], context);
                }
                return contents;
            };
            const deserializeAws_queryEventDestinationAlreadyExistsException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    EventDestinationName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["EventDestinationName"] !== undefined) {
                    contents.EventDestinationName = (0, smithy_client_1.expectString)(output["EventDestinationName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryEventDestinationDoesNotExistException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    EventDestinationName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["EventDestinationName"] !== undefined) {
                    contents.EventDestinationName = (0, smithy_client_1.expectString)(output["EventDestinationName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryEventDestinations = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryEventDestination(entry, context);
                    });
            };
            const deserializeAws_queryEventTypes = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return (0, smithy_client_1.expectString)(entry);
                    });
            };
            const deserializeAws_queryFromEmailAddressNotVerifiedException = (output, context) => {
                const contents = {
                    FromEmailAddress: undefined,
                    message: undefined,
                };
                if (output["FromEmailAddress"] !== undefined) {
                    contents.FromEmailAddress = (0, smithy_client_1.expectString)(output["FromEmailAddress"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryGetAccountSendingEnabledResponse = (output, context) => {
                const contents = {
                    Enabled: undefined,
                };
                if (output["Enabled"] !== undefined) {
                    contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
                }
                return contents;
            };
            const deserializeAws_queryGetCustomVerificationEmailTemplateResponse = (output, context) => {
                const contents = {
                    TemplateName: undefined,
                    FromEmailAddress: undefined,
                    TemplateSubject: undefined,
                    TemplateContent: undefined,
                    SuccessRedirectionURL: undefined,
                    FailureRedirectionURL: undefined,
                };
                if (output["TemplateName"] !== undefined) {
                    contents.TemplateName = (0, smithy_client_1.expectString)(output["TemplateName"]);
                }
                if (output["FromEmailAddress"] !== undefined) {
                    contents.FromEmailAddress = (0, smithy_client_1.expectString)(output["FromEmailAddress"]);
                }
                if (output["TemplateSubject"] !== undefined) {
                    contents.TemplateSubject = (0, smithy_client_1.expectString)(output["TemplateSubject"]);
                }
                if (output["TemplateContent"] !== undefined) {
                    contents.TemplateContent = (0, smithy_client_1.expectString)(output["TemplateContent"]);
                }
                if (output["SuccessRedirectionURL"] !== undefined) {
                    contents.SuccessRedirectionURL = (0, smithy_client_1.expectString)(output["SuccessRedirectionURL"]);
                }
                if (output["FailureRedirectionURL"] !== undefined) {
                    contents.FailureRedirectionURL = (0, smithy_client_1.expectString)(output["FailureRedirectionURL"]);
                }
                return contents;
            };
            const deserializeAws_queryGetIdentityDkimAttributesResponse = (output, context) => {
                const contents = {
                    DkimAttributes: undefined,
                };
                if (output.DkimAttributes === "") {
                    contents.DkimAttributes = {};
                }
                if (output["DkimAttributes"] !== undefined && output["DkimAttributes"]["entry"] !== undefined) {
                    contents.DkimAttributes = deserializeAws_queryDkimAttributes((0, smithy_client_1.getArrayIfSingleItem)(output["DkimAttributes"]["entry"]), context);
                }
                return contents;
            };
            const deserializeAws_queryGetIdentityMailFromDomainAttributesResponse = (output, context) => {
                const contents = {
                    MailFromDomainAttributes: undefined,
                };
                if (output.MailFromDomainAttributes === "") {
                    contents.MailFromDomainAttributes = {};
                }
                if (output["MailFromDomainAttributes"] !== undefined && output["MailFromDomainAttributes"]["entry"] !== undefined) {
                    contents.MailFromDomainAttributes = deserializeAws_queryMailFromDomainAttributes((0, smithy_client_1.getArrayIfSingleItem)(output["MailFromDomainAttributes"]["entry"]), context);
                }
                return contents;
            };
            const deserializeAws_queryGetIdentityNotificationAttributesResponse = (output, context) => {
                const contents = {
                    NotificationAttributes: undefined,
                };
                if (output.NotificationAttributes === "") {
                    contents.NotificationAttributes = {};
                }
                if (output["NotificationAttributes"] !== undefined && output["NotificationAttributes"]["entry"] !== undefined) {
                    contents.NotificationAttributes = deserializeAws_queryNotificationAttributes((0, smithy_client_1.getArrayIfSingleItem)(output["NotificationAttributes"]["entry"]), context);
                }
                return contents;
            };
            const deserializeAws_queryGetIdentityPoliciesResponse = (output, context) => {
                const contents = {
                    Policies: undefined,
                };
                if (output.Policies === "") {
                    contents.Policies = {};
                }
                if (output["Policies"] !== undefined && output["Policies"]["entry"] !== undefined) {
                    contents.Policies = deserializeAws_queryPolicyMap((0, smithy_client_1.getArrayIfSingleItem)(output["Policies"]["entry"]), context);
                }
                return contents;
            };
            const deserializeAws_queryGetIdentityVerificationAttributesResponse = (output, context) => {
                const contents = {
                    VerificationAttributes: undefined,
                };
                if (output.VerificationAttributes === "") {
                    contents.VerificationAttributes = {};
                }
                if (output["VerificationAttributes"] !== undefined && output["VerificationAttributes"]["entry"] !== undefined) {
                    contents.VerificationAttributes = deserializeAws_queryVerificationAttributes((0, smithy_client_1.getArrayIfSingleItem)(output["VerificationAttributes"]["entry"]), context);
                }
                return contents;
            };
            const deserializeAws_queryGetSendQuotaResponse = (output, context) => {
                const contents = {
                    Max24HourSend: undefined,
                    MaxSendRate: undefined,
                    SentLast24Hours: undefined,
                };
                if (output["Max24HourSend"] !== undefined) {
                    contents.Max24HourSend = (0, smithy_client_1.strictParseFloat)(output["Max24HourSend"]);
                }
                if (output["MaxSendRate"] !== undefined) {
                    contents.MaxSendRate = (0, smithy_client_1.strictParseFloat)(output["MaxSendRate"]);
                }
                if (output["SentLast24Hours"] !== undefined) {
                    contents.SentLast24Hours = (0, smithy_client_1.strictParseFloat)(output["SentLast24Hours"]);
                }
                return contents;
            };
            const deserializeAws_queryGetSendStatisticsResponse = (output, context) => {
                const contents = {
                    SendDataPoints: undefined,
                };
                if (output.SendDataPoints === "") {
                    contents.SendDataPoints = [];
                }
                if (output["SendDataPoints"] !== undefined && output["SendDataPoints"]["member"] !== undefined) {
                    contents.SendDataPoints = deserializeAws_querySendDataPointList((0, smithy_client_1.getArrayIfSingleItem)(output["SendDataPoints"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryGetTemplateResponse = (output, context) => {
                const contents = {
                    Template: undefined,
                };
                if (output["Template"] !== undefined) {
                    contents.Template = deserializeAws_queryTemplate(output["Template"], context);
                }
                return contents;
            };
            const deserializeAws_queryIdentityDkimAttributes = (output, context) => {
                const contents = {
                    DkimEnabled: undefined,
                    DkimVerificationStatus: undefined,
                    DkimTokens: undefined,
                };
                if (output["DkimEnabled"] !== undefined) {
                    contents.DkimEnabled = (0, smithy_client_1.parseBoolean)(output["DkimEnabled"]);
                }
                if (output["DkimVerificationStatus"] !== undefined) {
                    contents.DkimVerificationStatus = (0, smithy_client_1.expectString)(output["DkimVerificationStatus"]);
                }
                if (output.DkimTokens === "") {
                    contents.DkimTokens = [];
                }
                if (output["DkimTokens"] !== undefined && output["DkimTokens"]["member"] !== undefined) {
                    contents.DkimTokens = deserializeAws_queryVerificationTokenList((0, smithy_client_1.getArrayIfSingleItem)(output["DkimTokens"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryIdentityList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return (0, smithy_client_1.expectString)(entry);
                    });
            };
            const deserializeAws_queryIdentityMailFromDomainAttributes = (output, context) => {
                const contents = {
                    MailFromDomain: undefined,
                    MailFromDomainStatus: undefined,
                    BehaviorOnMXFailure: undefined,
                };
                if (output["MailFromDomain"] !== undefined) {
                    contents.MailFromDomain = (0, smithy_client_1.expectString)(output["MailFromDomain"]);
                }
                if (output["MailFromDomainStatus"] !== undefined) {
                    contents.MailFromDomainStatus = (0, smithy_client_1.expectString)(output["MailFromDomainStatus"]);
                }
                if (output["BehaviorOnMXFailure"] !== undefined) {
                    contents.BehaviorOnMXFailure = (0, smithy_client_1.expectString)(output["BehaviorOnMXFailure"]);
                }
                return contents;
            };
            const deserializeAws_queryIdentityNotificationAttributes = (output, context) => {
                const contents = {
                    BounceTopic: undefined,
                    ComplaintTopic: undefined,
                    DeliveryTopic: undefined,
                    ForwardingEnabled: undefined,
                    HeadersInBounceNotificationsEnabled: undefined,
                    HeadersInComplaintNotificationsEnabled: undefined,
                    HeadersInDeliveryNotificationsEnabled: undefined,
                };
                if (output["BounceTopic"] !== undefined) {
                    contents.BounceTopic = (0, smithy_client_1.expectString)(output["BounceTopic"]);
                }
                if (output["ComplaintTopic"] !== undefined) {
                    contents.ComplaintTopic = (0, smithy_client_1.expectString)(output["ComplaintTopic"]);
                }
                if (output["DeliveryTopic"] !== undefined) {
                    contents.DeliveryTopic = (0, smithy_client_1.expectString)(output["DeliveryTopic"]);
                }
                if (output["ForwardingEnabled"] !== undefined) {
                    contents.ForwardingEnabled = (0, smithy_client_1.parseBoolean)(output["ForwardingEnabled"]);
                }
                if (output["HeadersInBounceNotificationsEnabled"] !== undefined) {
                    contents.HeadersInBounceNotificationsEnabled = (0, smithy_client_1.parseBoolean)(output["HeadersInBounceNotificationsEnabled"]);
                }
                if (output["HeadersInComplaintNotificationsEnabled"] !== undefined) {
                    contents.HeadersInComplaintNotificationsEnabled = (0, smithy_client_1.parseBoolean)(output["HeadersInComplaintNotificationsEnabled"]);
                }
                if (output["HeadersInDeliveryNotificationsEnabled"] !== undefined) {
                    contents.HeadersInDeliveryNotificationsEnabled = (0, smithy_client_1.parseBoolean)(output["HeadersInDeliveryNotificationsEnabled"]);
                }
                return contents;
            };
            const deserializeAws_queryIdentityVerificationAttributes = (output, context) => {
                const contents = {
                    VerificationStatus: undefined,
                    VerificationToken: undefined,
                };
                if (output["VerificationStatus"] !== undefined) {
                    contents.VerificationStatus = (0, smithy_client_1.expectString)(output["VerificationStatus"]);
                }
                if (output["VerificationToken"] !== undefined) {
                    contents.VerificationToken = (0, smithy_client_1.expectString)(output["VerificationToken"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidCloudWatchDestinationException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    EventDestinationName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["EventDestinationName"] !== undefined) {
                    contents.EventDestinationName = (0, smithy_client_1.expectString)(output["EventDestinationName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidConfigurationSetException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidDeliveryOptionsException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidFirehoseDestinationException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    EventDestinationName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["EventDestinationName"] !== undefined) {
                    contents.EventDestinationName = (0, smithy_client_1.expectString)(output["EventDestinationName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidLambdaFunctionException = (output, context) => {
                const contents = {
                    FunctionArn: undefined,
                    message: undefined,
                };
                if (output["FunctionArn"] !== undefined) {
                    contents.FunctionArn = (0, smithy_client_1.expectString)(output["FunctionArn"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidPolicyException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidRenderingParameterException = (output, context) => {
                const contents = {
                    TemplateName: undefined,
                    message: undefined,
                };
                if (output["TemplateName"] !== undefined) {
                    contents.TemplateName = (0, smithy_client_1.expectString)(output["TemplateName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidS3ConfigurationException = (output, context) => {
                const contents = {
                    Bucket: undefined,
                    message: undefined,
                };
                if (output["Bucket"] !== undefined) {
                    contents.Bucket = (0, smithy_client_1.expectString)(output["Bucket"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidSNSDestinationException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    EventDestinationName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["EventDestinationName"] !== undefined) {
                    contents.EventDestinationName = (0, smithy_client_1.expectString)(output["EventDestinationName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidSnsTopicException = (output, context) => {
                const contents = {
                    Topic: undefined,
                    message: undefined,
                };
                if (output["Topic"] !== undefined) {
                    contents.Topic = (0, smithy_client_1.expectString)(output["Topic"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidTemplateException = (output, context) => {
                const contents = {
                    TemplateName: undefined,
                    message: undefined,
                };
                if (output["TemplateName"] !== undefined) {
                    contents.TemplateName = (0, smithy_client_1.expectString)(output["TemplateName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryInvalidTrackingOptionsException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryKinesisFirehoseDestination = (output, context) => {
                const contents = {
                    IAMRoleARN: undefined,
                    DeliveryStreamARN: undefined,
                };
                if (output["IAMRoleARN"] !== undefined) {
                    contents.IAMRoleARN = (0, smithy_client_1.expectString)(output["IAMRoleARN"]);
                }
                if (output["DeliveryStreamARN"] !== undefined) {
                    contents.DeliveryStreamARN = (0, smithy_client_1.expectString)(output["DeliveryStreamARN"]);
                }
                return contents;
            };
            const deserializeAws_queryLambdaAction = (output, context) => {
                const contents = {
                    TopicArn: undefined,
                    FunctionArn: undefined,
                    InvocationType: undefined,
                };
                if (output["TopicArn"] !== undefined) {
                    contents.TopicArn = (0, smithy_client_1.expectString)(output["TopicArn"]);
                }
                if (output["FunctionArn"] !== undefined) {
                    contents.FunctionArn = (0, smithy_client_1.expectString)(output["FunctionArn"]);
                }
                if (output["InvocationType"] !== undefined) {
                    contents.InvocationType = (0, smithy_client_1.expectString)(output["InvocationType"]);
                }
                return contents;
            };
            const deserializeAws_queryLimitExceededException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryListConfigurationSetsResponse = (output, context) => {
                const contents = {
                    ConfigurationSets: undefined,
                    NextToken: undefined,
                };
                if (output.ConfigurationSets === "") {
                    contents.ConfigurationSets = [];
                }
                if (output["ConfigurationSets"] !== undefined && output["ConfigurationSets"]["member"] !== undefined) {
                    contents.ConfigurationSets = deserializeAws_queryConfigurationSets((0, smithy_client_1.getArrayIfSingleItem)(output["ConfigurationSets"]["member"]), context);
                }
                if (output["NextToken"] !== undefined) {
                    contents.NextToken = (0, smithy_client_1.expectString)(output["NextToken"]);
                }
                return contents;
            };
            const deserializeAws_queryListCustomVerificationEmailTemplatesResponse = (output, context) => {
                const contents = {
                    CustomVerificationEmailTemplates: undefined,
                    NextToken: undefined,
                };
                if (output.CustomVerificationEmailTemplates === "") {
                    contents.CustomVerificationEmailTemplates = [];
                }
                if (output["CustomVerificationEmailTemplates"] !== undefined &&
                    output["CustomVerificationEmailTemplates"]["member"] !== undefined) {
                    contents.CustomVerificationEmailTemplates = deserializeAws_queryCustomVerificationEmailTemplates((0, smithy_client_1.getArrayIfSingleItem)(output["CustomVerificationEmailTemplates"]["member"]), context);
                }
                if (output["NextToken"] !== undefined) {
                    contents.NextToken = (0, smithy_client_1.expectString)(output["NextToken"]);
                }
                return contents;
            };
            const deserializeAws_queryListIdentitiesResponse = (output, context) => {
                const contents = {
                    Identities: undefined,
                    NextToken: undefined,
                };
                if (output.Identities === "") {
                    contents.Identities = [];
                }
                if (output["Identities"] !== undefined && output["Identities"]["member"] !== undefined) {
                    contents.Identities = deserializeAws_queryIdentityList((0, smithy_client_1.getArrayIfSingleItem)(output["Identities"]["member"]), context);
                }
                if (output["NextToken"] !== undefined) {
                    contents.NextToken = (0, smithy_client_1.expectString)(output["NextToken"]);
                }
                return contents;
            };
            const deserializeAws_queryListIdentityPoliciesResponse = (output, context) => {
                const contents = {
                    PolicyNames: undefined,
                };
                if (output.PolicyNames === "") {
                    contents.PolicyNames = [];
                }
                if (output["PolicyNames"] !== undefined && output["PolicyNames"]["member"] !== undefined) {
                    contents.PolicyNames = deserializeAws_queryPolicyNameList((0, smithy_client_1.getArrayIfSingleItem)(output["PolicyNames"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryListReceiptFiltersResponse = (output, context) => {
                const contents = {
                    Filters: undefined,
                };
                if (output.Filters === "") {
                    contents.Filters = [];
                }
                if (output["Filters"] !== undefined && output["Filters"]["member"] !== undefined) {
                    contents.Filters = deserializeAws_queryReceiptFilterList((0, smithy_client_1.getArrayIfSingleItem)(output["Filters"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryListReceiptRuleSetsResponse = (output, context) => {
                const contents = {
                    RuleSets: undefined,
                    NextToken: undefined,
                };
                if (output.RuleSets === "") {
                    contents.RuleSets = [];
                }
                if (output["RuleSets"] !== undefined && output["RuleSets"]["member"] !== undefined) {
                    contents.RuleSets = deserializeAws_queryReceiptRuleSetsLists((0, smithy_client_1.getArrayIfSingleItem)(output["RuleSets"]["member"]), context);
                }
                if (output["NextToken"] !== undefined) {
                    contents.NextToken = (0, smithy_client_1.expectString)(output["NextToken"]);
                }
                return contents;
            };
            const deserializeAws_queryListTemplatesResponse = (output, context) => {
                const contents = {
                    TemplatesMetadata: undefined,
                    NextToken: undefined,
                };
                if (output.TemplatesMetadata === "") {
                    contents.TemplatesMetadata = [];
                }
                if (output["TemplatesMetadata"] !== undefined && output["TemplatesMetadata"]["member"] !== undefined) {
                    contents.TemplatesMetadata = deserializeAws_queryTemplateMetadataList((0, smithy_client_1.getArrayIfSingleItem)(output["TemplatesMetadata"]["member"]), context);
                }
                if (output["NextToken"] !== undefined) {
                    contents.NextToken = (0, smithy_client_1.expectString)(output["NextToken"]);
                }
                return contents;
            };
            const deserializeAws_queryListVerifiedEmailAddressesResponse = (output, context) => {
                const contents = {
                    VerifiedEmailAddresses: undefined,
                };
                if (output.VerifiedEmailAddresses === "") {
                    contents.VerifiedEmailAddresses = [];
                }
                if (output["VerifiedEmailAddresses"] !== undefined && output["VerifiedEmailAddresses"]["member"] !== undefined) {
                    contents.VerifiedEmailAddresses = deserializeAws_queryAddressList((0, smithy_client_1.getArrayIfSingleItem)(output["VerifiedEmailAddresses"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryMailFromDomainAttributes = (output, context) => {
                return output.reduce((acc, pair) => {
                    if (pair["value"] === null) {
                        return acc;
                    }
                    return {
                        ...acc,
                        [pair["key"]]: deserializeAws_queryIdentityMailFromDomainAttributes(pair["value"], context),
                    };
                }, {});
            };
            const deserializeAws_queryMailFromDomainNotVerifiedException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryMessageRejected = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryMissingRenderingAttributeException = (output, context) => {
                const contents = {
                    TemplateName: undefined,
                    message: undefined,
                };
                if (output["TemplateName"] !== undefined) {
                    contents.TemplateName = (0, smithy_client_1.expectString)(output["TemplateName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryNotificationAttributes = (output, context) => {
                return output.reduce((acc, pair) => {
                    if (pair["value"] === null) {
                        return acc;
                    }
                    return {
                        ...acc,
                        [pair["key"]]: deserializeAws_queryIdentityNotificationAttributes(pair["value"], context),
                    };
                }, {});
            };
            const deserializeAws_queryPolicyMap = (output, context) => {
                return output.reduce((acc, pair) => {
                    if (pair["value"] === null) {
                        return acc;
                    }
                    return {
                        ...acc,
                        [pair["key"]]: (0, smithy_client_1.expectString)(pair["value"]),
                    };
                }, {});
            };
            const deserializeAws_queryPolicyNameList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return (0, smithy_client_1.expectString)(entry);
                    });
            };
            const deserializeAws_queryProductionAccessNotGrantedException = (output, context) => {
                const contents = {
                    message: undefined,
                };
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryPutConfigurationSetDeliveryOptionsResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryPutIdentityPolicyResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryReceiptAction = (output, context) => {
                const contents = {
                    S3Action: undefined,
                    BounceAction: undefined,
                    WorkmailAction: undefined,
                    LambdaAction: undefined,
                    StopAction: undefined,
                    AddHeaderAction: undefined,
                    SNSAction: undefined,
                };
                if (output["S3Action"] !== undefined) {
                    contents.S3Action = deserializeAws_queryS3Action(output["S3Action"], context);
                }
                if (output["BounceAction"] !== undefined) {
                    contents.BounceAction = deserializeAws_queryBounceAction(output["BounceAction"], context);
                }
                if (output["WorkmailAction"] !== undefined) {
                    contents.WorkmailAction = deserializeAws_queryWorkmailAction(output["WorkmailAction"], context);
                }
                if (output["LambdaAction"] !== undefined) {
                    contents.LambdaAction = deserializeAws_queryLambdaAction(output["LambdaAction"], context);
                }
                if (output["StopAction"] !== undefined) {
                    contents.StopAction = deserializeAws_queryStopAction(output["StopAction"], context);
                }
                if (output["AddHeaderAction"] !== undefined) {
                    contents.AddHeaderAction = deserializeAws_queryAddHeaderAction(output["AddHeaderAction"], context);
                }
                if (output["SNSAction"] !== undefined) {
                    contents.SNSAction = deserializeAws_querySNSAction(output["SNSAction"], context);
                }
                return contents;
            };
            const deserializeAws_queryReceiptActionsList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryReceiptAction(entry, context);
                    });
            };
            const deserializeAws_queryReceiptFilter = (output, context) => {
                const contents = {
                    Name: undefined,
                    IpFilter: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["IpFilter"] !== undefined) {
                    contents.IpFilter = deserializeAws_queryReceiptIpFilter(output["IpFilter"], context);
                }
                return contents;
            };
            const deserializeAws_queryReceiptFilterList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryReceiptFilter(entry, context);
                    });
            };
            const deserializeAws_queryReceiptIpFilter = (output, context) => {
                const contents = {
                    Policy: undefined,
                    Cidr: undefined,
                };
                if (output["Policy"] !== undefined) {
                    contents.Policy = (0, smithy_client_1.expectString)(output["Policy"]);
                }
                if (output["Cidr"] !== undefined) {
                    contents.Cidr = (0, smithy_client_1.expectString)(output["Cidr"]);
                }
                return contents;
            };
            const deserializeAws_queryReceiptRule = (output, context) => {
                const contents = {
                    Name: undefined,
                    Enabled: undefined,
                    TlsPolicy: undefined,
                    Recipients: undefined,
                    Actions: undefined,
                    ScanEnabled: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["Enabled"] !== undefined) {
                    contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
                }
                if (output["TlsPolicy"] !== undefined) {
                    contents.TlsPolicy = (0, smithy_client_1.expectString)(output["TlsPolicy"]);
                }
                if (output.Recipients === "") {
                    contents.Recipients = [];
                }
                if (output["Recipients"] !== undefined && output["Recipients"]["member"] !== undefined) {
                    contents.Recipients = deserializeAws_queryRecipientsList((0, smithy_client_1.getArrayIfSingleItem)(output["Recipients"]["member"]), context);
                }
                if (output.Actions === "") {
                    contents.Actions = [];
                }
                if (output["Actions"] !== undefined && output["Actions"]["member"] !== undefined) {
                    contents.Actions = deserializeAws_queryReceiptActionsList((0, smithy_client_1.getArrayIfSingleItem)(output["Actions"]["member"]), context);
                }
                if (output["ScanEnabled"] !== undefined) {
                    contents.ScanEnabled = (0, smithy_client_1.parseBoolean)(output["ScanEnabled"]);
                }
                return contents;
            };
            const deserializeAws_queryReceiptRuleSetMetadata = (output, context) => {
                const contents = {
                    Name: undefined,
                    CreatedTimestamp: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["CreatedTimestamp"] !== undefined) {
                    contents.CreatedTimestamp = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["CreatedTimestamp"]));
                }
                return contents;
            };
            const deserializeAws_queryReceiptRuleSetsLists = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryReceiptRuleSetMetadata(entry, context);
                    });
            };
            const deserializeAws_queryReceiptRulesList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryReceiptRule(entry, context);
                    });
            };
            const deserializeAws_queryRecipientsList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return (0, smithy_client_1.expectString)(entry);
                    });
            };
            const deserializeAws_queryReorderReceiptRuleSetResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryReputationOptions = (output, context) => {
                const contents = {
                    SendingEnabled: undefined,
                    ReputationMetricsEnabled: undefined,
                    LastFreshStart: undefined,
                };
                if (output["SendingEnabled"] !== undefined) {
                    contents.SendingEnabled = (0, smithy_client_1.parseBoolean)(output["SendingEnabled"]);
                }
                if (output["ReputationMetricsEnabled"] !== undefined) {
                    contents.ReputationMetricsEnabled = (0, smithy_client_1.parseBoolean)(output["ReputationMetricsEnabled"]);
                }
                if (output["LastFreshStart"] !== undefined) {
                    contents.LastFreshStart = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["LastFreshStart"]));
                }
                return contents;
            };
            const deserializeAws_queryRuleDoesNotExistException = (output, context) => {
                const contents = {
                    Name: undefined,
                    message: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryRuleSetDoesNotExistException = (output, context) => {
                const contents = {
                    Name: undefined,
                    message: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryS3Action = (output, context) => {
                const contents = {
                    TopicArn: undefined,
                    BucketName: undefined,
                    ObjectKeyPrefix: undefined,
                    KmsKeyArn: undefined,
                };
                if (output["TopicArn"] !== undefined) {
                    contents.TopicArn = (0, smithy_client_1.expectString)(output["TopicArn"]);
                }
                if (output["BucketName"] !== undefined) {
                    contents.BucketName = (0, smithy_client_1.expectString)(output["BucketName"]);
                }
                if (output["ObjectKeyPrefix"] !== undefined) {
                    contents.ObjectKeyPrefix = (0, smithy_client_1.expectString)(output["ObjectKeyPrefix"]);
                }
                if (output["KmsKeyArn"] !== undefined) {
                    contents.KmsKeyArn = (0, smithy_client_1.expectString)(output["KmsKeyArn"]);
                }
                return contents;
            };
            const deserializeAws_querySendBounceResponse = (output, context) => {
                const contents = {
                    MessageId: undefined,
                };
                if (output["MessageId"] !== undefined) {
                    contents.MessageId = (0, smithy_client_1.expectString)(output["MessageId"]);
                }
                return contents;
            };
            const deserializeAws_querySendBulkTemplatedEmailResponse = (output, context) => {
                const contents = {
                    Status: undefined,
                };
                if (output.Status === "") {
                    contents.Status = [];
                }
                if (output["Status"] !== undefined && output["Status"]["member"] !== undefined) {
                    contents.Status = deserializeAws_queryBulkEmailDestinationStatusList((0, smithy_client_1.getArrayIfSingleItem)(output["Status"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_querySendCustomVerificationEmailResponse = (output, context) => {
                const contents = {
                    MessageId: undefined,
                };
                if (output["MessageId"] !== undefined) {
                    contents.MessageId = (0, smithy_client_1.expectString)(output["MessageId"]);
                }
                return contents;
            };
            const deserializeAws_querySendDataPoint = (output, context) => {
                const contents = {
                    Timestamp: undefined,
                    DeliveryAttempts: undefined,
                    Bounces: undefined,
                    Complaints: undefined,
                    Rejects: undefined,
                };
                if (output["Timestamp"] !== undefined) {
                    contents.Timestamp = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["Timestamp"]));
                }
                if (output["DeliveryAttempts"] !== undefined) {
                    contents.DeliveryAttempts = (0, smithy_client_1.strictParseLong)(output["DeliveryAttempts"]);
                }
                if (output["Bounces"] !== undefined) {
                    contents.Bounces = (0, smithy_client_1.strictParseLong)(output["Bounces"]);
                }
                if (output["Complaints"] !== undefined) {
                    contents.Complaints = (0, smithy_client_1.strictParseLong)(output["Complaints"]);
                }
                if (output["Rejects"] !== undefined) {
                    contents.Rejects = (0, smithy_client_1.strictParseLong)(output["Rejects"]);
                }
                return contents;
            };
            const deserializeAws_querySendDataPointList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_querySendDataPoint(entry, context);
                    });
            };
            const deserializeAws_querySendEmailResponse = (output, context) => {
                const contents = {
                    MessageId: undefined,
                };
                if (output["MessageId"] !== undefined) {
                    contents.MessageId = (0, smithy_client_1.expectString)(output["MessageId"]);
                }
                return contents;
            };
            const deserializeAws_querySendRawEmailResponse = (output, context) => {
                const contents = {
                    MessageId: undefined,
                };
                if (output["MessageId"] !== undefined) {
                    contents.MessageId = (0, smithy_client_1.expectString)(output["MessageId"]);
                }
                return contents;
            };
            const deserializeAws_querySendTemplatedEmailResponse = (output, context) => {
                const contents = {
                    MessageId: undefined,
                };
                if (output["MessageId"] !== undefined) {
                    contents.MessageId = (0, smithy_client_1.expectString)(output["MessageId"]);
                }
                return contents;
            };
            const deserializeAws_querySetActiveReceiptRuleSetResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_querySetIdentityDkimEnabledResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_querySetIdentityFeedbackForwardingEnabledResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_querySetIdentityHeadersInNotificationsEnabledResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_querySetIdentityMailFromDomainResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_querySetIdentityNotificationTopicResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_querySetReceiptRulePositionResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_querySNSAction = (output, context) => {
                const contents = {
                    TopicArn: undefined,
                    Encoding: undefined,
                };
                if (output["TopicArn"] !== undefined) {
                    contents.TopicArn = (0, smithy_client_1.expectString)(output["TopicArn"]);
                }
                if (output["Encoding"] !== undefined) {
                    contents.Encoding = (0, smithy_client_1.expectString)(output["Encoding"]);
                }
                return contents;
            };
            const deserializeAws_querySNSDestination = (output, context) => {
                const contents = {
                    TopicARN: undefined,
                };
                if (output["TopicARN"] !== undefined) {
                    contents.TopicARN = (0, smithy_client_1.expectString)(output["TopicARN"]);
                }
                return contents;
            };
            const deserializeAws_queryStopAction = (output, context) => {
                const contents = {
                    Scope: undefined,
                    TopicArn: undefined,
                };
                if (output["Scope"] !== undefined) {
                    contents.Scope = (0, smithy_client_1.expectString)(output["Scope"]);
                }
                if (output["TopicArn"] !== undefined) {
                    contents.TopicArn = (0, smithy_client_1.expectString)(output["TopicArn"]);
                }
                return contents;
            };
            const deserializeAws_queryTemplate = (output, context) => {
                const contents = {
                    TemplateName: undefined,
                    SubjectPart: undefined,
                    TextPart: undefined,
                    HtmlPart: undefined,
                };
                if (output["TemplateName"] !== undefined) {
                    contents.TemplateName = (0, smithy_client_1.expectString)(output["TemplateName"]);
                }
                if (output["SubjectPart"] !== undefined) {
                    contents.SubjectPart = (0, smithy_client_1.expectString)(output["SubjectPart"]);
                }
                if (output["TextPart"] !== undefined) {
                    contents.TextPart = (0, smithy_client_1.expectString)(output["TextPart"]);
                }
                if (output["HtmlPart"] !== undefined) {
                    contents.HtmlPart = (0, smithy_client_1.expectString)(output["HtmlPart"]);
                }
                return contents;
            };
            const deserializeAws_queryTemplateDoesNotExistException = (output, context) => {
                const contents = {
                    TemplateName: undefined,
                    message: undefined,
                };
                if (output["TemplateName"] !== undefined) {
                    contents.TemplateName = (0, smithy_client_1.expectString)(output["TemplateName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryTemplateMetadata = (output, context) => {
                const contents = {
                    Name: undefined,
                    CreatedTimestamp: undefined,
                };
                if (output["Name"] !== undefined) {
                    contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
                }
                if (output["CreatedTimestamp"] !== undefined) {
                    contents.CreatedTimestamp = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["CreatedTimestamp"]));
                }
                return contents;
            };
            const deserializeAws_queryTemplateMetadataList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_queryTemplateMetadata(entry, context);
                    });
            };
            const deserializeAws_queryTestRenderTemplateResponse = (output, context) => {
                const contents = {
                    RenderedTemplate: undefined,
                };
                if (output["RenderedTemplate"] !== undefined) {
                    contents.RenderedTemplate = (0, smithy_client_1.expectString)(output["RenderedTemplate"]);
                }
                return contents;
            };
            const deserializeAws_queryTrackingOptions = (output, context) => {
                const contents = {
                    CustomRedirectDomain: undefined,
                };
                if (output["CustomRedirectDomain"] !== undefined) {
                    contents.CustomRedirectDomain = (0, smithy_client_1.expectString)(output["CustomRedirectDomain"]);
                }
                return contents;
            };
            const deserializeAws_queryTrackingOptionsAlreadyExistsException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryTrackingOptionsDoesNotExistException = (output, context) => {
                const contents = {
                    ConfigurationSetName: undefined,
                    message: undefined,
                };
                if (output["ConfigurationSetName"] !== undefined) {
                    contents.ConfigurationSetName = (0, smithy_client_1.expectString)(output["ConfigurationSetName"]);
                }
                if (output["message"] !== undefined) {
                    contents.message = (0, smithy_client_1.expectString)(output["message"]);
                }
                return contents;
            };
            const deserializeAws_queryUpdateConfigurationSetEventDestinationResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryUpdateConfigurationSetTrackingOptionsResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryUpdateReceiptRuleResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryUpdateTemplateResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryVerificationAttributes = (output, context) => {
                return output.reduce((acc, pair) => {
                    if (pair["value"] === null) {
                        return acc;
                    }
                    return {
                        ...acc,
                        [pair["key"]]: deserializeAws_queryIdentityVerificationAttributes(pair["value"], context),
                    };
                }, {});
            };
            const deserializeAws_queryVerificationTokenList = (output, context) => {
                return (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return (0, smithy_client_1.expectString)(entry);
                    });
            };
            const deserializeAws_queryVerifyDomainDkimResponse = (output, context) => {
                const contents = {
                    DkimTokens: undefined,
                };
                if (output.DkimTokens === "") {
                    contents.DkimTokens = [];
                }
                if (output["DkimTokens"] !== undefined && output["DkimTokens"]["member"] !== undefined) {
                    contents.DkimTokens = deserializeAws_queryVerificationTokenList((0, smithy_client_1.getArrayIfSingleItem)(output["DkimTokens"]["member"]), context);
                }
                return contents;
            };
            const deserializeAws_queryVerifyDomainIdentityResponse = (output, context) => {
                const contents = {
                    VerificationToken: undefined,
                };
                if (output["VerificationToken"] !== undefined) {
                    contents.VerificationToken = (0, smithy_client_1.expectString)(output["VerificationToken"]);
                }
                return contents;
            };
            const deserializeAws_queryVerifyEmailIdentityResponse = (output, context) => {
                const contents = {};
                return contents;
            };
            const deserializeAws_queryWorkmailAction = (output, context) => {
                const contents = {
                    TopicArn: undefined,
                    OrganizationArn: undefined,
                };
                if (output["TopicArn"] !== undefined) {
                    contents.TopicArn = (0, smithy_client_1.expectString)(output["TopicArn"]);
                }
                if (output["OrganizationArn"] !== undefined) {
                    contents.OrganizationArn = (0, smithy_client_1.expectString)(output["OrganizationArn"]);
                }
                return contents;
            };
            const deserializeMetadata = (output) => {
                var _a;
                return ({
                    httpStatusCode: output.statusCode,
                    requestId: (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"],
                    extendedRequestId: output.headers["x-amz-id-2"],
                    cfId: output.headers["x-amz-cf-id"],
                });
            };
            const collectBody = (streamBody = new Uint8Array(), context) => {
                if (streamBody instanceof Uint8Array) {
                    return Promise.resolve(streamBody);
                }
                return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
            };
            const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
            const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
                const {hostname, protocol = "https", port, path: basePath} = await context.endpoint();
                const contents = {
                    protocol,
                    hostname,
                    port,
                    method: "POST",
                    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
                    headers,
                };
                if (resolvedHostname !== undefined) {
                    contents.hostname = resolvedHostname;
                }
                if (body !== undefined) {
                    contents.body = body;
                }
                return new protocol_http_1.HttpRequest(contents);
            };
            const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
                if (encoded.length) {
                    const parsedObj = (0, fast_xml_parser_1.parse)(encoded, {
                        attributeNamePrefix: "",
                        ignoreAttributes: false,
                        parseNodeValue: false,
                        trimValues: false,
                        tagValueProcessor: (val) => (val.trim() === "" && val.includes("\n") ? "" : (0, entities_1.decodeHTML)(val)),
                    });
                    const textNodeName = "#text";
                    const key = Object.keys(parsedObj)[0];
                    const parsedObjToReturn = parsedObj[key];
                    if (parsedObjToReturn[textNodeName]) {
                        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
                        delete parsedObjToReturn[textNodeName];
                    }
                    return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
                }
                return {};
            });
            const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
                .map(([key, value]) => (0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value))
                .join("&");
            const loadQueryErrorCode = (output, data) => {
                if (data.Error.Code !== undefined) {
                    return data.Error.Code;
                }
                if (output.statusCode == 404) {
                    return "NotFound";
                }
                return "";
            };


            /***/
        }),
        /* 408 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.loadConfig = void 0;
            const property_provider_1 = __webpack_require__(118);
            const fromEnv_1 = __webpack_require__(325);
            const fromSharedConfigFiles_1 = __webpack_require__(220);
            const fromStatic_1 = __webpack_require__(923);
            const loadConfig = ({
                                    environmentVariableSelector,
                                    configFileSelector,
                                    default: defaultValue
                                }, configuration = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromEnv_1.fromEnv)(environmentVariableSelector), (0, fromSharedConfigFiles_1.fromSharedConfigFiles)(configFileSelector, configuration), (0, fromStatic_1.fromStatic)(defaultValue)));
            exports.loadConfig = loadConfig;


            /***/
        }),
        /* 409 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 410 */
        /***/ (function (__unusedmodule, __unusedexports, __webpack_require__) {

            "use strict";


            const core = __webpack_require__(357);
            const github = __webpack_require__(955);
            let nodemailer = __webpack_require__(305);
            let aws = __webpack_require__(662);

            async function main() {

                // from: process.env.FROM,
                //     to: process.env.TO,
                //     subject: process.env.SUBJECT,
                //     text: process.env.BODY,
                //     html: process.env.BODY,

                const to = core.getInput('to');
                const from = core.getInput('from');
                const subject = core.getInput('subject');
                const body = core.getInput('body');

                const ses = new aws.SES({
                    apiVersion: "2010-12-01",
                    region: "us-east-1",
                });
                let transporter = nodemailer.createTransport({
                    SES: {ses, aws},
                });

                // send mail with defined transport object
                const info = await transporter.sendMail({
                    from: from,
                    to: to,
                    subject: subject,
                    text: body,
                    html: body,
                });

                console.log("Message sent: %s", info.messageId);

                // Preview only available when sending through an Ethereal account
                console.log("Preview URL: %s", nodemailer.getTestMessageUrl(info));
                // Preview URL: https://ethereal.email/message/WaQKMgKddxQDoou...
            }

            main().catch(err => core.setFailed(err));


            /***/
        }),
        /* 411 */,
        /* 412 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.VerifyEmailIdentityCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class VerifyEmailIdentityCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "VerifyEmailIdentityCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.VerifyEmailIdentityRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.VerifyEmailIdentityResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryVerifyEmailIdentityCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryVerifyEmailIdentityCommand)(output, context);
                }
            }

            exports.VerifyEmailIdentityCommand = VerifyEmailIdentityCommand;


            /***/
        }),
        /* 413 */
        /***/ (function (module) {

            module.exports = require("stream");

            /***/
        }),
        /* 414 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetSessionTokenCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const middleware_signing_1 = __webpack_require__(22);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(575);
            const Aws_query_1 = __webpack_require__(139);

            class GetSessionTokenCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "STSClient";
                    const commandName = "GetSessionTokenCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetSessionTokenRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetSessionTokenResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetSessionTokenCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetSessionTokenCommand)(output, context);
                }
            }

            exports.GetSessionTokenCommand = GetSessionTokenCommand;


            /***/
        }),
        /* 415 */,
        /* 416 */,
        /* 417 */
        /***/ (function (module) {

            module.exports = require("crypto");

            /***/
        }),
        /* 418 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveEndpointsConfig = void 0;
            const util_middleware_1 = __webpack_require__(552);
            const getEndpointFromRegion_1 = __webpack_require__(257);
            const resolveEndpointsConfig = (input) => {
                var _a;
                const useDualstackEndpoint = (0, util_middleware_1.normalizeProvider)(input.useDualstackEndpoint);
                const {endpoint, useFipsEndpoint, urlParser} = input;
                return {
                    ...input,
                    tls: (_a = input.tls) !== null && _a !== void 0 ? _a : true,
                    endpoint: endpoint
                        ? (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
                        : () => (0, getEndpointFromRegion_1.getEndpointFromRegion)({
                            ...input,
                            useDualstackEndpoint,
                            useFipsEndpoint
                        }),
                    isCustomEndpoint: endpoint ? true : false,
                    useDualstackEndpoint,
                };
            };
            exports.resolveEndpointsConfig = resolveEndpointsConfig;


            /***/
        }),
        /* 419 */,
        /* 420 */,
        /* 421 */,
        /* 422 */,
        /* 423 */,
        /* 424 */,
        /* 425 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteCustomVerificationEmailTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteCustomVerificationEmailTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteCustomVerificationEmailTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteCustomVerificationEmailTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteCustomVerificationEmailTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteCustomVerificationEmailTemplateCommand)(output, context);
                }
            }

            exports.DeleteCustomVerificationEmailTemplateCommand = DeleteCustomVerificationEmailTemplateCommand;


            /***/
        }),
        /* 426 */,
        /* 427 */,
        /* 428 */,
        /* 429 */,
        /* 430 */,
        /* 431 */,
        /* 432 */,
        /* 433 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.Context = void 0;
            const fs_1 = __webpack_require__(747);
            const os_1 = __webpack_require__(87);

            class Context {
                /**
                 * Hydrate the context from the environment
                 */
                constructor() {
                    var _a, _b, _c;
                    this.payload = {};
                    if (process.env.GITHUB_EVENT_PATH) {
                        if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                            this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, {encoding: 'utf8'}));
                        } else {
                            const path = process.env.GITHUB_EVENT_PATH;
                            process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
                        }
                    }
                    this.eventName = process.env.GITHUB_EVENT_NAME;
                    this.sha = process.env.GITHUB_SHA;
                    this.ref = process.env.GITHUB_REF;
                    this.workflow = process.env.GITHUB_WORKFLOW;
                    this.action = process.env.GITHUB_ACTION;
                    this.actor = process.env.GITHUB_ACTOR;
                    this.job = process.env.GITHUB_JOB;
                    this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
                    this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
                    this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
                    this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
                    this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
                }

                get issue() {
                    const payload = this.payload;
                    return Object.assign(Object.assign({}, this.repo), {number: (payload.issue || payload.pull_request || payload).number});
                }

                get repo() {
                    if (process.env.GITHUB_REPOSITORY) {
                        const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
                        return {owner, repo};
                    }
                    if (this.payload.repository) {
                        return {
                            owner: this.payload.repository.owner.login,
                            repo: this.payload.repository.name
                        };
                    }
                    throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
                }
            }

            exports.Context = Context;
//# sourceMappingURL=context.js.map

            /***/
        }),
        /* 434 */
        /***/ (function (module) {

            module.exports = register;

            function register(state, name, method, options) {
                if (typeof method !== "function") {
                    throw new Error("method for before hook must be a function");
                }

                if (!options) {
                    options = {};
                }

                if (Array.isArray(name)) {
                    return name.reverse().reduce(function (callback, name) {
                        return register.bind(null, state, name, callback, options);
                    }, method)();
                }

                return Promise.resolve().then(function () {
                    if (!state.registry[name]) {
                        return method(options);
                    }

                    return state.registry[name].reduce(function (method, registered) {
                        return registered.hook.bind(null, method, options);
                    }, method)();
                });
            }


            /***/
        }),
        /* 435 */,
        /* 436 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const Transform = __webpack_require__(413).Transform;

            /**
             * MessageParser instance is a transform stream that separates message headers
             * from the rest of the body. Headers are emitted with the 'headers' event. Message
             * body is passed on as the resulting stream.
             */
            class MessageParser extends Transform {
                constructor(options) {
                    super(options);
                    this.lastBytes = Buffer.alloc(4);
                    this.headersParsed = false;
                    this.headerBytes = 0;
                    this.headerChunks = [];
                    this.rawHeaders = false;
                    this.bodySize = 0;
                }

                /**
                 * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries
                 *
                 * @param {Buffer} data Next data chunk from the stream
                 */
                updateLastBytes(data) {
                    let lblen = this.lastBytes.length;
                    let nblen = Math.min(data.length, lblen);

                    // shift existing bytes
                    for (let i = 0, len = lblen - nblen; i < len; i++) {
                        this.lastBytes[i] = this.lastBytes[i + nblen];
                    }

                    // add new bytes
                    for (let i = 1; i <= nblen; i++) {
                        this.lastBytes[lblen - i] = data[data.length - i];
                    }
                }

                /**
                 * Finds and removes message headers from the remaining body. We want to keep
                 * headers separated until final delivery to be able to modify these
                 *
                 * @param {Buffer} data Next chunk of data
                 * @return {Boolean} Returns true if headers are already found or false otherwise
                 */
                checkHeaders(data) {
                    if (this.headersParsed) {
                        return true;
                    }

                    let lblen = this.lastBytes.length;
                    let headerPos = 0;
                    this.curLinePos = 0;
                    for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {
                        let chr;
                        if (i < lblen) {
                            chr = this.lastBytes[i];
                        } else {
                            chr = data[i - lblen];
                        }
                        if (chr === 0x0a && i) {
                            let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
                            let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;
                            if (pr1 === 0x0a) {
                                this.headersParsed = true;
                                headerPos = i - lblen + 1;
                                this.headerBytes += headerPos;
                                break;
                            } else if (pr1 === 0x0d && pr2 === 0x0a) {
                                this.headersParsed = true;
                                headerPos = i - lblen + 1;
                                this.headerBytes += headerPos;
                                break;
                            }
                        }
                    }

                    if (this.headersParsed) {
                        this.headerChunks.push(data.slice(0, headerPos));
                        this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
                        this.headerChunks = null;
                        this.emit('headers', this.parseHeaders());
                        if (data.length - 1 > headerPos) {
                            let chunk = data.slice(headerPos);
                            this.bodySize += chunk.length;
                            // this would be the first chunk of data sent downstream
                            setImmediate(() => this.push(chunk));
                        }
                        return false;
                    } else {
                        this.headerBytes += data.length;
                        this.headerChunks.push(data);
                    }

                    // store last 4 bytes to catch header break
                    this.updateLastBytes(data);

                    return false;
                }

                _transform(chunk, encoding, callback) {
                    if (!chunk || !chunk.length) {
                        return callback();
                    }

                    if (typeof chunk === 'string') {
                        chunk = Buffer.from(chunk, encoding);
                    }

                    let headersFound;

                    try {
                        headersFound = this.checkHeaders(chunk);
                    } catch (E) {
                        return callback(E);
                    }

                    if (headersFound) {
                        this.bodySize += chunk.length;
                        this.push(chunk);
                    }

                    setImmediate(callback);
                }

                _flush(callback) {
                    if (this.headerChunks) {
                        let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
                        this.bodySize += chunk.length;
                        this.push(chunk);
                        this.headerChunks = null;
                    }
                    callback();
                }

                parseHeaders() {
                    let lines = (this.rawHeaders || '').toString().split(/\r?\n/);
                    for (let i = lines.length - 1; i > 0; i--) {
                        if (/^\s/.test(lines[i])) {
                            lines[i - 1] += '\n' + lines[i];
                            lines.splice(i, 1);
                        }
                    }
                    return lines
                        .filter(line => line.trim())
                        .map(line => ({
                            key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),
                            line
                        }));
                }
            }

            module.exports = MessageParser;


            /***/
        }),
        /* 437 */,
        /* 438 */,
        /* 439 */,
        /* 440 */,
        /* 441 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


// streams through a message body and calculates relaxed body hash

            const Transform = __webpack_require__(413).Transform;
            const crypto = __webpack_require__(417);

            class RelaxedBody extends Transform {
                constructor(options) {
                    super();
                    options = options || {};
                    this.chunkBuffer = [];
                    this.chunkBufferLen = 0;
                    this.bodyHash = crypto.createHash(options.hashAlgo || 'sha1');
                    this.remainder = '';
                    this.byteLength = 0;

                    this.debug = options.debug;
                    this._debugBody = options.debug ? [] : false;
                }

                updateHash(chunk) {
                    let bodyStr;

                    // find next remainder
                    let nextRemainder = '';

                    // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line
                    // If we get another chunk that does not match this description then we can restore the previously processed data
                    let state = 'file';
                    for (let i = chunk.length - 1; i >= 0; i--) {
                        let c = chunk[i];

                        if (state === 'file' && (c === 0x0a || c === 0x0d)) {
                            // do nothing, found \n or \r at the end of chunk, stil end of file
                        } else if (state === 'file' && (c === 0x09 || c === 0x20)) {
                            // switch to line ending mode, this is the last non-empty line
                            state = 'line';
                        } else if (state === 'line' && (c === 0x09 || c === 0x20)) {
                            // do nothing, found ' ' or \t at the end of line, keep processing the last non-empty line
                        } else if (state === 'file' || state === 'line') {
                            // non line/file ending character found, switch to body mode
                            state = 'body';
                            if (i === chunk.length - 1) {
                                // final char is not part of line end or file end, so do nothing
                                break;
                            }
                        }

                        if (i === 0) {
                            // reached to the beginning of the chunk, check if it is still about the ending
                            // and if the remainder also matches
                            if (
                                (state === 'file' && (!this.remainder || /[\r\n]$/.test(this.remainder))) ||
                                (state === 'line' && (!this.remainder || /[ \t]$/.test(this.remainder)))
                            ) {
                                // keep everything
                                this.remainder += chunk.toString('binary');
                                return;
                            } else if (state === 'line' || state === 'file') {
                                // process existing remainder as normal line but store the current chunk
                                nextRemainder = chunk.toString('binary');
                                chunk = false;
                                break;
                            }
                        }

                        if (state !== 'body') {
                            continue;
                        }

                        // reached first non ending byte
                        nextRemainder = chunk.slice(i + 1).toString('binary');
                        chunk = chunk.slice(0, i + 1);
                        break;
                    }

                    let needsFixing = !!this.remainder;
                    if (chunk && !needsFixing) {
                        // check if we even need to change anything
                        for (let i = 0, len = chunk.length; i < len; i++) {
                            if (i && chunk[i] === 0x0a && chunk[i - 1] !== 0x0d) {
                                // missing \r before \n
                                needsFixing = true;
                                break;
                            } else if (i && chunk[i] === 0x0d && chunk[i - 1] === 0x20) {
                                // trailing WSP found
                                needsFixing = true;
                                break;
                            } else if (i && chunk[i] === 0x20 && chunk[i - 1] === 0x20) {
                                // multiple spaces found, needs to be replaced with just one
                                needsFixing = true;
                                break;
                            } else if (chunk[i] === 0x09) {
                                // TAB found, needs to be replaced with a space
                                needsFixing = true;
                                break;
                            }
                        }
                    }

                    if (needsFixing) {
                        bodyStr = this.remainder + (chunk ? chunk.toString('binary') : '');
                        this.remainder = nextRemainder;
                        bodyStr = bodyStr
                            .replace(/\r?\n/g, '\n') // use js line endings
                            .replace(/[ \t]*$/gm, '') // remove line endings, rtrim
                            .replace(/[ \t]+/gm, ' ') // single spaces
                            .replace(/\n/g, '\r\n'); // restore rfc822 line endings
                        chunk = Buffer.from(bodyStr, 'binary');
                    } else if (nextRemainder) {
                        this.remainder = nextRemainder;
                    }

                    if (this.debug) {
                        this._debugBody.push(chunk);
                    }
                    this.bodyHash.update(chunk);
                }

                _transform(chunk, encoding, callback) {
                    if (!chunk || !chunk.length) {
                        return callback();
                    }

                    if (typeof chunk === 'string') {
                        chunk = Buffer.from(chunk, encoding);
                    }

                    this.updateHash(chunk);

                    this.byteLength += chunk.length;
                    this.push(chunk);
                    callback();
                }

                _flush(callback) {
                    // generate final hash and emit it
                    if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
                        // add terminating line end
                        this.bodyHash.update(Buffer.from('\r\n'));
                    }
                    if (!this.byteLength) {
                        // emit empty line buffer to keep the stream flowing
                        this.push(Buffer.from('\r\n'));
                        // this.bodyHash.update(Buffer.from('\r\n'));
                    }

                    this.emit('hash', this.bodyHash.digest('base64'), this.debug ? Buffer.concat(this._debugBody) : false);
                    callback();
                }
            }

            module.exports = RelaxedBody;


            /***/
        }),
        /* 442 */,
        /* 443 */,
        /* 444 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetCustomVerificationEmailTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetCustomVerificationEmailTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetCustomVerificationEmailTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetCustomVerificationEmailTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetCustomVerificationEmailTemplateResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetCustomVerificationEmailTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetCustomVerificationEmailTemplateCommand)(output, context);
                }
            }

            exports.GetCustomVerificationEmailTemplateCommand = GetCustomVerificationEmailTemplateCommand;


            /***/
        }),
        /* 445 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.cloneQuery = exports.cloneRequest = void 0;
            const cloneRequest = ({headers, query, ...rest}) => ({
                ...rest,
                headers: {...headers},
                query: query ? (0, exports.cloneQuery)(query) : undefined,
            });
            exports.cloneRequest = cloneRequest;
            const cloneQuery = (query) => Object.keys(query).reduce((carry, paramName) => {
                const param = query[paramName];
                return {
                    ...carry,
                    [paramName]: Array.isArray(param) ? [...param] : param,
                };
            }, {});
            exports.cloneQuery = cloneQuery;


            /***/
        }),
        /* 446 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            const nodeToJson = __webpack_require__(148);
            const xmlToNodeobj = __webpack_require__(259);
            const x2xmlnode = __webpack_require__(259);
            const buildOptions = __webpack_require__(176).buildOptions;
            const validator = __webpack_require__(117);

            exports.parse = function (xmlData, options, validationOption) {
                if (validationOption) {
                    if (validationOption === true) validationOption = {}

                    const result = validator.validate(xmlData, validationOption);
                    if (result !== true) {
                        throw Error(result.err.msg)
                    }
                }
                options = buildOptions(options, x2xmlnode.defaultOptions, x2xmlnode.props);
                const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options)
                //print(traversableObj, "  ");
                return nodeToJson.convertToJson(traversableObj, options);
            };
            exports.convertTonimn = __webpack_require__(882).convert2nimn;
            exports.getTraversalObj = xmlToNodeobj.getTraversalObj;
            exports.convertToJson = nodeToJson.convertToJson;
            exports.convertToJsonString = __webpack_require__(953).convertToJsonString;
            exports.validate = validator.validate;
            exports.j2xParser = __webpack_require__(510);
            exports.parseToNimn = function (xmlData, schema, options) {
                return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);
            };


            function print(xmlNode, indentation) {
                if (xmlNode) {
                    console.log(indentation + "{")
                    console.log(indentation + "  \"tagName\": \"" + xmlNode.tagname + "\", ");
                    if (xmlNode.parent) {
                        console.log(indentation + "  \"parent\": \"" + xmlNode.parent.tagname + "\", ");
                    }
                    console.log(indentation + "  \"val\": \"" + xmlNode.val + "\", ");
                    console.log(indentation + "  \"attrs\": " + JSON.stringify(xmlNode.attrsMap, null, 4) + ", ");

                    if (xmlNode.child) {
                        console.log(indentation + "\"child\": {")
                        const indentation2 = indentation + indentation;
                        Object.keys(xmlNode.child).forEach(function (key) {
                            const node = xmlNode.child[key];

                            if (Array.isArray(node)) {
                                console.log(indentation + "\"" + key + "\" :[")
                                node.forEach(function (item, index) {
                                    //console.log(indentation + " \""+index+"\" : [")
                                    print(item, indentation2);
                                })
                                console.log(indentation + "],")
                            } else {
                                console.log(indentation + " \"" + key + "\" : {")
                                print(node, indentation2);
                                console.log(indentation + "},")
                            }
                        });
                        console.log(indentation + "},")
                    }
                    console.log(indentation + "},")
                }
            }


            /***/
        }),
        /* 447 */,
        /* 448 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CreateReceiptRuleCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CreateReceiptRuleCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CreateReceiptRuleCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CreateReceiptRuleRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.CreateReceiptRuleResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCreateReceiptRuleCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCreateReceiptRuleCommand)(output, context);
                }
            }

            exports.CreateReceiptRuleCommand = CreateReceiptRuleCommand;


            /***/
        }),
        /* 449 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(909), exports);
            tslib_1.__exportStar(__webpack_require__(1), exports);
            tslib_1.__exportStar(__webpack_require__(53), exports);
            tslib_1.__exportStar(__webpack_require__(958), exports);
            tslib_1.__exportStar(__webpack_require__(842), exports);
            tslib_1.__exportStar(__webpack_require__(109), exports);
            tslib_1.__exportStar(__webpack_require__(135), exports);
            tslib_1.__exportStar(__webpack_require__(915), exports);
            tslib_1.__exportStar(__webpack_require__(774), exports);
            tslib_1.__exportStar(__webpack_require__(122), exports);
            tslib_1.__exportStar(__webpack_require__(98), exports);
            tslib_1.__exportStar(__webpack_require__(80), exports);
            tslib_1.__exportStar(__webpack_require__(789), exports);
            tslib_1.__exportStar(__webpack_require__(612), exports);


            /***/
        }),
        /* 450 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getUpdatedSystemClockOffset = void 0;
            const isClockSkewed_1 = __webpack_require__(58);
            const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
                const clockTimeInMs = Date.parse(clockTime);
                if ((0, isClockSkewed_1.isClockSkewed)(clockTimeInMs, currentSystemClockOffset)) {
                    return clockTimeInMs - Date.now();
                }
                return currentSystemClockOffset;
            };
            exports.getUpdatedSystemClockOffset = getUpdatedSystemClockOffset;


            /***/
        }),
        /* 451 */,
        /* 452 */,
        /* 453 */,
        /* 454 */,
        /* 455 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetAccountSendingEnabledCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetAccountSendingEnabledCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetAccountSendingEnabledCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: (input) => input,
                        outputFilterSensitiveLog: models_0_1.GetAccountSendingEnabledResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetAccountSendingEnabledCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetAccountSendingEnabledCommand)(output, context);
                }
            }

            exports.GetAccountSendingEnabledCommand = GetAccountSendingEnabledCommand;


            /***/
        }),
        /* 456 */,
        /* 457 */,
        /* 458 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListCustomVerificationEmailTemplatesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ListCustomVerificationEmailTemplatesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ListCustomVerificationEmailTemplatesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListCustomVerificationEmailTemplatesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListCustomVerificationEmailTemplatesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryListCustomVerificationEmailTemplatesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryListCustomVerificationEmailTemplatesCommand)(output, context);
                }
            }

            exports.ListCustomVerificationEmailTemplatesCommand = ListCustomVerificationEmailTemplatesCommand;


            /***/
        }),
        /* 459 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


// module to handle cookies

            const urllib = __webpack_require__(835);

            const SESSION_TIMEOUT = 1800; // 30 min

            /**
             * Creates a biskviit cookie jar for managing cookie values in memory
             *
             * @constructor
             * @param {Object} [options] Optional options object
             */
            class Cookies {
                constructor(options) {
                    this.options = options || {};
                    this.cookies = [];
                }

                /**
                 * Stores a cookie string to the cookie storage
                 *
                 * @param {String} cookieStr Value from the 'Set-Cookie:' header
                 * @param {String} url Current URL
                 */
                set(cookieStr, url) {
                    let urlparts = urllib.parse(url || '');
                    let cookie = this.parse(cookieStr);
                    let domain;

                    if (cookie.domain) {
                        domain = cookie.domain.replace(/^\./, '');

                        // do not allow cross origin cookies
                        if (
                            // can't be valid if the requested domain is shorter than current hostname
                            urlparts.hostname.length < domain.length ||
                            // prefix domains with dot to be sure that partial matches are not used
                            ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain
                        ) {
                            cookie.domain = urlparts.hostname;
                        }
                    } else {
                        cookie.domain = urlparts.hostname;
                    }

                    if (!cookie.path) {
                        cookie.path = this.getPath(urlparts.pathname);
                    }

                    // if no expire date, then use sessionTimeout value
                    if (!cookie.expires) {
                        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);
                    }

                    return this.add(cookie);
                }

                /**
                 * Returns cookie string for the 'Cookie:' header.
                 *
                 * @param {String} url URL to check for
                 * @returns {String} Cookie header or empty string if no matches were found
                 */
                get(url) {
                    return this.list(url)
                        .map(cookie => cookie.name + '=' + cookie.value)
                        .join('; ');
                }

                /**
                 * Lists all valied cookie objects for the specified URL
                 *
                 * @param {String} url URL to check for
                 * @returns {Array} An array of cookie objects
                 */
                list(url) {
                    let result = [];
                    let i;
                    let cookie;

                    for (i = this.cookies.length - 1; i >= 0; i--) {
                        cookie = this.cookies[i];

                        if (this.isExpired(cookie)) {
                            this.cookies.splice(i, i);
                            continue;
                        }

                        if (this.match(cookie, url)) {
                            result.unshift(cookie);
                        }
                    }

                    return result;
                }

                /**
                 * Parses cookie string from the 'Set-Cookie:' header
                 *
                 * @param {String} cookieStr String from the 'Set-Cookie:' header
                 * @returns {Object} Cookie object
                 */
                parse(cookieStr) {
                    let cookie = {};

                    (cookieStr || '')
                        .toString()
                        .split(';')
                        .forEach(cookiePart => {
                            let valueParts = cookiePart.split('=');
                            let key = valueParts.shift().trim().toLowerCase();
                            let value = valueParts.join('=').trim();
                            let domain;

                            if (!key) {
                                // skip empty parts
                                return;
                            }

                            switch (key) {
                                case 'expires':
                                    value = new Date(value);
                                    // ignore date if can not parse it
                                    if (value.toString() !== 'Invalid Date') {
                                        cookie.expires = value;
                                    }
                                    break;

                                case 'path':
                                    cookie.path = value;
                                    break;

                                case 'domain':
                                    domain = value.toLowerCase();
                                    if (domain.length && domain.charAt(0) !== '.') {
                                        domain = '.' + domain; // ensure preceeding dot for user set domains
                                    }
                                    cookie.domain = domain;
                                    break;

                                case 'max-age':
                                    cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);
                                    break;

                                case 'secure':
                                    cookie.secure = true;
                                    break;

                                case 'httponly':
                                    cookie.httponly = true;
                                    break;

                                default:
                                    if (!cookie.name) {
                                        cookie.name = key;
                                        cookie.value = value;
                                    }
                            }
                        });

                    return cookie;
                }

                /**
                 * Checks if a cookie object is valid for a specified URL
                 *
                 * @param {Object} cookie Cookie object
                 * @param {String} url URL to check for
                 * @returns {Boolean} true if cookie is valid for specifiec URL
                 */
                match(cookie, url) {
                    let urlparts = urllib.parse(url || '');

                    // check if hostname matches
                    // .foo.com also matches subdomains, foo.com does not
                    if (
                        urlparts.hostname !== cookie.domain &&
                        (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)
                    ) {
                        return false;
                    }

                    // check if path matches
                    let path = this.getPath(urlparts.pathname);
                    if (path.substr(0, cookie.path.length) !== cookie.path) {
                        return false;
                    }

                    // check secure argument
                    if (cookie.secure && urlparts.protocol !== 'https:') {
                        return false;
                    }

                    return true;
                }

                /**
                 * Adds (or updates/removes if needed) a cookie object to the cookie storage
                 *
                 * @param {Object} cookie Cookie value to be stored
                 */
                add(cookie) {
                    let i;
                    let len;

                    // nothing to do here
                    if (!cookie || !cookie.name) {
                        return false;
                    }

                    // overwrite if has same params
                    for (i = 0, len = this.cookies.length; i < len; i++) {
                        if (this.compare(this.cookies[i], cookie)) {
                            // check if the cookie needs to be removed instead
                            if (this.isExpired(cookie)) {
                                this.cookies.splice(i, 1); // remove expired/unset cookie
                                return false;
                            }

                            this.cookies[i] = cookie;
                            return true;
                        }
                    }

                    // add as new if not already expired
                    if (!this.isExpired(cookie)) {
                        this.cookies.push(cookie);
                    }

                    return true;
                }

                /**
                 * Checks if two cookie objects are the same
                 *
                 * @param {Object} a Cookie to check against
                 * @param {Object} b Cookie to check against
                 * @returns {Boolean} True, if the cookies are the same
                 */
                compare(a, b) {
                    return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;
                }

                /**
                 * Checks if a cookie is expired
                 *
                 * @param {Object} cookie Cookie object to check against
                 * @returns {Boolean} True, if the cookie is expired
                 */
                isExpired(cookie) {
                    return (cookie.expires && cookie.expires < new Date()) || !cookie.value;
                }

                /**
                 * Returns normalized cookie path for an URL path argument
                 *
                 * @param {String} pathname
                 * @returns {String} Normalized path
                 */
                getPath(pathname) {
                    let path = (pathname || '/').split('/');
                    path.pop(); // remove filename part
                    path = path.join('/').trim();

                    // ensure path prefix /
                    if (path.charAt(0) !== '/') {
                        path = '/' + path;
                    }

                    // ensure path suffix /
                    if (path.substr(-1) !== '/') {
                        path += '/';
                    }

                    return path;
                }
            }

            module.exports = Cookies;


            /***/
        }),
        /* 460 */,
        /* 461 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveDefaultsModeConfig = void 0;
            const config_resolver_1 = __webpack_require__(772);
            const credential_provider_imds_1 = __webpack_require__(272);
            const node_config_provider_1 = __webpack_require__(588);
            const property_provider_1 = __webpack_require__(118);
            const constants_1 = __webpack_require__(47);
            const defaultsModeConfig_1 = __webpack_require__(615);
            const resolveDefaultsModeConfig = ({
                                                   region = (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS),
                                                   defaultsMode = (0, node_config_provider_1.loadConfig)(defaultsModeConfig_1.NODE_DEFAULTS_MODE_CONFIG_OPTIONS),
                                               } = {}) => (0, property_provider_1.memoize)(async () => {
                const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
                switch (mode === null || mode === void 0 ? void 0 : mode.toLowerCase()) {
                    case "auto":
                        return resolveNodeDefaultsModeAuto(region);
                    case "in-region":
                    case "cross-region":
                    case "mobile":
                    case "standard":
                    case "legacy":
                        return Promise.resolve(mode === null || mode === void 0 ? void 0 : mode.toLocaleLowerCase());
                    case undefined:
                        return Promise.resolve("legacy");
                    default:
                        throw new Error(`Invalid parameter for "defaultsMode", expect ${constants_1.DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
                }
            });
            exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
            const resolveNodeDefaultsModeAuto = async (clientRegion) => {
                if (clientRegion) {
                    const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
                    const inferredRegion = await inferPhysicalRegion();
                    if (!inferredRegion) {
                        return "standard";
                    }
                    if (resolvedRegion === inferredRegion) {
                        return "in-region";
                    } else {
                        return "cross-region";
                    }
                }
                return "standard";
            };
            const inferPhysicalRegion = async () => {
                var _a;
                if (process.env[constants_1.AWS_EXECUTION_ENV] && (process.env[constants_1.AWS_REGION_ENV] || process.env[constants_1.AWS_DEFAULT_REGION_ENV])) {
                    return (_a = process.env[constants_1.AWS_REGION_ENV]) !== null && _a !== void 0 ? _a : process.env[constants_1.AWS_DEFAULT_REGION_ENV];
                }
                if (!process.env[constants_1.ENV_IMDS_DISABLED]) {
                    try {
                        const endpoint = await (0, credential_provider_imds_1.getInstanceMetadataEndpoint)();
                        return (await (0, credential_provider_imds_1.httpRequest)({
                            ...endpoint,
                            path: constants_1.IMDS_REGION_PATH
                        })).toString();
                    } catch (e) {
                    }
                }
            };


            /***/
        }),
        /* 462 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SetIdentityDkimEnabledCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SetIdentityDkimEnabledCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SetIdentityDkimEnabledCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SetIdentityDkimEnabledRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SetIdentityDkimEnabledResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySetIdentityDkimEnabledCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySetIdentityDkimEnabledCommand)(output, context);
                }
            }

            exports.SetIdentityDkimEnabledCommand = SetIdentityDkimEnabledCommand;


            /***/
        }),
        /* 463 */,
        /* 464 */,
        /* 465 */,
        /* 466 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.remoteProvider = exports.ENV_IMDS_DISABLED = void 0;
            const credential_provider_imds_1 = __webpack_require__(272);
            const property_provider_1 = __webpack_require__(118);
            exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
            const remoteProvider = (init) => {
                if (process.env[credential_provider_imds_1.ENV_CMDS_RELATIVE_URI] || process.env[credential_provider_imds_1.ENV_CMDS_FULL_URI]) {
                    return (0, credential_provider_imds_1.fromContainerMetadata)(init);
                }
                if (process.env[exports.ENV_IMDS_DISABLED]) {
                    return async () => {
                        throw new property_provider_1.CredentialsProviderError("EC2 Instance Metadata Service access disabled");
                    };
                }
                return (0, credential_provider_imds_1.fromInstanceMetadata)(init);
            };
            exports.remoteProvider = remoteProvider;


            /***/
        }),
        /* 467 */,
        /* 468 */,
        /* 469 */,
        /* 470 */,
        /* 471 */,
        /* 472 */,
        /* 473 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveStaticCredentials = exports.isStaticCredsProfile = void 0;
            const isStaticCredsProfile = (arg) => Boolean(arg) &&
                typeof arg === "object" &&
                typeof arg.aws_access_key_id === "string" &&
                typeof arg.aws_secret_access_key === "string" &&
                ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
            exports.isStaticCredsProfile = isStaticCredsProfile;
            const resolveStaticCredentials = (profile) => Promise.resolve({
                accessKeyId: profile.aws_access_key_id,
                secretAccessKey: profile.aws_secret_access_key,
                sessionToken: profile.aws_session_token,
            });
            exports.resolveStaticCredentials = resolveStaticCredentials;


            /***/
        }),
        /* 474 */,
        /* 475 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
            const REGEX_IS_INSTALLATION = /^ghs_/;
            const REGEX_IS_USER_TO_SERVER = /^ghu_/;

            async function auth(token) {
                const isApp = token.split(/\./).length === 3;
                const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
                const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
                const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
                return {
                    type: "token",
                    token: token,
                    tokenType
                };
            }

            /**
             * Prefix token for usage in the Authorization header
             *
             * @param token OAuth token or JSON Web Token
             */
            function withAuthorizationPrefix(token) {
                if (token.split(/\./).length === 3) {
                    return `bearer ${token}`;
                }

                return `token ${token}`;
            }

            async function hook(token, request, route, parameters) {
                const endpoint = request.endpoint.merge(route, parameters);
                endpoint.headers.authorization = withAuthorizationPrefix(token);
                return request(endpoint);
            }

            const createTokenAuth = function createTokenAuth(token) {
                if (!token) {
                    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
                }

                if (typeof token !== "string") {
                    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
                }

                token = token.replace(/^(token|bearer) +/i, "");
                return Object.assign(auth.bind(null, token), {
                    hook: hook.bind(null, token)
                });
            };

            exports.createTokenAuth = createTokenAuth;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 476 */,
        /* 477 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : {"default": mod};
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
            var entities_json_1 = __importDefault(__webpack_require__(265));
            var legacy_json_1 = __importDefault(__webpack_require__(629));
            var xml_json_1 = __importDefault(__webpack_require__(699));
            var decode_codepoint_1 = __importDefault(__webpack_require__(337));
            var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
            exports.decodeXML = getStrictDecoder(xml_json_1.default);
            exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);

            function getStrictDecoder(map) {
                var replace = getReplacer(map);
                return function (str) {
                    return String(str).replace(strictEntityRe, replace);
                };
            }

            var sorter = function (a, b) {
                return (a < b ? 1 : -1);
            };
            exports.decodeHTML = (function () {
                var legacy = Object.keys(legacy_json_1.default).sort(sorter);
                var keys = Object.keys(entities_json_1.default).sort(sorter);
                for (var i = 0, j = 0; i < keys.length; i++) {
                    if (legacy[j] === keys[i]) {
                        keys[i] += ";?";
                        j++;
                    } else {
                        keys[i] += ";";
                    }
                }
                var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
                var replace = getReplacer(entities_json_1.default);

                function replacer(str) {
                    if (str.substr(-1) !== ";")
                        str += ";";
                    return replace(str);
                }

                // TODO consider creating a merged map
                return function (str) {
                    return String(str).replace(re, replacer);
                };
            })();

            function getReplacer(map) {
                return function replace(str) {
                    if (str.charAt(1) === "#") {
                        var secondChar = str.charAt(2);
                        if (secondChar === "X" || secondChar === "x") {
                            return decode_codepoint_1.default(parseInt(str.substr(3), 16));
                        }
                        return decode_codepoint_1.default(parseInt(str.substr(2), 10));
                    }
                    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                    return map[str.slice(1, -1)] || str;
                };
            }


            /***/
        }),
        /* 478 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getSSOTokenFilepath = void 0;
            const crypto_1 = __webpack_require__(417);
            const path_1 = __webpack_require__(622);
            const getHomeDir_1 = __webpack_require__(567);
            const getSSOTokenFilepath = (ssoStartUrl) => {
                const hasher = (0, crypto_1.createHash)("sha1");
                const cacheName = hasher.update(ssoStartUrl).digest("hex");
                return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
            };
            exports.getSSOTokenFilepath = getSSOTokenFilepath;


            /***/
        }),
        /* 479 */,
        /* 480 */,
        /* 481 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const EventEmitter = __webpack_require__(614);
            const packageData = __webpack_require__(786);
            const shared = __webpack_require__(190);
            const LeWindows = __webpack_require__(791);

            /**
             * Generates a Transport object for AWS SES
             *
             * Possible options can be the following:
             *
             *  * **sendingRate** optional Number specifying how many messages per second should be delivered to SES
             *  * **maxConnections** optional Number specifying max number of parallel connections to SES
             *
             * @constructor
             * @param {Object} optional config parameter
             */
            class SESTransport extends EventEmitter {
                constructor(options) {
                    super();
                    options = options || {};

                    this.options = options || {};
                    this.ses = this.options.SES;

                    this.name = 'SESTransport';
                    this.version = packageData.version;

                    this.logger = shared.getLogger(this.options, {
                        component: this.options.component || 'ses-transport'
                    });

                    // parallel sending connections
                    this.maxConnections = Number(this.options.maxConnections) || Infinity;
                    this.connections = 0;

                    // max messages per second
                    this.sendingRate = Number(this.options.sendingRate) || Infinity;
                    this.sendingRateTTL = null;
                    this.rateInterval = 1000; // milliseconds
                    this.rateMessages = [];

                    this.pending = [];

                    this.idling = true;

                    setImmediate(() => {
                        if (this.idling) {
                            this.emit('idle');
                        }
                    });
                }

                /**
                 * Schedules a sending of a message
                 *
                 * @param {Object} emailMessage MailComposer object
                 * @param {Function} callback Callback function to run when the sending is completed
                 */
                send(mail, callback) {
                    if (this.connections >= this.maxConnections) {
                        this.idling = false;
                        return this.pending.push({
                            mail,
                            callback
                        });
                    }

                    if (!this._checkSendingRate()) {
                        this.idling = false;
                        return this.pending.push({
                            mail,
                            callback
                        });
                    }

                    this._send(mail, (...args) => {
                        setImmediate(() => callback(...args));
                        this._sent();
                    });
                }

                _checkRatedQueue() {
                    if (this.connections >= this.maxConnections || !this._checkSendingRate()) {
                        return;
                    }

                    if (!this.pending.length) {
                        if (!this.idling) {
                            this.idling = true;
                            this.emit('idle');
                        }
                        return;
                    }

                    let next = this.pending.shift();
                    this._send(next.mail, (...args) => {
                        setImmediate(() => next.callback(...args));
                        this._sent();
                    });
                }

                _checkSendingRate() {
                    clearTimeout(this.sendingRateTTL);

                    let now = Date.now();
                    let oldest = false;
                    // delete older messages
                    for (let i = this.rateMessages.length - 1; i >= 0; i--) {
                        if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {
                            oldest = this.rateMessages[i].ts;
                        }

                        if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {
                            this.rateMessages.splice(i, 1);
                        }
                    }

                    if (this.rateMessages.length < this.sendingRate) {
                        return true;
                    }

                    let delay = Math.max(oldest + 1001, now + 20);
                    this.sendingRateTTL = setTimeout(() => this._checkRatedQueue(), now - delay);

                    try {
                        this.sendingRateTTL.unref();
                    } catch (E) {
                        // Ignore. Happens on envs with non-node timer implementation
                    }

                    return false;
                }

                _sent() {
                    this.connections--;
                    this._checkRatedQueue();
                }

                /**
                 * Returns true if there are free slots in the queue
                 */
                isIdle() {
                    return this.idling;
                }

                /**
                 * Compiles a mailcomposer message and forwards it to SES
                 *
                 * @param {Object} emailMessage MailComposer object
                 * @param {Function} callback Callback function to run when the sending is completed
                 */
                _send(mail, callback) {
                    let statObject = {
                        ts: Date.now(),
                        pending: true
                    };
                    this.connections++;
                    this.rateMessages.push(statObject);

                    let envelope = mail.data.envelope || mail.message.getEnvelope();
                    let messageId = mail.message.messageId();

                    let recipients = [].concat(envelope.to || []);
                    if (recipients.length > 3) {
                        recipients.push('...and ' + recipients.splice(2).length + ' more');
                    }
                    this.logger.info(
                        {
                            tnx: 'send',
                            messageId
                        },
                        'Sending message %s to <%s>',
                        messageId,
                        recipients.join(', ')
                    );

                    let getRawMessage = next => {
                        // do not use Message-ID and Date in DKIM signature
                        if (!mail.data._dkim) {
                            mail.data._dkim = {};
                        }
                        if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === 'string') {
                            mail.data._dkim.skipFields += ':date:message-id';
                        } else {
                            mail.data._dkim.skipFields = 'date:message-id';
                        }

                        let sourceStream = mail.message.createReadStream();
                        let stream = sourceStream.pipe(new LeWindows());
                        let chunks = [];
                        let chunklen = 0;

                        stream.on('readable', () => {
                            let chunk;
                            while ((chunk = stream.read()) !== null) {
                                chunks.push(chunk);
                                chunklen += chunk.length;
                            }
                        });

                        sourceStream.once('error', err => stream.emit('error', err));

                        stream.once('error', err => {
                            next(err);
                        });

                        stream.once('end', () => next(null, Buffer.concat(chunks, chunklen)));
                    };

                    setImmediate(() =>
                        getRawMessage((err, raw) => {
                            if (err) {
                                this.logger.error(
                                    {
                                        err,
                                        tnx: 'send',
                                        messageId
                                    },
                                    'Failed creating message for %s. %s',
                                    messageId,
                                    err.message
                                );
                                statObject.pending = false;
                                return callback(err);
                            }

                            let sesMessage = {
                                RawMessage: {
                                    // required
                                    Data: raw // required
                                },
                                Source: envelope.from,
                                Destinations: envelope.to
                            };

                            Object.keys(mail.data.ses || {}).forEach(key => {
                                sesMessage[key] = mail.data.ses[key];
                            });

                            let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
                            let aws = this.ses.aws || {};

                            let getRegion = cb => {
                                if (ses.config && typeof ses.config.region === 'function') {
                                    // promise
                                    return ses.config
                                        .region()
                                        .then(region => cb(null, region))
                                        .catch(err => cb(err));
                                }
                                return cb(null, (ses.config && ses.config.region) || 'us-east-1');
                            };

                            getRegion((err, region) => {
                                if (err || !region) {
                                    region = 'us-east-1';
                                }

                                let sendPromise;
                                if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {
                                    // v3 API
                                    sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));
                                } else {
                                    // v2 API
                                    sendPromise = ses.sendRawEmail(sesMessage).promise();
                                }

                                sendPromise
                                    .then(data => {
                                        if (region === 'us-east-1') {
                                            region = 'email';
                                        }

                                        statObject.pending = false;
                                        callback(null, {
                                            envelope: {
                                                from: envelope.from,
                                                to: envelope.to
                                            },
                                            messageId: '<' + data.MessageId + (!/@/.test(data.MessageId) ? '@' + region + '.amazonses.com' : '') + '>',
                                            response: data.MessageId,
                                            raw
                                        });
                                    })
                                    .catch(err => {
                                        this.logger.error(
                                            {
                                                err,
                                                tnx: 'send'
                                            },
                                            'Send error for %s: %s',
                                            messageId,
                                            err.message
                                        );
                                        statObject.pending = false;
                                        callback(err);
                                    });
                            });
                        })
                    );
                }

                /**
                 * Verifies SES configuration
                 *
                 * @param {Function} callback Callback function
                 */
                verify(callback) {
                    let promise;
                    let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
                    let aws = this.ses.aws || {};

                    const sesMessage = {
                        RawMessage: {
                            // required
                            Data: 'From: invalid@invalid\r\nTo: invalid@invalid\r\n Subject: Invalid\r\n\r\nInvalid'
                        },
                        Source: 'invalid@invalid',
                        Destinations: ['invalid@invalid']
                    };

                    if (!callback) {
                        promise = new Promise((resolve, reject) => {
                            callback = shared.callbackPromise(resolve, reject);
                        });
                    }
                    const cb = err => {
                        if (err && (err.code || err.Code) !== 'InvalidParameterValue') {
                            return callback(err);
                        }
                        return callback(null, true);
                    };

                    if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {
                        // v3 API
                        sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);
                        ses.send(new aws.SendRawEmailCommand(sesMessage), cb);
                    } else {
                        // v2 API
                        ses.sendRawEmail(sesMessage, cb);
                    }

                    return promise;
                }
            }

            module.exports = SESTransport;


            /***/
        }),
        /* 482 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromProcess = void 0;
            const shared_ini_file_loader_1 = __webpack_require__(706);
            const resolveProcessCredentials_1 = __webpack_require__(544);
            const fromProcess = (init = {}) => async () => {
                const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
                return (0, resolveProcessCredentials_1.resolveProcessCredentials)((0, shared_ini_file_loader_1.getProfileName)(init), profiles);
            };
            exports.fromProcess = fromProcess;


            /***/
        }),
        /* 483 */,
        /* 484 */,
        /* 485 */,
        /* 486 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveCustomEndpointsConfig = void 0;
            const util_middleware_1 = __webpack_require__(552);
            const resolveCustomEndpointsConfig = (input) => {
                var _a;
                const {endpoint, urlParser} = input;
                return {
                    ...input,
                    tls: (_a = input.tls) !== null && _a !== void 0 ? _a : true,
                    endpoint: (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
                    isCustomEndpoint: true,
                    useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)(input.useDualstackEndpoint),
                };
            };
            exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;


            /***/
        }),
        /* 487 */,
        /* 488 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getDefaultRetryQuota = void 0;
            const constants_1 = __webpack_require__(581);
            const getDefaultRetryQuota = (initialRetryTokens, options) => {
                var _a, _b, _c;
                const MAX_CAPACITY = initialRetryTokens;
                const noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : constants_1.NO_RETRY_INCREMENT;
                const retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : constants_1.RETRY_COST;
                const timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : constants_1.TIMEOUT_RETRY_COST;
                let availableCapacity = initialRetryTokens;
                const getCapacityAmount = (error) => (error.name === "TimeoutError" ? timeoutRetryCost : retryCost);
                const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
                const retrieveRetryTokens = (error) => {
                    if (!hasRetryTokens(error)) {
                        throw new Error("No retry token available");
                    }
                    const capacityAmount = getCapacityAmount(error);
                    availableCapacity -= capacityAmount;
                    return capacityAmount;
                };
                const releaseRetryTokens = (capacityReleaseAmount) => {
                    availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;
                    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
                };
                return Object.freeze({
                    hasRetryTokens,
                    retrieveRetryTokens,
                    releaseRetryTokens,
                });
            };
            exports.getDefaultRetryQuota = getDefaultRetryQuota;


            /***/
        }),
        /* 489 */,
        /* 490 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getUserAgentPlugin = exports.getUserAgentMiddlewareOptions = exports.userAgentMiddleware = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const constants_1 = __webpack_require__(163);
            const userAgentMiddleware = (options) => (next, context) => async (args) => {
                var _a, _b;
                const {request} = args;
                if (!protocol_http_1.HttpRequest.isInstance(request))
                    return next(args);
                const {headers} = request;
                const userAgent = ((_a = context === null || context === void 0 ? void 0 : context.userAgent) === null || _a === void 0 ? void 0 : _a.map(escapeUserAgent)) || [];
                const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
                const customUserAgent = ((_b = options === null || options === void 0 ? void 0 : options.customUserAgent) === null || _b === void 0 ? void 0 : _b.map(escapeUserAgent)) || [];
                const sdkUserAgentValue = [...defaultUserAgent, ...userAgent, ...customUserAgent].join(constants_1.SPACE);
                const normalUAValue = [
                    ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
                    ...customUserAgent,
                ].join(constants_1.SPACE);
                if (options.runtime !== "browser") {
                    if (normalUAValue) {
                        headers[constants_1.X_AMZ_USER_AGENT] = headers[constants_1.X_AMZ_USER_AGENT]
                            ? `${headers[constants_1.USER_AGENT]} ${normalUAValue}`
                            : normalUAValue;
                    }
                    headers[constants_1.USER_AGENT] = sdkUserAgentValue;
                } else {
                    headers[constants_1.X_AMZ_USER_AGENT] = sdkUserAgentValue;
                }
                return next({
                    ...args,
                    request,
                });
            };
            exports.userAgentMiddleware = userAgentMiddleware;
            const escapeUserAgent = ([name, version]) => {
                const prefixSeparatorIndex = name.indexOf("/");
                const prefix = name.substring(0, prefixSeparatorIndex);
                let uaName = name.substring(prefixSeparatorIndex + 1);
                if (prefix === "api") {
                    uaName = uaName.toLowerCase();
                }
                return [prefix, uaName, version]
                    .filter((item) => item && item.length > 0)
                    .map((item) => item === null || item === void 0 ? void 0 : item.replace(constants_1.UA_ESCAPE_REGEX, "_"))
                    .join("/");
            };
            exports.getUserAgentMiddlewareOptions = {
                name: "getUserAgentMiddleware",
                step: "build",
                priority: "low",
                tags: ["SET_USER_AGENT", "USER_AGENT"],
                override: true,
            };
            const getUserAgentPlugin = (config) => ({
                applyToStack: (clientStack) => {
                    clientStack.add((0, exports.userAgentMiddleware)(config), exports.getUserAgentMiddlewareOptions);
                },
            });
            exports.getUserAgentPlugin = getUserAgentPlugin;


            /***/
        }),
        /* 491 */,
        /* 492 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.deserializeAws_restJson1LogoutCommand = exports.deserializeAws_restJson1ListAccountsCommand = exports.deserializeAws_restJson1ListAccountRolesCommand = exports.deserializeAws_restJson1GetRoleCredentialsCommand = exports.serializeAws_restJson1LogoutCommand = exports.serializeAws_restJson1ListAccountsCommand = exports.serializeAws_restJson1ListAccountRolesCommand = exports.serializeAws_restJson1GetRoleCredentialsCommand = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(518);
            const SSOServiceException_1 = __webpack_require__(238);
            const serializeAws_restJson1GetRoleCredentialsCommand = async (input, context) => {
                const {hostname, protocol = "https", port, path: basePath} = await context.endpoint();
                const headers = {
                    ...(isSerializableHeaderValue(input.accessToken) && {"x-amz-sso_bearer_token": input.accessToken}),
                };
                const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/federation/credentials";
                const query = {
                    ...(input.roleName !== undefined && {role_name: input.roleName}),
                    ...(input.accountId !== undefined && {account_id: input.accountId}),
                };
                let body;
                return new protocol_http_1.HttpRequest({
                    protocol,
                    hostname,
                    port,
                    method: "GET",
                    headers,
                    path: resolvedPath,
                    query,
                    body,
                });
            };
            exports.serializeAws_restJson1GetRoleCredentialsCommand = serializeAws_restJson1GetRoleCredentialsCommand;
            const serializeAws_restJson1ListAccountRolesCommand = async (input, context) => {
                const {hostname, protocol = "https", port, path: basePath} = await context.endpoint();
                const headers = {
                    ...(isSerializableHeaderValue(input.accessToken) && {"x-amz-sso_bearer_token": input.accessToken}),
                };
                const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/roles";
                const query = {
                    ...(input.nextToken !== undefined && {next_token: input.nextToken}),
                    ...(input.maxResults !== undefined && {max_result: input.maxResults.toString()}),
                    ...(input.accountId !== undefined && {account_id: input.accountId}),
                };
                let body;
                return new protocol_http_1.HttpRequest({
                    protocol,
                    hostname,
                    port,
                    method: "GET",
                    headers,
                    path: resolvedPath,
                    query,
                    body,
                });
            };
            exports.serializeAws_restJson1ListAccountRolesCommand = serializeAws_restJson1ListAccountRolesCommand;
            const serializeAws_restJson1ListAccountsCommand = async (input, context) => {
                const {hostname, protocol = "https", port, path: basePath} = await context.endpoint();
                const headers = {
                    ...(isSerializableHeaderValue(input.accessToken) && {"x-amz-sso_bearer_token": input.accessToken}),
                };
                const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/accounts";
                const query = {
                    ...(input.nextToken !== undefined && {next_token: input.nextToken}),
                    ...(input.maxResults !== undefined && {max_result: input.maxResults.toString()}),
                };
                let body;
                return new protocol_http_1.HttpRequest({
                    protocol,
                    hostname,
                    port,
                    method: "GET",
                    headers,
                    path: resolvedPath,
                    query,
                    body,
                });
            };
            exports.serializeAws_restJson1ListAccountsCommand = serializeAws_restJson1ListAccountsCommand;
            const serializeAws_restJson1LogoutCommand = async (input, context) => {
                const {hostname, protocol = "https", port, path: basePath} = await context.endpoint();
                const headers = {
                    ...(isSerializableHeaderValue(input.accessToken) && {"x-amz-sso_bearer_token": input.accessToken}),
                };
                const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/logout";
                let body;
                return new protocol_http_1.HttpRequest({
                    protocol,
                    hostname,
                    port,
                    method: "POST",
                    headers,
                    path: resolvedPath,
                    body,
                });
            };
            exports.serializeAws_restJson1LogoutCommand = serializeAws_restJson1LogoutCommand;
            const deserializeAws_restJson1GetRoleCredentialsCommand = async (output, context) => {
                if (output.statusCode !== 200 && output.statusCode >= 300) {
                    return deserializeAws_restJson1GetRoleCredentialsCommandError(output, context);
                }
                const contents = {
                    $metadata: deserializeMetadata(output),
                    roleCredentials: undefined,
                };
                const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
                if (data.roleCredentials !== undefined && data.roleCredentials !== null) {
                    contents.roleCredentials = deserializeAws_restJson1RoleCredentials(data.roleCredentials, context);
                }
                return Promise.resolve(contents);
            };
            exports.deserializeAws_restJson1GetRoleCredentialsCommand = deserializeAws_restJson1GetRoleCredentialsCommand;
            const deserializeAws_restJson1GetRoleCredentialsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidRequestException":
                    case "com.amazonaws.sso#InvalidRequestException":
                        throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
                    case "ResourceNotFoundException":
                    case "com.amazonaws.sso#ResourceNotFoundException":
                        throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
                    case "TooManyRequestsException":
                    case "com.amazonaws.sso#TooManyRequestsException":
                        throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
                    case "UnauthorizedException":
                    case "com.amazonaws.sso#UnauthorizedException":
                        throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SSOServiceException_1.SSOServiceException({
                            name: parsedBody.code || parsedBody.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
                }
            };
            const deserializeAws_restJson1ListAccountRolesCommand = async (output, context) => {
                if (output.statusCode !== 200 && output.statusCode >= 300) {
                    return deserializeAws_restJson1ListAccountRolesCommandError(output, context);
                }
                const contents = {
                    $metadata: deserializeMetadata(output),
                    nextToken: undefined,
                    roleList: undefined,
                };
                const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
                if (data.nextToken !== undefined && data.nextToken !== null) {
                    contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
                }
                if (data.roleList !== undefined && data.roleList !== null) {
                    contents.roleList = deserializeAws_restJson1RoleListType(data.roleList, context);
                }
                return Promise.resolve(contents);
            };
            exports.deserializeAws_restJson1ListAccountRolesCommand = deserializeAws_restJson1ListAccountRolesCommand;
            const deserializeAws_restJson1ListAccountRolesCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidRequestException":
                    case "com.amazonaws.sso#InvalidRequestException":
                        throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
                    case "ResourceNotFoundException":
                    case "com.amazonaws.sso#ResourceNotFoundException":
                        throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
                    case "TooManyRequestsException":
                    case "com.amazonaws.sso#TooManyRequestsException":
                        throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
                    case "UnauthorizedException":
                    case "com.amazonaws.sso#UnauthorizedException":
                        throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SSOServiceException_1.SSOServiceException({
                            name: parsedBody.code || parsedBody.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
                }
            };
            const deserializeAws_restJson1ListAccountsCommand = async (output, context) => {
                if (output.statusCode !== 200 && output.statusCode >= 300) {
                    return deserializeAws_restJson1ListAccountsCommandError(output, context);
                }
                const contents = {
                    $metadata: deserializeMetadata(output),
                    accountList: undefined,
                    nextToken: undefined,
                };
                const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
                if (data.accountList !== undefined && data.accountList !== null) {
                    contents.accountList = deserializeAws_restJson1AccountListType(data.accountList, context);
                }
                if (data.nextToken !== undefined && data.nextToken !== null) {
                    contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
                }
                return Promise.resolve(contents);
            };
            exports.deserializeAws_restJson1ListAccountsCommand = deserializeAws_restJson1ListAccountsCommand;
            const deserializeAws_restJson1ListAccountsCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidRequestException":
                    case "com.amazonaws.sso#InvalidRequestException":
                        throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
                    case "ResourceNotFoundException":
                    case "com.amazonaws.sso#ResourceNotFoundException":
                        throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
                    case "TooManyRequestsException":
                    case "com.amazonaws.sso#TooManyRequestsException":
                        throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
                    case "UnauthorizedException":
                    case "com.amazonaws.sso#UnauthorizedException":
                        throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SSOServiceException_1.SSOServiceException({
                            name: parsedBody.code || parsedBody.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
                }
            };
            const deserializeAws_restJson1LogoutCommand = async (output, context) => {
                if (output.statusCode !== 200 && output.statusCode >= 300) {
                    return deserializeAws_restJson1LogoutCommandError(output, context);
                }
                const contents = {
                    $metadata: deserializeMetadata(output),
                };
                await collectBody(output.body, context);
                return Promise.resolve(contents);
            };
            exports.deserializeAws_restJson1LogoutCommand = deserializeAws_restJson1LogoutCommand;
            const deserializeAws_restJson1LogoutCommandError = async (output, context) => {
                const parsedOutput = {
                    ...output,
                    body: await parseBody(output.body, context),
                };
                let response;
                let errorCode = "UnknownError";
                errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
                switch (errorCode) {
                    case "InvalidRequestException":
                    case "com.amazonaws.sso#InvalidRequestException":
                        throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
                    case "TooManyRequestsException":
                    case "com.amazonaws.sso#TooManyRequestsException":
                        throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
                    case "UnauthorizedException":
                    case "com.amazonaws.sso#UnauthorizedException":
                        throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
                    default:
                        const parsedBody = parsedOutput.body;
                        response = new SSOServiceException_1.SSOServiceException({
                            name: parsedBody.code || parsedBody.Code || errorCode,
                            $fault: "client",
                            $metadata: deserializeMetadata(output),
                        });
                        throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
                }
            };
            const deserializeAws_restJson1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
                const contents = {};
                const data = parsedOutput.body;
                if (data.message !== undefined && data.message !== null) {
                    contents.message = (0, smithy_client_1.expectString)(data.message);
                }
                const exception = new models_0_1.InvalidRequestException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...contents,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
            };
            const deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
                const contents = {};
                const data = parsedOutput.body;
                if (data.message !== undefined && data.message !== null) {
                    contents.message = (0, smithy_client_1.expectString)(data.message);
                }
                const exception = new models_0_1.ResourceNotFoundException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...contents,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
            };
            const deserializeAws_restJson1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
                const contents = {};
                const data = parsedOutput.body;
                if (data.message !== undefined && data.message !== null) {
                    contents.message = (0, smithy_client_1.expectString)(data.message);
                }
                const exception = new models_0_1.TooManyRequestsException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...contents,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
            };
            const deserializeAws_restJson1UnauthorizedExceptionResponse = async (parsedOutput, context) => {
                const contents = {};
                const data = parsedOutput.body;
                if (data.message !== undefined && data.message !== null) {
                    contents.message = (0, smithy_client_1.expectString)(data.message);
                }
                const exception = new models_0_1.UnauthorizedException({
                    $metadata: deserializeMetadata(parsedOutput),
                    ...contents,
                });
                return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
            };
            const deserializeAws_restJson1AccountInfo = (output, context) => {
                return {
                    accountId: (0, smithy_client_1.expectString)(output.accountId),
                    accountName: (0, smithy_client_1.expectString)(output.accountName),
                    emailAddress: (0, smithy_client_1.expectString)(output.emailAddress),
                };
            };
            const deserializeAws_restJson1AccountListType = (output, context) => {
                const retVal = (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_restJson1AccountInfo(entry, context);
                    });
                return retVal;
            };
            const deserializeAws_restJson1RoleCredentials = (output, context) => {
                return {
                    accessKeyId: (0, smithy_client_1.expectString)(output.accessKeyId),
                    expiration: (0, smithy_client_1.expectLong)(output.expiration),
                    secretAccessKey: (0, smithy_client_1.expectString)(output.secretAccessKey),
                    sessionToken: (0, smithy_client_1.expectString)(output.sessionToken),
                };
            };
            const deserializeAws_restJson1RoleInfo = (output, context) => {
                return {
                    accountId: (0, smithy_client_1.expectString)(output.accountId),
                    roleName: (0, smithy_client_1.expectString)(output.roleName),
                };
            };
            const deserializeAws_restJson1RoleListType = (output, context) => {
                const retVal = (output || [])
                    .filter((e) => e != null)
                    .map((entry) => {
                        if (entry === null) {
                            return null;
                        }
                        return deserializeAws_restJson1RoleInfo(entry, context);
                    });
                return retVal;
            };
            const deserializeMetadata = (output) => {
                var _a;
                return ({
                    httpStatusCode: output.statusCode,
                    requestId: (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"],
                    extendedRequestId: output.headers["x-amz-id-2"],
                    cfId: output.headers["x-amz-cf-id"],
                });
            };
            const collectBody = (streamBody = new Uint8Array(), context) => {
                if (streamBody instanceof Uint8Array) {
                    return Promise.resolve(streamBody);
                }
                return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
            };
            const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
            const isSerializableHeaderValue = (value) => value !== undefined &&
                value !== null &&
                value !== "" &&
                (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
                (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
            const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
                if (encoded.length) {
                    return JSON.parse(encoded);
                }
                return {};
            });
            const loadRestJsonErrorCode = (output, data) => {
                const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
                const sanitizeErrorCode = (rawValue) => {
                    let cleanValue = rawValue;
                    if (cleanValue.indexOf(":") >= 0) {
                        cleanValue = cleanValue.split(":")[0];
                    }
                    if (cleanValue.indexOf("#") >= 0) {
                        cleanValue = cleanValue.split("#")[1];
                    }
                    return cleanValue;
                };
                const headerKey = findKey(output.headers, "x-amzn-errortype");
                if (headerKey !== undefined) {
                    return sanitizeErrorCode(output.headers[headerKey]);
                }
                if (data.code !== undefined) {
                    return sanitizeErrorCode(data.code);
                }
                if (data["__type"] !== undefined) {
                    return sanitizeErrorCode(data["__type"]);
                }
                return "";
            };


            /***/
        }),
        /* 493 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRegionInfo = void 0;
            const getHostnameFromVariants_1 = __webpack_require__(234);
            const getResolvedHostname_1 = __webpack_require__(862);
            const getResolvedPartition_1 = __webpack_require__(15);
            const getResolvedSigningRegion_1 = __webpack_require__(793);
            const getRegionInfo = (region, {
                useFipsEndpoint = false,
                useDualstackEndpoint = false,
                signingService,
                regionHash,
                partitionHash,
            }) => {
                var _a, _b, _c, _d, _e, _f;
                const partition = (0, getResolvedPartition_1.getResolvedPartition)(region, {partitionHash});
                const resolvedRegion = region in regionHash ? region : (_b = (_a = partitionHash[partition]) === null || _a === void 0 ? void 0 : _a.endpoint) !== null && _b !== void 0 ? _b : region;
                const hostnameOptions = {useFipsEndpoint, useDualstackEndpoint};
                const regionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_c = regionHash[resolvedRegion]) === null || _c === void 0 ? void 0 : _c.variants, hostnameOptions);
                const partitionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_d = partitionHash[partition]) === null || _d === void 0 ? void 0 : _d.variants, hostnameOptions);
                const hostname = (0, getResolvedHostname_1.getResolvedHostname)(resolvedRegion, {
                    regionHostname,
                    partitionHostname
                });
                if (hostname === undefined) {
                    throw new Error(`Endpoint resolution failed for: ${{
                        resolvedRegion,
                        useFipsEndpoint,
                        useDualstackEndpoint
                    }}`);
                }
                const signingRegion = (0, getResolvedSigningRegion_1.getResolvedSigningRegion)(hostname, {
                    signingRegion: (_e = regionHash[resolvedRegion]) === null || _e === void 0 ? void 0 : _e.signingRegion,
                    regionRegex: partitionHash[partition].regionRegex,
                    useFipsEndpoint,
                });
                return {
                    partition,
                    signingService,
                    hostname,
                    ...(signingRegion && {signingRegion}),
                    ...(((_f = regionHash[resolvedRegion]) === null || _f === void 0 ? void 0 : _f.signingService) && {
                        signingService: regionHash[resolvedRegion].signingService,
                    }),
                };
            };
            exports.getRegionInfo = getRegionInfo;


            /***/
        }),
        /* 494 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.NODE_RETRY_MODE_CONFIG_OPTIONS = exports.CONFIG_RETRY_MODE = exports.ENV_RETRY_MODE = exports.resolveRetryConfig = exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = exports.CONFIG_MAX_ATTEMPTS = exports.ENV_MAX_ATTEMPTS = void 0;
            const util_middleware_1 = __webpack_require__(552);
            const AdaptiveRetryStrategy_1 = __webpack_require__(714);
            const config_1 = __webpack_require__(168);
            const StandardRetryStrategy_1 = __webpack_require__(185);
            exports.ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
            exports.CONFIG_MAX_ATTEMPTS = "max_attempts";
            exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
                environmentVariableSelector: (env) => {
                    const value = env[exports.ENV_MAX_ATTEMPTS];
                    if (!value)
                        return undefined;
                    const maxAttempt = parseInt(value);
                    if (Number.isNaN(maxAttempt)) {
                        throw new Error(`Environment variable ${exports.ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
                    }
                    return maxAttempt;
                },
                configFileSelector: (profile) => {
                    const value = profile[exports.CONFIG_MAX_ATTEMPTS];
                    if (!value)
                        return undefined;
                    const maxAttempt = parseInt(value);
                    if (Number.isNaN(maxAttempt)) {
                        throw new Error(`Shared config file entry ${exports.CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
                    }
                    return maxAttempt;
                },
                default: config_1.DEFAULT_MAX_ATTEMPTS,
            };
            const resolveRetryConfig = (input) => {
                var _a;
                const maxAttempts = (0, util_middleware_1.normalizeProvider)((_a = input.maxAttempts) !== null && _a !== void 0 ? _a : config_1.DEFAULT_MAX_ATTEMPTS);
                return {
                    ...input,
                    maxAttempts,
                    retryStrategy: async () => {
                        if (input.retryStrategy) {
                            return input.retryStrategy;
                        }
                        const retryMode = await (0, util_middleware_1.normalizeProvider)(input.retryMode)();
                        if (retryMode === config_1.RETRY_MODES.ADAPTIVE) {
                            return new AdaptiveRetryStrategy_1.AdaptiveRetryStrategy(maxAttempts);
                        }
                        return new StandardRetryStrategy_1.StandardRetryStrategy(maxAttempts);
                    },
                };
            };
            exports.resolveRetryConfig = resolveRetryConfig;
            exports.ENV_RETRY_MODE = "AWS_RETRY_MODE";
            exports.CONFIG_RETRY_MODE = "retry_mode";
            exports.NODE_RETRY_MODE_CONFIG_OPTIONS = {
                environmentVariableSelector: (env) => env[exports.ENV_RETRY_MODE],
                configFileSelector: (profile) => profile[exports.CONFIG_RETRY_MODE],
                default: config_1.DEFAULT_RETRY_MODE,
            };


            /***/
        }),
        /* 495 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.toUtf8 = exports.fromUtf8 = void 0;
            const util_buffer_from_1 = __webpack_require__(75);
            const fromUtf8 = (input) => {
                const buf = (0, util_buffer_from_1.fromString)(input, "utf8");
                return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
            };
            exports.fromUtf8 = fromUtf8;
            const toUtf8 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
            exports.toUtf8 = toUtf8;


            /***/
        }),
        /* 496 */,
        /* 497 */,
        /* 498 */,
        /* 499 */,
        /* 500 */,
        /* 501 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UpdateConfigurationSetTrackingOptionsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class UpdateConfigurationSetTrackingOptionsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "UpdateConfigurationSetTrackingOptionsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.UpdateConfigurationSetTrackingOptionsRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.UpdateConfigurationSetTrackingOptionsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryUpdateConfigurationSetTrackingOptionsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryUpdateConfigurationSetTrackingOptionsCommand)(output, context);
                }
            }

            exports.UpdateConfigurationSetTrackingOptionsCommand = UpdateConfigurationSetTrackingOptionsCommand;


            /***/
        }),
        /* 502 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getOmitRetryHeadersPlugin = exports.omitRetryHeadersMiddlewareOptions = exports.omitRetryHeadersMiddleware = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const constants_1 = __webpack_require__(581);
            const omitRetryHeadersMiddleware = () => (next) => async (args) => {
                const {request} = args;
                if (protocol_http_1.HttpRequest.isInstance(request)) {
                    delete request.headers[constants_1.INVOCATION_ID_HEADER];
                    delete request.headers[constants_1.REQUEST_HEADER];
                }
                return next(args);
            };
            exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
            exports.omitRetryHeadersMiddlewareOptions = {
                name: "omitRetryHeadersMiddleware",
                tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
                relation: "before",
                toMiddleware: "awsAuthMiddleware",
                override: true,
            };
            const getOmitRetryHeadersPlugin = (options) => ({
                applyToStack: (clientStack) => {
                    clientStack.addRelativeTo((0, exports.omitRetryHeadersMiddleware)(), exports.omitRetryHeadersMiddlewareOptions);
                },
            });
            exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;


            /***/
        }),
        /* 503 */,
        /* 504 */,
        /* 505 */,
        /* 506 */,
        /* 507 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const packageData = __webpack_require__(786);
            const shared = __webpack_require__(190);

            /**
             * Generates a Transport object for streaming
             *
             * Possible options can be the following:
             *
             *  * **buffer** if true, then returns the message as a Buffer object instead of a stream
             *  * **newline** either 'windows' or 'unix'
             *
             * @constructor
             * @param {Object} optional config parameter
             */
            class StreamTransport {
                constructor(options) {
                    options = options || {};

                    this.options = options || {};

                    this.name = 'StreamTransport';
                    this.version = packageData.version;

                    this.logger = shared.getLogger(this.options, {
                        component: this.options.component || 'stream-transport'
                    });

                    this.winbreak = ['win', 'windows', 'dos', '\r\n'].includes((options.newline || '').toString().toLowerCase());
                }

                /**
                 * Compiles a mailcomposer message and forwards it to handler that sends it
                 *
                 * @param {Object} emailMessage MailComposer object
                 * @param {Function} callback Callback function to run when the sending is completed
                 */
                send(mail, done) {
                    // We probably need this in the output
                    mail.message.keepBcc = true;

                    let envelope = mail.data.envelope || mail.message.getEnvelope();
                    let messageId = mail.message.messageId();

                    let recipients = [].concat(envelope.to || []);
                    if (recipients.length > 3) {
                        recipients.push('...and ' + recipients.splice(2).length + ' more');
                    }
                    this.logger.info(
                        {
                            tnx: 'send',
                            messageId
                        },
                        'Sending message %s to <%s> using %s line breaks',
                        messageId,
                        recipients.join(', '),
                        this.winbreak ? '<CR><LF>' : '<LF>'
                    );

                    setImmediate(() => {
                        let stream;

                        try {
                            stream = mail.message.createReadStream();
                        } catch (E) {
                            this.logger.error(
                                {
                                    err: E,
                                    tnx: 'send',
                                    messageId
                                },
                                'Creating send stream failed for %s. %s',
                                messageId,
                                E.message
                            );
                            return done(E);
                        }

                        if (!this.options.buffer) {
                            stream.once('error', err => {
                                this.logger.error(
                                    {
                                        err,
                                        tnx: 'send',
                                        messageId
                                    },
                                    'Failed creating message for %s. %s',
                                    messageId,
                                    err.message
                                );
                            });
                            return done(null, {
                                envelope: mail.data.envelope || mail.message.getEnvelope(),
                                messageId,
                                message: stream
                            });
                        }

                        let chunks = [];
                        let chunklen = 0;
                        stream.on('readable', () => {
                            let chunk;
                            while ((chunk = stream.read()) !== null) {
                                chunks.push(chunk);
                                chunklen += chunk.length;
                            }
                        });

                        stream.once('error', err => {
                            this.logger.error(
                                {
                                    err,
                                    tnx: 'send',
                                    messageId
                                },
                                'Failed creating message for %s. %s',
                                messageId,
                                err.message
                            );
                            return done(err);
                        });

                        stream.on('end', () =>
                            done(null, {
                                envelope: mail.data.envelope || mail.message.getEnvelope(),
                                messageId,
                                message: Buffer.concat(chunks, chunklen)
                            })
                        );
                    });
                }
            }

            module.exports = StreamTransport;


            /***/
        }),
        /* 508 */,
        /* 509 */
        /***/ (function (module) {

            module.exports = {
                "0": 65533,
                "128": 8364,
                "130": 8218,
                "131": 402,
                "132": 8222,
                "133": 8230,
                "134": 8224,
                "135": 8225,
                "136": 710,
                "137": 8240,
                "138": 352,
                "139": 8249,
                "140": 338,
                "142": 381,
                "145": 8216,
                "146": 8217,
                "147": 8220,
                "148": 8221,
                "149": 8226,
                "150": 8211,
                "151": 8212,
                "152": 732,
                "153": 8482,
                "154": 353,
                "155": 8250,
                "156": 339,
                "158": 382,
                "159": 376
            };

            /***/
        }),
        /* 510 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";

//parse Empty Node as self closing node
            const buildOptions = __webpack_require__(176).buildOptions;

            const defaultOptions = {
                attributeNamePrefix: '@_',
                attrNodeName: false,
                textNodeName: '#text',
                ignoreAttributes: true,
                cdataTagName: false,
                cdataPositionChar: '\\c',
                format: false,
                indentBy: '  ',
                supressEmptyNode: false,
                tagValueProcessor: function (a) {
                    return a;
                },
                attrValueProcessor: function (a) {
                    return a;
                },
            };

            const props = [
                'attributeNamePrefix',
                'attrNodeName',
                'textNodeName',
                'ignoreAttributes',
                'cdataTagName',
                'cdataPositionChar',
                'format',
                'indentBy',
                'supressEmptyNode',
                'tagValueProcessor',
                'attrValueProcessor',
            ];

            function Parser(options) {
                this.options = buildOptions(options, defaultOptions, props);
                if (this.options.ignoreAttributes || this.options.attrNodeName) {
                    this.isAttribute = function (/*a*/) {
                        return false;
                    };
                } else {
                    this.attrPrefixLen = this.options.attributeNamePrefix.length;
                    this.isAttribute = isAttribute;
                }
                if (this.options.cdataTagName) {
                    this.isCDATA = isCDATA;
                } else {
                    this.isCDATA = function (/*a*/) {
                        return false;
                    };
                }
                this.replaceCDATAstr = replaceCDATAstr;
                this.replaceCDATAarr = replaceCDATAarr;

                if (this.options.format) {
                    this.indentate = indentate;
                    this.tagEndChar = '>\n';
                    this.newLine = '\n';
                } else {
                    this.indentate = function () {
                        return '';
                    };
                    this.tagEndChar = '>';
                    this.newLine = '';
                }

                if (this.options.supressEmptyNode) {
                    this.buildTextNode = buildEmptyTextNode;
                    this.buildObjNode = buildEmptyObjNode;
                } else {
                    this.buildTextNode = buildTextValNode;
                    this.buildObjNode = buildObjectNode;
                }

                this.buildTextValNode = buildTextValNode;
                this.buildObjectNode = buildObjectNode;
            }

            Parser.prototype.parse = function (jObj) {
                return this.j2x(jObj, 0).val;
            };

            Parser.prototype.j2x = function (jObj, level) {
                let attrStr = '';
                let val = '';
                const keys = Object.keys(jObj);
                const len = keys.length;
                for (let i = 0; i < len; i++) {
                    const key = keys[i];
                    if (typeof jObj[key] === 'undefined') {
                        // supress undefined node
                    } else if (jObj[key] === null) {
                        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
                    } else if (jObj[key] instanceof Date) {
                        val += this.buildTextNode(jObj[key], key, '', level);
                    } else if (typeof jObj[key] !== 'object') {
                        //premitive type
                        const attr = this.isAttribute(key);
                        if (attr) {
                            attrStr += ' ' + attr + '="' + this.options.attrValueProcessor('' + jObj[key]) + '"';
                        } else if (this.isCDATA(key)) {
                            if (jObj[this.options.textNodeName]) {
                                val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);
                            } else {
                                val += this.replaceCDATAstr('', jObj[key]);
                            }
                        } else {
                            //tag value
                            if (key === this.options.textNodeName) {
                                if (jObj[this.options.cdataTagName]) {
                                    //value will added while processing cdata
                                } else {
                                    val += this.options.tagValueProcessor('' + jObj[key]);
                                }
                            } else {
                                val += this.buildTextNode(jObj[key], key, '', level);
                            }
                        }
                    } else if (Array.isArray(jObj[key])) {
                        //repeated nodes
                        if (this.isCDATA(key)) {
                            val += this.indentate(level);
                            if (jObj[this.options.textNodeName]) {
                                val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);
                            } else {
                                val += this.replaceCDATAarr('', jObj[key]);
                            }
                        } else {
                            //nested nodes
                            const arrLen = jObj[key].length;
                            for (let j = 0; j < arrLen; j++) {
                                const item = jObj[key][j];
                                if (typeof item === 'undefined') {
                                    // supress undefined node
                                } else if (item === null) {
                                    val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
                                } else if (typeof item === 'object') {
                                    const result = this.j2x(item, level + 1);
                                    val += this.buildObjNode(result.val, key, result.attrStr, level);
                                } else {
                                    val += this.buildTextNode(item, key, '', level);
                                }
                            }
                        }
                    } else {
                        //nested node
                        if (this.options.attrNodeName && key === this.options.attrNodeName) {
                            const Ks = Object.keys(jObj[key]);
                            const L = Ks.length;
                            for (let j = 0; j < L; j++) {
                                attrStr += ' ' + Ks[j] + '="' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '"';
                            }
                        } else {
                            const result = this.j2x(jObj[key], level + 1);
                            val += this.buildObjNode(result.val, key, result.attrStr, level);
                        }
                    }
                }
                return {attrStr: attrStr, val: val};
            };

            function replaceCDATAstr(str, cdata) {
                str = this.options.tagValueProcessor('' + str);
                if (this.options.cdataPositionChar === '' || str === '') {
                    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;
                } else {
                    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);
                }
            }

            function replaceCDATAarr(str, cdata) {
                str = this.options.tagValueProcessor('' + str);
                if (this.options.cdataPositionChar === '' || str === '') {
                    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;
                } else {
                    for (let v in cdata) {
                        str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');
                    }
                    return str + this.newLine;
                }
            }

            function buildObjectNode(val, key, attrStr, level) {
                if (attrStr && !val.includes('<')) {
                    return (
                        this.indentate(level) +
                        '<' +
                        key +
                        attrStr +
                        '>' +
                        val +
                        //+ this.newLine
                        // + this.indentate(level)
                        '</' +
                        key +
                        this.tagEndChar
                    );
                } else {
                    return (
                        this.indentate(level) +
                        '<' +
                        key +
                        attrStr +
                        this.tagEndChar +
                        val +
                        //+ this.newLine
                        this.indentate(level) +
                        '</' +
                        key +
                        this.tagEndChar
                    );
                }
            }

            function buildEmptyObjNode(val, key, attrStr, level) {
                if (val !== '') {
                    return this.buildObjectNode(val, key, attrStr, level);
                } else {
                    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
                    //+ this.newLine
                }
            }

            function buildTextValNode(val, key, attrStr, level) {
                return (
                    this.indentate(level) +
                    '<' +
                    key +
                    attrStr +
                    '>' +
                    this.options.tagValueProcessor(val) +
                    '</' +
                    key +
                    this.tagEndChar
                );
            }

            function buildEmptyTextNode(val, key, attrStr, level) {
                if (val !== '') {
                    return this.buildTextValNode(val, key, attrStr, level);
                } else {
                    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
                }
            }

            function indentate(level) {
                return this.options.indentBy.repeat(level);
            }

            function isAttribute(name /*, options*/) {
                if (name.startsWith(this.options.attributeNamePrefix)) {
                    return name.substr(this.attrPrefixLen);
                } else {
                    return false;
                }
            }

            function isCDATA(name) {
                return name === this.options.cdataTagName;
            }

//formatting
//indentation
//\n after each closing or self closing tag

            module.exports = Parser;


            /***/
        }),
        /* 511 */,
        /* 512 */,
        /* 513 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetRoleCredentialsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(518);
            const Aws_restJson1_1 = __webpack_require__(492);

            class GetRoleCredentialsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SSOClient";
                    const commandName = "GetRoleCredentialsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetRoleCredentialsRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetRoleCredentialsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_restJson1_1.serializeAws_restJson1GetRoleCredentialsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_restJson1_1.deserializeAws_restJson1GetRoleCredentialsCommand)(output, context);
                }
            }

            exports.GetRoleCredentialsCommand = GetRoleCredentialsCommand;


            /***/
        }),
        /* 514 */,
        /* 515 */,
        /* 516 */,
        /* 517 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CredentialsProviderError = void 0;
            const ProviderError_1 = __webpack_require__(354);

            class CredentialsProviderError extends ProviderError_1.ProviderError {
                constructor(message, tryNextLink = true) {
                    super(message, tryNextLink);
                    this.tryNextLink = tryNextLink;
                    this.name = "CredentialsProviderError";
                    Object.setPrototypeOf(this, CredentialsProviderError.prototype);
                }
            }

            exports.CredentialsProviderError = CredentialsProviderError;


            /***/
        }),
        /* 518 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.LogoutRequest = exports.ListAccountsResponse = exports.ListAccountsRequest = exports.ListAccountRolesResponse = exports.RoleInfo = exports.ListAccountRolesRequest = exports.UnauthorizedException = exports.TooManyRequestsException = exports.ResourceNotFoundException = exports.InvalidRequestException = exports.GetRoleCredentialsResponse = exports.RoleCredentials = exports.GetRoleCredentialsRequest = exports.AccountInfo = void 0;
            const smithy_client_1 = __webpack_require__(449);
            const SSOServiceException_1 = __webpack_require__(238);
            var AccountInfo;
            (function (AccountInfo) {
                AccountInfo.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AccountInfo = exports.AccountInfo || (exports.AccountInfo = {}));
            var GetRoleCredentialsRequest;
            (function (GetRoleCredentialsRequest) {
                GetRoleCredentialsRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                    ...(obj.accessToken && {accessToken: smithy_client_1.SENSITIVE_STRING}),
                });
            })(GetRoleCredentialsRequest = exports.GetRoleCredentialsRequest || (exports.GetRoleCredentialsRequest = {}));
            var RoleCredentials;
            (function (RoleCredentials) {
                RoleCredentials.filterSensitiveLog = (obj) => ({
                    ...obj,
                    ...(obj.secretAccessKey && {secretAccessKey: smithy_client_1.SENSITIVE_STRING}),
                    ...(obj.sessionToken && {sessionToken: smithy_client_1.SENSITIVE_STRING}),
                });
            })(RoleCredentials = exports.RoleCredentials || (exports.RoleCredentials = {}));
            var GetRoleCredentialsResponse;
            (function (GetRoleCredentialsResponse) {
                GetRoleCredentialsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                    ...(obj.roleCredentials && {roleCredentials: RoleCredentials.filterSensitiveLog(obj.roleCredentials)}),
                });
            })(GetRoleCredentialsResponse = exports.GetRoleCredentialsResponse || (exports.GetRoleCredentialsResponse = {}));

            class InvalidRequestException extends SSOServiceException_1.SSOServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidRequestException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidRequestException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidRequestException.prototype);
                }
            }

            exports.InvalidRequestException = InvalidRequestException;

            class ResourceNotFoundException extends SSOServiceException_1.SSOServiceException {
                constructor(opts) {
                    super({
                        name: "ResourceNotFoundException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "ResourceNotFoundException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
                }
            }

            exports.ResourceNotFoundException = ResourceNotFoundException;

            class TooManyRequestsException extends SSOServiceException_1.SSOServiceException {
                constructor(opts) {
                    super({
                        name: "TooManyRequestsException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "TooManyRequestsException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, TooManyRequestsException.prototype);
                }
            }

            exports.TooManyRequestsException = TooManyRequestsException;

            class UnauthorizedException extends SSOServiceException_1.SSOServiceException {
                constructor(opts) {
                    super({
                        name: "UnauthorizedException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "UnauthorizedException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, UnauthorizedException.prototype);
                }
            }

            exports.UnauthorizedException = UnauthorizedException;
            var ListAccountRolesRequest;
            (function (ListAccountRolesRequest) {
                ListAccountRolesRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                    ...(obj.accessToken && {accessToken: smithy_client_1.SENSITIVE_STRING}),
                });
            })(ListAccountRolesRequest = exports.ListAccountRolesRequest || (exports.ListAccountRolesRequest = {}));
            var RoleInfo;
            (function (RoleInfo) {
                RoleInfo.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(RoleInfo = exports.RoleInfo || (exports.RoleInfo = {}));
            var ListAccountRolesResponse;
            (function (ListAccountRolesResponse) {
                ListAccountRolesResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListAccountRolesResponse = exports.ListAccountRolesResponse || (exports.ListAccountRolesResponse = {}));
            var ListAccountsRequest;
            (function (ListAccountsRequest) {
                ListAccountsRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                    ...(obj.accessToken && {accessToken: smithy_client_1.SENSITIVE_STRING}),
                });
            })(ListAccountsRequest = exports.ListAccountsRequest || (exports.ListAccountsRequest = {}));
            var ListAccountsResponse;
            (function (ListAccountsResponse) {
                ListAccountsResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(ListAccountsResponse = exports.ListAccountsResponse || (exports.ListAccountsResponse = {}));
            var LogoutRequest;
            (function (LogoutRequest) {
                LogoutRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                    ...(obj.accessToken && {accessToken: smithy_client_1.SENSITIVE_STRING}),
                });
            })(LogoutRequest = exports.LogoutRequest || (exports.LogoutRequest = {}));


            /***/
        }),
        /* 519 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(283), exports);


            /***/
        }),
        /* 520 */,
        /* 521 */,
        /* 522 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SESClient = void 0;
            const config_resolver_1 = __webpack_require__(772);
            const middleware_content_length_1 = __webpack_require__(193);
            const middleware_host_header_1 = __webpack_require__(318);
            const middleware_logger_1 = __webpack_require__(676);
            const middleware_retry_1 = __webpack_require__(806);
            const middleware_signing_1 = __webpack_require__(22);
            const middleware_user_agent_1 = __webpack_require__(624);
            const smithy_client_1 = __webpack_require__(449);
            const runtimeConfig_1 = __webpack_require__(892);

            class SESClient extends smithy_client_1.Client {
                constructor(configuration) {
                    const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
                    const _config_1 = (0, config_resolver_1.resolveRegionConfig)(_config_0);
                    const _config_2 = (0, config_resolver_1.resolveEndpointsConfig)(_config_1);
                    const _config_3 = (0, middleware_retry_1.resolveRetryConfig)(_config_2);
                    const _config_4 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_3);
                    const _config_5 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_4);
                    const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
                    super(_config_6);
                    this.config = _config_6;
                    this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
                }

                destroy() {
                    super.destroy();
                }
            }

            exports.SESClient = SESClient;


            /***/
        }),
        /* 523 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getCanonicalHeaders = void 0;
            const constants_1 = __webpack_require__(70);
            const getCanonicalHeaders = ({headers}, unsignableHeaders, signableHeaders) => {
                const canonical = {};
                for (const headerName of Object.keys(headers).sort()) {
                    const canonicalHeaderName = headerName.toLowerCase();
                    if (canonicalHeaderName in constants_1.ALWAYS_UNSIGNABLE_HEADERS ||
                        (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) ||
                        constants_1.PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
                        constants_1.SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
                        if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                            continue;
                        }
                    }
                    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
                }
                return canonical;
            };
            exports.getCanonicalHeaders = getCanonicalHeaders;


            /***/
        }),
        /* 524 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(482), exports);


            /***/
        }),
        /* 525 */,
        /* 526 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 527 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _validate = _interopRequireDefault(__webpack_require__(960));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            function parse(uuid) {
                if (!(0, _validate.default)(uuid)) {
                    throw TypeError('Invalid UUID');
                }

                let v;
                const arr = new Uint8Array(16); // Parse ########-....-....-....-............

                arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
                arr[1] = v >>> 16 & 0xff;
                arr[2] = v >>> 8 & 0xff;
                arr[3] = v & 0xff; // Parse ........-####-....-....-............

                arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
                arr[5] = v & 0xff; // Parse ........-....-####-....-............

                arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
                arr[7] = v & 0xff; // Parse ........-....-....-####-............

                arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
                arr[9] = v & 0xff; // Parse ........-....-....-....-############
                // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

                arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
                arr[11] = v / 0x100000000 & 0xff;
                arr[12] = v >>> 24 & 0xff;
                arr[13] = v >>> 16 & 0xff;
                arr[14] = v >>> 8 & 0xff;
                arr[15] = v & 0xff;
                return arr;
            }

            var _default = parse;
            exports.default = _default;

            /***/
        }),
        /* 528 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const Transform = __webpack_require__(413).Transform;

            /**
             * Encodes a Buffer into a base64 encoded string
             *
             * @param {Buffer} buffer Buffer to convert
             * @returns {String} base64 encoded string
             */
            function encode(buffer) {
                if (typeof buffer === 'string') {
                    buffer = Buffer.from(buffer, 'utf-8');
                }

                return buffer.toString('base64');
            }

            /**
             * Adds soft line breaks to a base64 string
             *
             * @param {String} str base64 encoded string that might need line wrapping
             * @param {Number} [lineLength=76] Maximum allowed length for a line
             * @returns {String} Soft-wrapped base64 encoded string
             */
            function wrap(str, lineLength) {
                str = (str || '').toString();
                lineLength = lineLength || 76;

                if (str.length <= lineLength) {
                    return str;
                }

                let result = [];
                let pos = 0;
                let chunkLength = lineLength * 1024;
                while (pos < str.length) {
                    let wrappedLines = str
                        .substr(pos, chunkLength)
                        .replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\r\n')
                        .trim();
                    result.push(wrappedLines);
                    pos += chunkLength;
                }

                return result.join('\r\n').trim();
            }

            /**
             * Creates a transform stream for encoding data to base64 encoding
             *
             * @constructor
             * @param {Object} options Stream options
             * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping
             */
            class Encoder extends Transform {
                constructor(options) {
                    super();
                    // init Transform
                    this.options = options || {};

                    if (this.options.lineLength !== false) {
                        this.options.lineLength = this.options.lineLength || 76;
                    }

                    this._curLine = '';
                    this._remainingBytes = false;

                    this.inputBytes = 0;
                    this.outputBytes = 0;
                }

                _transform(chunk, encoding, done) {
                    if (encoding !== 'buffer') {
                        chunk = Buffer.from(chunk, encoding);
                    }

                    if (!chunk || !chunk.length) {
                        return setImmediate(done);
                    }

                    this.inputBytes += chunk.length;

                    if (this._remainingBytes && this._remainingBytes.length) {
                        chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);
                        this._remainingBytes = false;
                    }

                    if (chunk.length % 3) {
                        this._remainingBytes = chunk.slice(chunk.length - (chunk.length % 3));
                        chunk = chunk.slice(0, chunk.length - (chunk.length % 3));
                    } else {
                        this._remainingBytes = false;
                    }

                    let b64 = this._curLine + encode(chunk);

                    if (this.options.lineLength) {
                        b64 = wrap(b64, this.options.lineLength);

                        // remove last line as it is still most probably incomplete
                        let lastLF = b64.lastIndexOf('\n');
                        if (lastLF < 0) {
                            this._curLine = b64;
                            b64 = '';
                        } else if (lastLF === b64.length - 1) {
                            this._curLine = '';
                        } else {
                            this._curLine = b64.substr(lastLF + 1);
                            b64 = b64.substr(0, lastLF + 1);
                        }
                    }

                    if (b64) {
                        this.outputBytes += b64.length;
                        this.push(Buffer.from(b64, 'ascii'));
                    }

                    setImmediate(done);
                }

                _flush(done) {
                    if (this._remainingBytes && this._remainingBytes.length) {
                        this._curLine += encode(this._remainingBytes);
                    }

                    if (this._curLine) {
                        this._curLine = wrap(this._curLine, this.options.lineLength);
                        this.outputBytes += this._curLine.length;
                        this.push(this._curLine, 'ascii');
                        this._curLine = '';
                    }
                    done();
                }
            }

// expose to the world
            module.exports = {
                encode,
                wrap,
                Encoder
            };


            /***/
        }),
        /* 529 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const Transform = __webpack_require__(413).Transform;

            /**
             * Encodes a Buffer into a Quoted-Printable encoded string
             *
             * @param {Buffer} buffer Buffer to convert
             * @returns {String} Quoted-Printable encoded string
             */
            function encode(buffer) {
                if (typeof buffer === 'string') {
                    buffer = Buffer.from(buffer, 'utf-8');
                }

                // usable characters that do not need encoding
                let ranges = [
                    // https://tools.ietf.org/html/rfc2045#section-6.7
                    [0x09], // <TAB>
                    [0x0a], // <LF>
                    [0x0d], // <CR>
                    [0x20, 0x3c], // <SP>!"#$%&'()*+,-./0123456789:;
                    [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
                ];
                let result = '';
                let ord;

                for (let i = 0, len = buffer.length; i < len; i++) {
                    ord = buffer[i];
                    // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line
                    if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {
                        result += String.fromCharCode(ord);
                        continue;
                    }
                    result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();
                }

                return result;
            }

            /**
             * Adds soft line breaks to a Quoted-Printable string
             *
             * @param {String} str Quoted-Printable encoded string that might need line wrapping
             * @param {Number} [lineLength=76] Maximum allowed length for a line
             * @returns {String} Soft-wrapped Quoted-Printable encoded string
             */
            function wrap(str, lineLength) {
                str = (str || '').toString();
                lineLength = lineLength || 76;

                if (str.length <= lineLength) {
                    return str;
                }

                let pos = 0;
                let len = str.length;
                let match, code, line;
                let lineMargin = Math.floor(lineLength / 3);
                let result = '';

                // insert soft linebreaks where needed
                while (pos < len) {
                    line = str.substr(pos, lineLength);
                    if ((match = line.match(/\r\n/))) {
                        line = line.substr(0, match.index + match[0].length);
                        result += line;
                        pos += line.length;
                        continue;
                    }

                    if (line.substr(-1) === '\n') {
                        // nothing to change here
                        result += line;
                        pos += line.length;
                        continue;
                    } else if ((match = line.substr(-lineMargin).match(/\n.*?$/))) {
                        // truncate to nearest line break
                        line = line.substr(0, line.length - (match[0].length - 1));
                        result += line;
                        pos += line.length;
                        continue;
                    } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
                        // truncate to nearest space
                        line = line.substr(0, line.length - (match[0].length - 1));
                    } else if (line.match(/[=][\da-f]{0,2}$/i)) {
                        // push incomplete encoding sequences to the next line
                        if ((match = line.match(/[=][\da-f]{0,1}$/i))) {
                            line = line.substr(0, line.length - match[0].length);
                        }

                        // ensure that utf-8 sequences are not split
                        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\da-f]{2}$/gi))) {
                            code = parseInt(match[0].substr(1, 2), 16);
                            if (code < 128) {
                                break;
                            }

                            line = line.substr(0, line.length - 3);

                            if (code >= 0xc0) {
                                break;
                            }
                        }
                    }

                    if (pos + line.length < len && line.substr(-1) !== '\n') {
                        if (line.length === lineLength && line.match(/[=][\da-f]{2}$/i)) {
                            line = line.substr(0, line.length - 3);
                        } else if (line.length === lineLength) {
                            line = line.substr(0, line.length - 1);
                        }
                        pos += line.length;
                        line += '=\r\n';
                    } else {
                        pos += line.length;
                    }

                    result += line;
                }

                return result;
            }

            /**
             * Helper function to check if a number is inside provided ranges
             *
             * @param {Number} nr Number to check for
             * @param {Array} ranges An Array of allowed values
             * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise
             */
            function checkRanges(nr, ranges) {
                for (let i = ranges.length - 1; i >= 0; i--) {
                    if (!ranges[i].length) {
                        continue;
                    }
                    if (ranges[i].length === 1 && nr === ranges[i][0]) {
                        return true;
                    }
                    if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
                        return true;
                    }
                }
                return false;
            }

            /**
             * Creates a transform stream for encoding data to Quoted-Printable encoding
             *
             * @constructor
             * @param {Object} options Stream options
             * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping
             */
            class Encoder extends Transform {
                constructor(options) {
                    super();

                    // init Transform
                    this.options = options || {};

                    if (this.options.lineLength !== false) {
                        this.options.lineLength = this.options.lineLength || 76;
                    }

                    this._curLine = '';

                    this.inputBytes = 0;
                    this.outputBytes = 0;
                }

                _transform(chunk, encoding, done) {
                    let qp;

                    if (encoding !== 'buffer') {
                        chunk = Buffer.from(chunk, encoding);
                    }

                    if (!chunk || !chunk.length) {
                        return done();
                    }

                    this.inputBytes += chunk.length;

                    if (this.options.lineLength) {
                        qp = this._curLine + encode(chunk);
                        qp = wrap(qp, this.options.lineLength);
                        qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine) => {
                            this._curLine = lastLine;
                            return lineBreak;
                        });

                        if (qp) {
                            this.outputBytes += qp.length;
                            this.push(qp);
                        }
                    } else {
                        qp = encode(chunk);
                        this.outputBytes += qp.length;
                        this.push(qp, 'ascii');
                    }

                    done();
                }

                _flush(done) {
                    if (this._curLine) {
                        this.outputBytes += this._curLine.length;
                        this.push(this._curLine, 'ascii');
                    }
                    done();
                }
            }

// expose to the world
            module.exports = {
                encode,
                wrap,
                Encoder
            };


            /***/
        }),
        /* 530 */,
        /* 531 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) {
                    return value instanceof P ? value : new P(function (resolve) {
                        resolve(value);
                    });
                }

                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.OidcClient = void 0;
            const http_client_1 = __webpack_require__(368);
            const auth_1 = __webpack_require__(977);
            const core_1 = __webpack_require__(357);

            class OidcClient {
                static createHttpClient(allowRetry = true, maxRetry = 10) {
                    const requestOptions = {
                        allowRetries: allowRetry,
                        maxRetries: maxRetry
                    };
                    return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
                }

                static getRequestToken() {
                    const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
                    if (!token) {
                        throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
                    }
                    return token;
                }

                static getIDTokenUrl() {
                    const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
                    if (!runtimeUrl) {
                        throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
                    }
                    return runtimeUrl;
                }

                static getCall(id_token_url) {
                    var _a;
                    return __awaiter(this, void 0, void 0, function* () {
                        const httpclient = OidcClient.createHttpClient();
                        const res = yield httpclient
                            .getJson(id_token_url)
                            .catch(error => {
                                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
                            });
                        const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
                        if (!id_token) {
                            throw new Error('Response json body do not have ID Token field');
                        }
                        return id_token;
                    });
                }

                static getIDToken(audience) {
                    return __awaiter(this, void 0, void 0, function* () {
                        try {
                            // New ID Token is requested from action service
                            let id_token_url = OidcClient.getIDTokenUrl();
                            if (audience) {
                                const encodedAudience = encodeURIComponent(audience);
                                id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                            }
                            core_1.debug(`ID token url is ${id_token_url}`);
                            const id_token = yield OidcClient.getCall(id_token_url);
                            core_1.setSecret(id_token);
                            return id_token;
                        } catch (error) {
                            throw new Error(`Error message: ${error.message}`);
                        }
                    });
                }
            }

            exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

            /***/
        }),
        /* 532 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.checkExceptions = exports.WaiterState = exports.waiterServiceDefaults = void 0;
            exports.waiterServiceDefaults = {
                minDelay: 2,
                maxDelay: 120,
            };
            var WaiterState;
            (function (WaiterState) {
                WaiterState["ABORTED"] = "ABORTED";
                WaiterState["FAILURE"] = "FAILURE";
                WaiterState["SUCCESS"] = "SUCCESS";
                WaiterState["RETRY"] = "RETRY";
                WaiterState["TIMEOUT"] = "TIMEOUT";
            })(WaiterState = exports.WaiterState || (exports.WaiterState = {}));
            const checkExceptions = (result) => {
                if (result.state === WaiterState.ABORTED) {
                    const abortError = new Error(`${JSON.stringify({
                        ...result,
                        reason: "Request was aborted",
                    })}`);
                    abortError.name = "AbortError";
                    throw abortError;
                } else if (result.state === WaiterState.TIMEOUT) {
                    const timeoutError = new Error(`${JSON.stringify({
                        ...result,
                        reason: "Waiter has timed out",
                    })}`);
                    timeoutError.name = "TimeoutError";
                    throw timeoutError;
                } else if (result.state !== WaiterState.SUCCESS) {
                    throw new Error(`${JSON.stringify({result})}`);
                }
                return result;
            };
            exports.checkExceptions = checkExceptions;


            /***/
        }),
        /* 533 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromSSO = void 0;
            const property_provider_1 = __webpack_require__(118);
            const shared_ini_file_loader_1 = __webpack_require__(706);
            const isSsoProfile_1 = __webpack_require__(215);
            const resolveSSOCredentials_1 = __webpack_require__(102);
            const validateSsoProfile_1 = __webpack_require__(347);
            const fromSSO = (init = {}) => async () => {
                const {ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient} = init;
                if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName) {
                    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
                    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
                    const profile = profiles[profileName];
                    if (!(0, isSsoProfile_1.isSsoProfile)(profile)) {
                        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
                    }
                    const {
                        sso_start_url,
                        sso_account_id,
                        sso_region,
                        sso_role_name
                    } = (0, validateSsoProfile_1.validateSsoProfile)(profile);
                    return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
                        ssoStartUrl: sso_start_url,
                        ssoAccountId: sso_account_id,
                        ssoRegion: sso_region,
                        ssoRoleName: sso_role_name,
                        ssoClient: ssoClient,
                    });
                } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
                    throw new property_provider_1.CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl",' +
                        ' "ssoAccountId", "ssoRegion", "ssoRoleName"');
                } else {
                    return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
                        ssoStartUrl,
                        ssoAccountId,
                        ssoRegion,
                        ssoRoleName,
                        ssoClient
                    });
                }
            };
            exports.fromSSO = fromSSO;


            /***/
        }),
        /* 534 */,
        /* 535 */,
        /* 536 */,
        /* 537 */,
        /* 538 */,
        /* 539 */,
        /* 540 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRetryPlugin = exports.retryMiddlewareOptions = exports.retryMiddleware = void 0;
            const retryMiddleware = (options) => (next, context) => async (args) => {
                const retryStrategy = await options.retryStrategy();
                if (retryStrategy === null || retryStrategy === void 0 ? void 0 : retryStrategy.mode)
                    context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
                return retryStrategy.retry(next, args);
            };
            exports.retryMiddleware = retryMiddleware;
            exports.retryMiddlewareOptions = {
                name: "retryMiddleware",
                tags: ["RETRY"],
                step: "finalizeRequest",
                priority: "high",
                override: true,
            };
            const getRetryPlugin = (options) => ({
                applyToStack: (clientStack) => {
                    clientStack.add((0, exports.retryMiddleware)(options), exports.retryMiddlewareOptions);
                },
            });
            exports.getRetryPlugin = getRetryPlugin;


            /***/
        }),
        /* 541 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = _default;
            exports.URL = exports.DNS = void 0;

            var _stringify = _interopRequireDefault(__webpack_require__(993));

            var _parse = _interopRequireDefault(__webpack_require__(527));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            function stringToBytes(str) {
                str = unescape(encodeURIComponent(str)); // UTF8 escape

                const bytes = [];

                for (let i = 0; i < str.length; ++i) {
                    bytes.push(str.charCodeAt(i));
                }

                return bytes;
            }

            const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
            exports.DNS = DNS;
            const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
            exports.URL = URL;

            function _default(name, version, hashfunc) {
                function generateUUID(value, namespace, buf, offset) {
                    if (typeof value === 'string') {
                        value = stringToBytes(value);
                    }

                    if (typeof namespace === 'string') {
                        namespace = (0, _parse.default)(namespace);
                    }

                    if (namespace.length !== 16) {
                        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
                    } // Compute hash of namespace and value, Per 4.3
                    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
                    // hashfunc([...namespace, ... value])`


                    let bytes = new Uint8Array(16 + value.length);
                    bytes.set(namespace);
                    bytes.set(value, namespace.length);
                    bytes = hashfunc(bytes);
                    bytes[6] = bytes[6] & 0x0f | version;
                    bytes[8] = bytes[8] & 0x3f | 0x80;

                    if (buf) {
                        offset = offset || 0;

                        for (let i = 0; i < 16; ++i) {
                            buf[offset + i] = bytes[i];
                        }

                        return buf;
                    }

                    return (0, _stringify.default)(bytes);
                } // Function#name is not settable on some platforms (#270)


                try {
                    generateUUID.name = name; // eslint-disable-next-line no-empty
                } catch (err) {
                } // For CommonJS default export support


                generateUUID.DNS = DNS;
                generateUUID.URL = URL;
                return generateUUID;
            }

            /***/
        }),
        /* 542 */,
        /* 543 */,
        /* 544 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveProcessCredentials = void 0;
            const property_provider_1 = __webpack_require__(118);
            const child_process_1 = __webpack_require__(129);
            const util_1 = __webpack_require__(669);
            const getValidatedProcessCredentials_1 = __webpack_require__(226);
            const resolveProcessCredentials = async (profileName, profiles) => {
                const profile = profiles[profileName];
                if (profiles[profileName]) {
                    const credentialProcess = profile["credential_process"];
                    if (credentialProcess !== undefined) {
                        const execPromise = (0, util_1.promisify)(child_process_1.exec);
                        try {
                            const {stdout} = await execPromise(credentialProcess);
                            let data;
                            try {
                                data = JSON.parse(stdout.trim());
                            } catch (_a) {
                                throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
                            }
                            return (0, getValidatedProcessCredentials_1.getValidatedProcessCredentials)(profileName, data);
                        } catch (error) {
                            throw new property_provider_1.CredentialsProviderError(error.message);
                        }
                    } else {
                        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
                    }
                } else {
                    throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
                }
            };
            exports.resolveProcessCredentials = resolveProcessCredentials;


            /***/
        }),
        /* 545 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.retry = void 0;
            const retry = (toRetry, maxRetries) => {
                let promise = toRetry();
                for (let i = 0; i < maxRetries; i++) {
                    promise = promise.catch(toRetry);
                }
                return promise;
            };
            exports.retry = retry;


            /***/
        }),
        /* 546 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CreateConfigurationSetEventDestinationCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CreateConfigurationSetEventDestinationCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CreateConfigurationSetEventDestinationCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CreateConfigurationSetEventDestinationRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.CreateConfigurationSetEventDestinationResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCreateConfigurationSetEventDestinationCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCreateConfigurationSetEventDestinationCommand)(output, context);
                }
            }

            exports.CreateConfigurationSetEventDestinationCommand = CreateConfigurationSetEventDestinationCommand;


            /***/
        }),
        /* 547 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _validate = _interopRequireDefault(__webpack_require__(960));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            function version(uuid) {
                if (!(0, _validate.default)(uuid)) {
                    throw TypeError('Invalid UUID');
                }

                return parseInt(uuid.substr(14, 1), 16);
            }

            var _default = version;
            exports.default = _default;

            /***/
        }),
        /* 548 */,
        /* 549 */,
        /* 550 */,
        /* 551 */,
        /* 552 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(589), exports);


            /***/
        }),
        /* 553 */,
        /* 554 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CreateTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CreateTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CreateTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CreateTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.CreateTemplateResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCreateTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCreateTemplateCommand)(output, context);
                }
            }

            exports.CreateTemplateCommand = CreateTemplateCommand;


            /***/
        }),
        /* 555 */,
        /* 556 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_DUALSTACK_ENDPOINT = exports.CONFIG_USE_DUALSTACK_ENDPOINT = exports.ENV_USE_DUALSTACK_ENDPOINT = void 0;
            const util_config_provider_1 = __webpack_require__(361);
            exports.ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
            exports.CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
            exports.DEFAULT_USE_DUALSTACK_ENDPOINT = false;
            exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
                environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.ENV),
                configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
                default: false,
            };


            /***/
        }),
        /* 557 */,
        /* 558 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveProfileData = void 0;
            const property_provider_1 = __webpack_require__(118);
            const resolveAssumeRoleCredentials_1 = __webpack_require__(601);
            const resolveSsoCredentials_1 = __webpack_require__(183);
            const resolveStaticCredentials_1 = __webpack_require__(473);
            const resolveWebIdentityCredentials_1 = __webpack_require__(568);
            const resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}) => {
                const data = profiles[profileName];
                if (Object.keys(visitedProfiles).length > 0 && (0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
                    return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
                }
                if ((0, resolveAssumeRoleCredentials_1.isAssumeRoleProfile)(data)) {
                    return (0, resolveAssumeRoleCredentials_1.resolveAssumeRoleCredentials)(profileName, profiles, options, visitedProfiles);
                }
                if ((0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
                    return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
                }
                if ((0, resolveWebIdentityCredentials_1.isWebIdentityProfile)(data)) {
                    return (0, resolveWebIdentityCredentials_1.resolveWebIdentityCredentials)(data, options);
                }
                if ((0, resolveSsoCredentials_1.isSsoProfile)(data)) {
                    return (0, resolveSsoCredentials_1.resolveSsoCredentials)(data);
                }
                throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
            };
            exports.resolveProfileData = resolveProfileData;


            /***/
        }),
        /* 559 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : {"default": mod};
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
            var xml_json_1 = __importDefault(__webpack_require__(699));
            var inverseXML = getInverseObj(xml_json_1.default);
            var xmlReplacer = getInverseReplacer(inverseXML);
            /**
             * Encodes all non-ASCII characters, as well as characters not valid in XML
             * documents using XML entities.
             *
             * If a character has no equivalent entity, a
             * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
             */
            exports.encodeXML = getASCIIEncoder(inverseXML);
            var entities_json_1 = __importDefault(__webpack_require__(265));
            var inverseHTML = getInverseObj(entities_json_1.default);
            var htmlReplacer = getInverseReplacer(inverseHTML);
            /**
             * Encodes all entities and non-ASCII characters in the input.
             *
             * This includes characters that are valid ASCII characters in HTML documents.
             * For example `#` will be encoded as `&num;`. To get a more compact output,
             * consider using the `encodeNonAsciiHTML` function.
             *
             * If a character has no equivalent entity, a
             * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
             */
            exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
            /**
             * Encodes all non-ASCII characters, as well as characters not valid in HTML
             * documents using HTML entities.
             *
             * If a character has no equivalent entity, a
             * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
             */
            exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);

            function getInverseObj(obj) {
                return Object.keys(obj)
                    .sort()
                    .reduce(function (inverse, name) {
                        inverse[obj[name]] = "&" + name + ";";
                        return inverse;
                    }, {});
            }

            function getInverseReplacer(inverse) {
                var single = [];
                var multiple = [];
                for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
                    var k = _a[_i];
                    if (k.length === 1) {
                        // Add value to single array
                        single.push("\\" + k);
                    } else {
                        // Add value to multiple array
                        multiple.push(k);
                    }
                }
                // Add ranges to single characters.
                single.sort();
                for (var start = 0; start < single.length - 1; start++) {
                    // Find the end of a run of characters
                    var end = start;
                    while (end < single.length - 1 &&
                    single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
                        end += 1;
                    }
                    var count = 1 + end - start;
                    // We want to replace at least three characters
                    if (count < 3)
                        continue;
                    single.splice(start, count, single[start] + "-" + single[end]);
                }
                multiple.unshift("[" + single.join("") + "]");
                return new RegExp(multiple.join("|"), "g");
            }

// /[^\0-\x7F]/gu
            var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
            var getCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                String.prototype.codePointAt != null
                    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    function (str) {
                        return str.codePointAt(0);
                    }
                    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    function (c) {
                        return (c.charCodeAt(0) - 0xd800) * 0x400 +
                            c.charCodeAt(1) -
                            0xdc00 +
                            0x10000;
                    };

            function singleCharReplacer(c) {
                return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
                    .toString(16)
                    .toUpperCase() + ";";
            }

            function getInverse(inverse, re) {
                return function (data) {
                    return data
                        .replace(re, function (name) {
                            return inverse[name];
                        })
                        .replace(reNonASCII, singleCharReplacer);
                };
            }

            var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");

            /**
             * Encodes all non-ASCII characters, as well as characters not valid in XML
             * documents using numeric hexadecimal reference (eg. `&#xfc;`).
             *
             * Have a look at `escapeUTF8` if you want a more concise output at the expense
             * of reduced transportability.
             *
             * @param data String to escape.
             */
            function escape(data) {
                return data.replace(reEscapeChars, singleCharReplacer);
            }

            exports.escape = escape;

            /**
             * Encodes all characters not valid in XML documents using numeric hexadecimal
             * reference (eg. `&#xfc;`).
             *
             * Note that the output will be character-set dependent.
             *
             * @param data String to escape.
             */
            function escapeUTF8(data) {
                return data.replace(xmlReplacer, singleCharReplacer);
            }

            exports.escapeUTF8 = escapeUTF8;

            function getASCIIEncoder(obj) {
                return function (data) {
                    return data.replace(reEscapeChars, function (c) {
                        return obj[c] || singleCharReplacer(c);
                    });
                };
            }


            /***/
        }),
        /* 560 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.isValidHostname = void 0;

            function isValidHostname(hostname) {
                const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
                return hostPattern.test(hostname);
            }

            exports.isValidHostname = isValidHostname;


            /***/
        }),
        /* 561 */,
        /* 562 */,
        /* 563 */,
        /* 564 */,
        /* 565 */
        /***/ (function (module) {

            module.exports = require("http2");

            /***/
        }),
        /* 566 */,
        /* 567 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getHomeDir = void 0;
            const os_1 = __webpack_require__(87);
            const path_1 = __webpack_require__(622);
            const getHomeDir = () => {
                const {HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}`} = process.env;
                if (HOME)
                    return HOME;
                if (USERPROFILE)
                    return USERPROFILE;
                if (HOMEPATH)
                    return `${HOMEDRIVE}${HOMEPATH}`;
                return (0, os_1.homedir)();
            };
            exports.getHomeDir = getHomeDir;


            /***/
        }),
        /* 568 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveWebIdentityCredentials = exports.isWebIdentityProfile = void 0;
            const credential_provider_web_identity_1 = __webpack_require__(740);
            const isWebIdentityProfile = (arg) => Boolean(arg) &&
                typeof arg === "object" &&
                typeof arg.web_identity_token_file === "string" &&
                typeof arg.role_arn === "string" &&
                ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
            exports.isWebIdentityProfile = isWebIdentityProfile;
            const resolveWebIdentityCredentials = async (profile, options) => (0, credential_provider_web_identity_1.fromTokenFile)({
                webIdentityTokenFile: profile.web_identity_token_file,
                roleArn: profile.role_arn,
                roleSessionName: profile.role_session_name,
                roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
            })();
            exports.resolveWebIdentityCredentials = resolveWebIdentityCredentials;


            /***/
        }),
        /* 569 */,
        /* 570 */,
        /* 571 */,
        /* 572 */,
        /* 573 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const conversions = __webpack_require__(286);
            const utils = __webpack_require__(311);
            const Impl = __webpack_require__(665);

            const impl = utils.implSymbol;

            function URL(url) {
                if (!this || this[impl] || !(this instanceof URL)) {
                    throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
                }
                if (arguments.length < 1) {
                    throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
                }
                const args = [];
                for (let i = 0; i < arguments.length && i < 2; ++i) {
                    args[i] = arguments[i];
                }
                args[0] = conversions["USVString"](args[0]);
                if (args[1] !== undefined) {
                    args[1] = conversions["USVString"](args[1]);
                }

                module.exports.setup(this, args);
            }

            URL.prototype.toJSON = function toJSON() {
                if (!this || !module.exports.is(this)) {
                    throw new TypeError("Illegal invocation");
                }
                const args = [];
                for (let i = 0; i < arguments.length && i < 0; ++i) {
                    args[i] = arguments[i];
                }
                return this[impl].toJSON.apply(this[impl], args);
            };
            Object.defineProperty(URL.prototype, "href", {
                get() {
                    return this[impl].href;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].href = V;
                },
                enumerable: true,
                configurable: true
            });

            URL.prototype.toString = function () {
                if (!this || !module.exports.is(this)) {
                    throw new TypeError("Illegal invocation");
                }
                return this.href;
            };

            Object.defineProperty(URL.prototype, "origin", {
                get() {
                    return this[impl].origin;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "protocol", {
                get() {
                    return this[impl].protocol;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].protocol = V;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "username", {
                get() {
                    return this[impl].username;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].username = V;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "password", {
                get() {
                    return this[impl].password;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].password = V;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "host", {
                get() {
                    return this[impl].host;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].host = V;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "hostname", {
                get() {
                    return this[impl].hostname;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].hostname = V;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "port", {
                get() {
                    return this[impl].port;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].port = V;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "pathname", {
                get() {
                    return this[impl].pathname;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].pathname = V;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "search", {
                get() {
                    return this[impl].search;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].search = V;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URL.prototype, "hash", {
                get() {
                    return this[impl].hash;
                },
                set(V) {
                    V = conversions["USVString"](V);
                    this[impl].hash = V;
                },
                enumerable: true,
                configurable: true
            });


            module.exports = {
                is(obj) {
                    return !!obj && obj[impl] instanceof Impl.implementation;
                },
                create(constructorArgs, privateData) {
                    let obj = Object.create(URL.prototype);
                    this.setup(obj, constructorArgs, privateData);
                    return obj;
                },
                setup(obj, constructorArgs, privateData) {
                    if (!privateData) privateData = {};
                    privateData.wrapper = obj;

                    obj[impl] = new Impl.implementation(constructorArgs, privateData);
                    obj[impl][utils.wrapperSymbol] = obj;
                },
                interface: URL,
                expose: {
                    Window: {URL: URL},
                    Worker: {URL: URL}
                }
            };


            /***/
        }),
        /* 574 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromStatic = void 0;
            const fromStatic = (staticValue) => () => Promise.resolve(staticValue);
            exports.fromStatic = fromStatic;


            /***/
        }),
        /* 575 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetSessionTokenResponse = exports.GetSessionTokenRequest = exports.GetFederationTokenResponse = exports.FederatedUser = exports.GetFederationTokenRequest = exports.GetCallerIdentityResponse = exports.GetCallerIdentityRequest = exports.GetAccessKeyInfoResponse = exports.GetAccessKeyInfoRequest = exports.InvalidAuthorizationMessageException = exports.DecodeAuthorizationMessageResponse = exports.DecodeAuthorizationMessageRequest = exports.IDPCommunicationErrorException = exports.AssumeRoleWithWebIdentityResponse = exports.AssumeRoleWithWebIdentityRequest = exports.InvalidIdentityTokenException = exports.IDPRejectedClaimException = exports.AssumeRoleWithSAMLResponse = exports.AssumeRoleWithSAMLRequest = exports.RegionDisabledException = exports.PackedPolicyTooLargeException = exports.MalformedPolicyDocumentException = exports.ExpiredTokenException = exports.AssumeRoleResponse = exports.Credentials = exports.AssumeRoleRequest = exports.Tag = exports.PolicyDescriptorType = exports.AssumedRoleUser = void 0;
            const STSServiceException_1 = __webpack_require__(838);
            var AssumedRoleUser;
            (function (AssumedRoleUser) {
                AssumedRoleUser.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AssumedRoleUser = exports.AssumedRoleUser || (exports.AssumedRoleUser = {}));
            var PolicyDescriptorType;
            (function (PolicyDescriptorType) {
                PolicyDescriptorType.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(PolicyDescriptorType = exports.PolicyDescriptorType || (exports.PolicyDescriptorType = {}));
            var Tag;
            (function (Tag) {
                Tag.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(Tag = exports.Tag || (exports.Tag = {}));
            var AssumeRoleRequest;
            (function (AssumeRoleRequest) {
                AssumeRoleRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AssumeRoleRequest = exports.AssumeRoleRequest || (exports.AssumeRoleRequest = {}));
            var Credentials;
            (function (Credentials) {
                Credentials.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(Credentials = exports.Credentials || (exports.Credentials = {}));
            var AssumeRoleResponse;
            (function (AssumeRoleResponse) {
                AssumeRoleResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AssumeRoleResponse = exports.AssumeRoleResponse || (exports.AssumeRoleResponse = {}));

            class ExpiredTokenException extends STSServiceException_1.STSServiceException {
                constructor(opts) {
                    super({
                        name: "ExpiredTokenException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "ExpiredTokenException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, ExpiredTokenException.prototype);
                }
            }

            exports.ExpiredTokenException = ExpiredTokenException;

            class MalformedPolicyDocumentException extends STSServiceException_1.STSServiceException {
                constructor(opts) {
                    super({
                        name: "MalformedPolicyDocumentException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "MalformedPolicyDocumentException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
                }
            }

            exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;

            class PackedPolicyTooLargeException extends STSServiceException_1.STSServiceException {
                constructor(opts) {
                    super({
                        name: "PackedPolicyTooLargeException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "PackedPolicyTooLargeException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
                }
            }

            exports.PackedPolicyTooLargeException = PackedPolicyTooLargeException;

            class RegionDisabledException extends STSServiceException_1.STSServiceException {
                constructor(opts) {
                    super({
                        name: "RegionDisabledException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "RegionDisabledException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, RegionDisabledException.prototype);
                }
            }

            exports.RegionDisabledException = RegionDisabledException;
            var AssumeRoleWithSAMLRequest;
            (function (AssumeRoleWithSAMLRequest) {
                AssumeRoleWithSAMLRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AssumeRoleWithSAMLRequest = exports.AssumeRoleWithSAMLRequest || (exports.AssumeRoleWithSAMLRequest = {}));
            var AssumeRoleWithSAMLResponse;
            (function (AssumeRoleWithSAMLResponse) {
                AssumeRoleWithSAMLResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AssumeRoleWithSAMLResponse = exports.AssumeRoleWithSAMLResponse || (exports.AssumeRoleWithSAMLResponse = {}));

            class IDPRejectedClaimException extends STSServiceException_1.STSServiceException {
                constructor(opts) {
                    super({
                        name: "IDPRejectedClaimException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "IDPRejectedClaimException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
                }
            }

            exports.IDPRejectedClaimException = IDPRejectedClaimException;

            class InvalidIdentityTokenException extends STSServiceException_1.STSServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidIdentityTokenException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidIdentityTokenException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
                }
            }

            exports.InvalidIdentityTokenException = InvalidIdentityTokenException;
            var AssumeRoleWithWebIdentityRequest;
            (function (AssumeRoleWithWebIdentityRequest) {
                AssumeRoleWithWebIdentityRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AssumeRoleWithWebIdentityRequest = exports.AssumeRoleWithWebIdentityRequest || (exports.AssumeRoleWithWebIdentityRequest = {}));
            var AssumeRoleWithWebIdentityResponse;
            (function (AssumeRoleWithWebIdentityResponse) {
                AssumeRoleWithWebIdentityResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(AssumeRoleWithWebIdentityResponse = exports.AssumeRoleWithWebIdentityResponse || (exports.AssumeRoleWithWebIdentityResponse = {}));

            class IDPCommunicationErrorException extends STSServiceException_1.STSServiceException {
                constructor(opts) {
                    super({
                        name: "IDPCommunicationErrorException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "IDPCommunicationErrorException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
                }
            }

            exports.IDPCommunicationErrorException = IDPCommunicationErrorException;
            var DecodeAuthorizationMessageRequest;
            (function (DecodeAuthorizationMessageRequest) {
                DecodeAuthorizationMessageRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DecodeAuthorizationMessageRequest = exports.DecodeAuthorizationMessageRequest || (exports.DecodeAuthorizationMessageRequest = {}));
            var DecodeAuthorizationMessageResponse;
            (function (DecodeAuthorizationMessageResponse) {
                DecodeAuthorizationMessageResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(DecodeAuthorizationMessageResponse = exports.DecodeAuthorizationMessageResponse || (exports.DecodeAuthorizationMessageResponse = {}));

            class InvalidAuthorizationMessageException extends STSServiceException_1.STSServiceException {
                constructor(opts) {
                    super({
                        name: "InvalidAuthorizationMessageException",
                        $fault: "client",
                        ...opts,
                    });
                    this.name = "InvalidAuthorizationMessageException";
                    this.$fault = "client";
                    Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
                }
            }

            exports.InvalidAuthorizationMessageException = InvalidAuthorizationMessageException;
            var GetAccessKeyInfoRequest;
            (function (GetAccessKeyInfoRequest) {
                GetAccessKeyInfoRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetAccessKeyInfoRequest = exports.GetAccessKeyInfoRequest || (exports.GetAccessKeyInfoRequest = {}));
            var GetAccessKeyInfoResponse;
            (function (GetAccessKeyInfoResponse) {
                GetAccessKeyInfoResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetAccessKeyInfoResponse = exports.GetAccessKeyInfoResponse || (exports.GetAccessKeyInfoResponse = {}));
            var GetCallerIdentityRequest;
            (function (GetCallerIdentityRequest) {
                GetCallerIdentityRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetCallerIdentityRequest = exports.GetCallerIdentityRequest || (exports.GetCallerIdentityRequest = {}));
            var GetCallerIdentityResponse;
            (function (GetCallerIdentityResponse) {
                GetCallerIdentityResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetCallerIdentityResponse = exports.GetCallerIdentityResponse || (exports.GetCallerIdentityResponse = {}));
            var GetFederationTokenRequest;
            (function (GetFederationTokenRequest) {
                GetFederationTokenRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetFederationTokenRequest = exports.GetFederationTokenRequest || (exports.GetFederationTokenRequest = {}));
            var FederatedUser;
            (function (FederatedUser) {
                FederatedUser.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(FederatedUser = exports.FederatedUser || (exports.FederatedUser = {}));
            var GetFederationTokenResponse;
            (function (GetFederationTokenResponse) {
                GetFederationTokenResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetFederationTokenResponse = exports.GetFederationTokenResponse || (exports.GetFederationTokenResponse = {}));
            var GetSessionTokenRequest;
            (function (GetSessionTokenRequest) {
                GetSessionTokenRequest.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetSessionTokenRequest = exports.GetSessionTokenRequest || (exports.GetSessionTokenRequest = {}));
            var GetSessionTokenResponse;
            (function (GetSessionTokenResponse) {
                GetSessionTokenResponse.filterSensitiveLog = (obj) => ({
                    ...obj,
                });
            })(GetSessionTokenResponse = exports.GetSessionTokenResponse || (exports.GetSessionTokenResponse = {}));


            /***/
        }),
        /* 576 */,
        /* 577 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SendRawEmailCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SendRawEmailCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SendRawEmailCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SendRawEmailRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SendRawEmailResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySendRawEmailCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySendRawEmailCommand)(output, context);
                }
            }

            exports.SendRawEmailCommand = SendRawEmailCommand;


            /***/
        }),
        /* 578 */,
        /* 579 */,
        /* 580 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const packageInfo = __webpack_require__(786);
            const EventEmitter = __webpack_require__(614).EventEmitter;
            const net = __webpack_require__(631);
            const tls = __webpack_require__(16);
            const os = __webpack_require__(87);
            const crypto = __webpack_require__(417);
            const DataStream = __webpack_require__(300);
            const PassThrough = __webpack_require__(413).PassThrough;
            const shared = __webpack_require__(190);

// default timeout values in ms
            const CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established
            const SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client
            const GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved

            /**
             * Generates a SMTP connection object
             *
             * Optional options object takes the following possible properties:
             *
             *  * **port** - is the port to connect to (defaults to 587 or 465)
             *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')
             *  * **secure** - use SSL
             *  * **ignoreTLS** - ignore server support for STARTTLS
             *  * **requireTLS** - forces the client to use STARTTLS
             *  * **name** - the name of the client server
             *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)
             *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)
             *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish
             *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)
             *  * **lmtp** - if true, uses LMTP instead of SMTP protocol
             *  * **logger** - bunyan compatible logger interface
             *  * **debug** - if true pass SMTP traffic to the logger
             *  * **tls** - options for createCredentials
             *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)
             *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls
             *
             * @constructor
             * @namespace SMTP Client module
             * @param {Object} [options] Option properties
             */
            class SMTPConnection extends EventEmitter {
                constructor(options) {
                    super(options);

                    this.id = crypto.randomBytes(8).toString('base64').replace(/\W/g, '');
                    this.stage = 'init';

                    this.options = options || {};

                    this.secureConnection = !!this.options.secure;
                    this.alreadySecured = !!this.options.secured;

                    this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
                    this.host = this.options.host || 'localhost';

                    if (typeof this.options.secure === 'undefined' && this.port === 465) {
                        // if secure option is not set but port is 465, then default to secure
                        this.secureConnection = true;
                    }

                    this.name = this.options.name || this._getHostname();

                    this.logger = shared.getLogger(this.options, {
                        component: this.options.component || 'smtp-connection',
                        sid: this.id
                    });

                    this.customAuth = new Map();
                    Object.keys(this.options.customAuth || {}).forEach(key => {
                        let mapKey = (key || '').toString().trim().toUpperCase();
                        if (!mapKey) {
                            return;
                        }
                        this.customAuth.set(mapKey, this.options.customAuth[key]);
                    });

                    /**
                     * Expose version nr, just for the reference
                     * @type {String}
                     */
                    this.version = packageInfo.version;

                    /**
                     * If true, then the user is authenticated
                     * @type {Boolean}
                     */
                    this.authenticated = false;

                    /**
                     * If set to true, this instance is no longer active
                     * @private
                     */
                    this.destroyed = false;

                    /**
                     * Defines if the current connection is secure or not. If not,
                     * STARTTLS can be used if available
                     * @private
                     */
                    this.secure = !!this.secureConnection;

                    /**
                     * Store incomplete messages coming from the server
                     * @private
                     */
                    this._remainder = '';

                    /**
                     * Unprocessed responses from the server
                     * @type {Array}
                     */
                    this._responseQueue = [];

                    this.lastServerResponse = false;

                    /**
                     * The socket connecting to the server
                     * @publick
                     */
                    this._socket = false;

                    /**
                     * Lists supported auth mechanisms
                     * @private
                     */
                    this._supportedAuth = [];

                    /**
                     * Set to true, if EHLO response includes "AUTH".
                     * If false then authentication is not tried
                     */
                    this.allowsAuth = false;

                    /**
                     * Includes current envelope (from, to)
                     * @private
                     */
                    this._envelope = false;

                    /**
                     * Lists supported extensions
                     * @private
                     */
                    this._supportedExtensions = [];

                    /**
                     * Defines the maximum allowed size for a single message
                     * @private
                     */
                    this._maxAllowedSize = 0;

                    /**
                     * Function queue to run if a data chunk comes from the server
                     * @private
                     */
                    this._responseActions = [];
                    this._recipientQueue = [];

                    /**
                     * Timeout variable for waiting the greeting
                     * @private
                     */
                    this._greetingTimeout = false;

                    /**
                     * Timeout variable for waiting the connection to start
                     * @private
                     */
                    this._connectionTimeout = false;

                    /**
                     * If the socket is deemed already closed
                     * @private
                     */
                    this._destroyed = false;

                    /**
                     * If the socket is already being closed
                     * @private
                     */
                    this._closing = false;

                    /**
                     * Callbacks for socket's listeners
                     */
                    this._onSocketData = chunk => this._onData(chunk);
                    this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');
                    this._onSocketClose = () => this._onClose();
                    this._onSocketEnd = () => this._onEnd();
                    this._onSocketTimeout = () => this._onTimeout();
                }

                /**
                 * Creates a connection to a SMTP server and sets up connection
                 * listener
                 */
                connect(connectCallback) {
                    if (typeof connectCallback === 'function') {
                        this.once('connect', () => {
                            this.logger.debug(
                                {
                                    tnx: 'smtp'
                                },
                                'SMTP handshake finished'
                            );
                            connectCallback();
                        });

                        const isDestroyedMessage = this._isDestroyedMessage('connect');
                        if (isDestroyedMessage) {
                            return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));
                        }
                    }

                    let opts = {
                        port: this.port,
                        host: this.host
                    };

                    if (this.options.localAddress) {
                        opts.localAddress = this.options.localAddress;
                    }

                    let setupConnectionHandlers = () => {
                        this._connectionTimeout = setTimeout(() => {
                            this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');
                        }, this.options.connectionTimeout || CONNECTION_TIMEOUT);

                        this._socket.on('error', this._onSocketError);
                    };

                    if (this.options.connection) {
                        // connection is already opened
                        this._socket = this.options.connection;
                        if (this.secureConnection && !this.alreadySecured) {
                            setImmediate(() =>
                                this._upgradeConnection(err => {
                                    if (err) {
                                        this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');
                                        return;
                                    }
                                    this._onConnect();
                                })
                            );
                        } else {
                            setImmediate(() => this._onConnect());
                        }
                        return;
                    } else if (this.options.socket) {
                        // socket object is set up but not yet connected
                        this._socket = this.options.socket;
                        return shared.resolveHostname(opts, (err, resolved) => {
                            if (err) {
                                return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));
                            }
                            this.logger.debug(
                                {
                                    tnx: 'dns',
                                    source: opts.host,
                                    resolved: resolved.host,
                                    cached: !!resolved.cached
                                },
                                'Resolved %s as %s [cache %s]',
                                opts.host,
                                resolved.host,
                                resolved.cached ? 'hit' : 'miss'
                            );
                            Object.keys(resolved).forEach(key => {
                                if (key.charAt(0) !== '_' && resolved[key]) {
                                    opts[key] = resolved[key];
                                }
                            });
                            try {
                                this._socket.connect(this.port, this.host, () => {
                                    this._socket.setKeepAlive(true);
                                    this._onConnect();
                                });
                                setupConnectionHandlers();
                            } catch (E) {
                                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));
                            }
                        });
                    } else if (this.secureConnection) {
                        // connect using tls
                        if (this.options.tls) {
                            Object.keys(this.options.tls).forEach(key => {
                                opts[key] = this.options.tls[key];
                            });
                        }
                        return shared.resolveHostname(opts, (err, resolved) => {
                            if (err) {
                                return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));
                            }
                            this.logger.debug(
                                {
                                    tnx: 'dns',
                                    source: opts.host,
                                    resolved: resolved.host,
                                    cached: !!resolved.cached
                                },
                                'Resolved %s as %s [cache %s]',
                                opts.host,
                                resolved.host,
                                resolved.cached ? 'hit' : 'miss'
                            );
                            Object.keys(resolved).forEach(key => {
                                if (key.charAt(0) !== '_' && resolved[key]) {
                                    opts[key] = resolved[key];
                                }
                            });
                            try {
                                this._socket = tls.connect(opts, () => {
                                    this._socket.setKeepAlive(true);
                                    this._onConnect();
                                });
                                setupConnectionHandlers();
                            } catch (E) {
                                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));
                            }
                        });
                    } else {
                        // connect using plaintext
                        return shared.resolveHostname(opts, (err, resolved) => {
                            if (err) {
                                return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));
                            }
                            this.logger.debug(
                                {
                                    tnx: 'dns',
                                    source: opts.host,
                                    resolved: resolved.host,
                                    cached: !!resolved.cached
                                },
                                'Resolved %s as %s [cache %s]',
                                opts.host,
                                resolved.host,
                                resolved.cached ? 'hit' : 'miss'
                            );
                            Object.keys(resolved).forEach(key => {
                                if (key.charAt(0) !== '_' && resolved[key]) {
                                    opts[key] = resolved[key];
                                }
                            });
                            try {
                                this._socket = net.connect(opts, () => {
                                    this._socket.setKeepAlive(true);
                                    this._onConnect();
                                });
                                setupConnectionHandlers();
                            } catch (E) {
                                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));
                            }
                        });
                    }
                }

                /**
                 * Sends QUIT
                 */
                quit() {
                    this._sendCommand('QUIT');
                    this._responseActions.push(this.close);
                }

                /**
                 * Closes the connection to the server
                 */
                close() {
                    clearTimeout(this._connectionTimeout);
                    clearTimeout(this._greetingTimeout);
                    this._responseActions = [];

                    // allow to run this function only once
                    if (this._closing) {
                        return;
                    }
                    this._closing = true;

                    let closeMethod = 'end';

                    if (this.stage === 'init') {
                        // Close the socket immediately when connection timed out
                        closeMethod = 'destroy';
                    }

                    this.logger.debug(
                        {
                            tnx: 'smtp'
                        },
                        'Closing connection to the server using "%s"',
                        closeMethod
                    );

                    let socket = (this._socket && this._socket.socket) || this._socket;

                    if (socket && !socket.destroyed) {
                        try {
                            this._socket[closeMethod]();
                        } catch (E) {
                            // just ignore
                        }
                    }

                    this._destroy();
                }

                /**
                 * Authenticate user
                 */
                login(authData, callback) {
                    const isDestroyedMessage = this._isDestroyedMessage('login');
                    if (isDestroyedMessage) {
                        return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));
                    }

                    this._auth = authData || {};
                    // Select SASL authentication method
                    this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;

                    if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
                        this._authMethod = 'XOAUTH2';
                    } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {
                        // use first supported
                        this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();
                    }

                    if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
                        if (this._auth.user && this._auth.pass) {
                            this._auth.credentials = {
                                user: this._auth.user,
                                pass: this._auth.pass,
                                options: this._auth.options
                            };
                        } else {
                            return callback(this._formatError('Missing credentials for "' + this._authMethod + '"', 'EAUTH', false, 'API'));
                        }
                    }

                    if (this.customAuth.has(this._authMethod)) {
                        let handler = this.customAuth.get(this._authMethod);
                        let lastResponse;
                        let returned = false;

                        let resolve = () => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            this.logger.info(
                                {
                                    tnx: 'smtp',
                                    username: this._auth.user,
                                    action: 'authenticated',
                                    method: this._authMethod
                                },
                                'User %s authenticated',
                                JSON.stringify(this._auth.user)
                            );
                            this.authenticated = true;
                            callback(null, true);
                        };

                        let reject = err => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));
                        };

                        let handlerResponse = handler({
                            auth: this._auth,
                            method: this._authMethod,

                            extensions: [].concat(this._supportedExtensions),
                            authMethods: [].concat(this._supportedAuth),
                            maxAllowedSize: this._maxAllowedSize || false,

                            sendCommand: (cmd, done) => {
                                let promise;

                                if (!done) {
                                    promise = new Promise((resolve, reject) => {
                                        done = shared.callbackPromise(resolve, reject);
                                    });
                                }

                                this._responseActions.push(str => {
                                    lastResponse = str;

                                    let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
                                    let data = {
                                        command: cmd,
                                        response: str
                                    };
                                    if (codes) {
                                        data.status = Number(codes[1]) || 0;
                                        if (codes[2]) {
                                            data.code = codes[2];
                                        }
                                        data.text = str.substr(codes[0].length);
                                    } else {
                                        data.text = str;
                                        data.status = 0; // just in case we need to perform numeric comparisons
                                    }
                                    done(null, data);
                                });
                                setImmediate(() => this._sendCommand(cmd));

                                return promise;
                            },

                            resolve,
                            reject
                        });

                        if (handlerResponse && typeof handlerResponse.catch === 'function') {
                            // a promise was returned
                            handlerResponse.then(resolve).catch(reject);
                        }

                        return;
                    }

                    switch (this._authMethod) {
                        case 'XOAUTH2':
                            this._handleXOauth2Token(false, callback);
                            return;
                        case 'LOGIN':
                            this._responseActions.push(str => {
                                this._actionAUTH_LOGIN_USER(str, callback);
                            });
                            this._sendCommand('AUTH LOGIN');
                            return;
                        case 'PLAIN':
                            this._responseActions.push(str => {
                                this._actionAUTHComplete(str, callback);
                            });
                            this._sendCommand(
                                'AUTH PLAIN ' +
                                Buffer.from(
                                    //this._auth.user+'\u0000'+
                                    '\u0000' + // skip authorization identity as it causes problems with some servers
                                    this._auth.credentials.user +
                                    '\u0000' +
                                    this._auth.credentials.pass,
                                    'utf-8'
                                ).toString('base64'),
                                // log entry without passwords
                                'AUTH PLAIN ' +
                                Buffer.from(
                                    //this._auth.user+'\u0000'+
                                    '\u0000' + // skip authorization identity as it causes problems with some servers
                                    this._auth.credentials.user +
                                    '\u0000' +
                                    '/* secret */',
                                    'utf-8'
                                ).toString('base64')
                            );
                            return;
                        case 'CRAM-MD5':
                            this._responseActions.push(str => {
                                this._actionAUTH_CRAM_MD5(str, callback);
                            });
                            this._sendCommand('AUTH CRAM-MD5');
                            return;
                    }

                    return callback(this._formatError('Unknown authentication method "' + this._authMethod + '"', 'EAUTH', false, 'API'));
                }

                /**
                 * Sends a message
                 *
                 * @param {Object} envelope Envelope object, {from: addr, to: [addr]}
                 * @param {Object} message String, Buffer or a Stream
                 * @param {Function} callback Callback to return once sending is completed
                 */
                send(envelope, message, done) {
                    if (!message) {
                        return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));
                    }

                    const isDestroyedMessage = this._isDestroyedMessage('send message');
                    if (isDestroyedMessage) {
                        return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));
                    }

                    // reject larger messages than allowed
                    if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
                        return setImmediate(() => {
                            done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));
                        });
                    }

                    // ensure that callback is only called once
                    let returned = false;
                    let callback = function () {
                        if (returned) {
                            return;
                        }
                        returned = true;

                        done(...arguments);
                    };

                    if (typeof message.on === 'function') {
                        message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));
                    }

                    let startTime = Date.now();
                    this._setEnvelope(envelope, (err, info) => {
                        if (err) {
                            return callback(err);
                        }
                        let envelopeTime = Date.now();
                        let stream = this._createSendStream((err, str) => {
                            if (err) {
                                return callback(err);
                            }

                            info.envelopeTime = envelopeTime - startTime;
                            info.messageTime = Date.now() - envelopeTime;
                            info.messageSize = stream.outByteCount;
                            info.response = str;

                            return callback(null, info);
                        });
                        if (typeof message.pipe === 'function') {
                            message.pipe(stream);
                        } else {
                            stream.write(message);
                            stream.end();
                        }
                    });
                }

                /**
                 * Resets connection state
                 *
                 * @param {Function} callback Callback to return once connection is reset
                 */
                reset(callback) {
                    this._sendCommand('RSET');
                    this._responseActions.push(str => {
                        if (str.charAt(0) !== '2') {
                            return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));
                        }
                        this._envelope = false;
                        return callback(null, true);
                    });
                }

                /**
                 * Connection listener that is run when the connection to
                 * the server is opened
                 *
                 * @event
                 */
                _onConnect() {
                    clearTimeout(this._connectionTimeout);

                    this.logger.info(
                        {
                            tnx: 'network',
                            localAddress: this._socket.localAddress,
                            localPort: this._socket.localPort,
                            remoteAddress: this._socket.remoteAddress,
                            remotePort: this._socket.remotePort
                        },
                        '%s established to %s:%s',
                        this.secure ? 'Secure connection' : 'Connection',
                        this._socket.remoteAddress,
                        this._socket.remotePort
                    );

                    if (this._destroyed) {
                        // Connection was established after we already had canceled it
                        this.close();
                        return;
                    }

                    this.stage = 'connected';

                    // clear existing listeners for the socket
                    this._socket.removeListener('data', this._onSocketData);
                    this._socket.removeListener('timeout', this._onSocketTimeout);
                    this._socket.removeListener('close', this._onSocketClose);
                    this._socket.removeListener('end', this._onSocketEnd);

                    this._socket.on('data', this._onSocketData);
                    this._socket.once('close', this._onSocketClose);
                    this._socket.once('end', this._onSocketEnd);

                    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
                    this._socket.on('timeout', this._onSocketTimeout);

                    this._greetingTimeout = setTimeout(() => {
                        // if still waiting for greeting, give up
                        if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
                            this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');
                        }
                    }, this.options.greetingTimeout || GREETING_TIMEOUT);

                    this._responseActions.push(this._actionGreeting);

                    // we have a 'data' listener set up so resume socket if it was paused
                    this._socket.resume();
                }

                /**
                 * 'data' listener for data coming from the server
                 *
                 * @event
                 * @param {Buffer} chunk Data chunk coming from the server
                 */
                _onData(chunk) {
                    if (this._destroyed || !chunk || !chunk.length) {
                        return;
                    }

                    let data = (chunk || '').toString('binary');
                    let lines = (this._remainder + data).split(/\r?\n/);
                    let lastline;

                    this._remainder = lines.pop();

                    for (let i = 0, len = lines.length; i < len; i++) {
                        if (this._responseQueue.length) {
                            lastline = this._responseQueue[this._responseQueue.length - 1];
                            if (/^\d+-/.test(lastline.split('\n').pop())) {
                                this._responseQueue[this._responseQueue.length - 1] += '\n' + lines[i];
                                continue;
                            }
                        }
                        this._responseQueue.push(lines[i]);
                    }

                    if (this._responseQueue.length) {
                        lastline = this._responseQueue[this._responseQueue.length - 1];
                        if (/^\d+-/.test(lastline.split('\n').pop())) {
                            return;
                        }
                    }

                    this._processResponse();
                }

                /**
                 * 'error' listener for the socket
                 *
                 * @event
                 * @param {Error} err Error object
                 * @param {String} type Error name
                 */
                _onError(err, type, data, command) {
                    clearTimeout(this._connectionTimeout);
                    clearTimeout(this._greetingTimeout);

                    if (this._destroyed) {
                        // just ignore, already closed
                        // this might happen when a socket is canceled because of reached timeout
                        // but the socket timeout error itself receives only after
                        return;
                    }

                    err = this._formatError(err, type, data, command);

                    this.logger.error(data, err.message);

                    this.emit('error', err);
                    this.close();
                }

                _formatError(message, type, response, command) {
                    let err;

                    if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
                        err = message;
                    } else {
                        err = new Error(message);
                    }

                    if (type && type !== 'Error') {
                        err.code = type;
                    }

                    if (response) {
                        err.response = response;
                        err.message += ': ' + response;
                    }

                    let responseCode = (typeof response === 'string' && Number((response.match(/^\d+/) || [])[0])) || false;
                    if (responseCode) {
                        err.responseCode = responseCode;
                    }

                    if (command) {
                        err.command = command;
                    }

                    return err;
                }

                /**
                 * 'close' listener for the socket
                 *
                 * @event
                 */
                _onClose() {
                    this.logger.info(
                        {
                            tnx: 'network'
                        },
                        'Connection closed'
                    );

                    if (this.upgrading && !this._destroyed) {
                        return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');
                    } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {
                        return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');
                    }

                    this._destroy();
                }

                /**
                 * 'end' listener for the socket
                 *
                 * @event
                 */
                _onEnd() {
                    if (this._socket && !this._socket.destroyed) {
                        this._socket.destroy();
                    }
                }

                /**
                 * 'timeout' listener for the socket
                 *
                 * @event
                 */
                _onTimeout() {
                    return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');
                }

                /**
                 * Destroys the client, emits 'end'
                 */
                _destroy() {
                    if (this._destroyed) {
                        return;
                    }
                    this._destroyed = true;
                    this.emit('end');
                }

                /**
                 * Upgrades the connection to TLS
                 *
                 * @param {Function} callback Callback function to run when the connection
                 *        has been secured
                 */
                _upgradeConnection(callback) {
                    // do not remove all listeners or it breaks node v0.10 as there's
                    // apparently a 'finish' event set that would be cleared as well

                    // we can safely keep 'error', 'end', 'close' etc. events
                    this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards
                    this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object

                    let socketPlain = this._socket;
                    let opts = {
                        socket: this._socket,
                        host: this.host
                    };

                    Object.keys(this.options.tls || {}).forEach(key => {
                        opts[key] = this.options.tls[key];
                    });

                    this.upgrading = true;
                    // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch
                    try {
                        this._socket = tls.connect(opts, () => {
                            this.secure = true;
                            this.upgrading = false;
                            this._socket.on('data', this._onSocketData);

                            socketPlain.removeListener('close', this._onSocketClose);
                            socketPlain.removeListener('end', this._onSocketEnd);

                            return callback(null, true);
                        });
                    } catch (err) {
                        return callback(err);
                    }

                    this._socket.on('error', this._onSocketError);
                    this._socket.once('close', this._onSocketClose);
                    this._socket.once('end', this._onSocketEnd);

                    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.
                    this._socket.on('timeout', this._onSocketTimeout);

                    // resume in case the socket was paused
                    socketPlain.resume();
                }

                /**
                 * Processes queued responses from the server
                 *
                 * @param {Boolean} force If true, ignores _processing flag
                 */
                _processResponse() {
                    if (!this._responseQueue.length) {
                        return false;
                    }

                    let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());

                    if (/^\d+-/.test(str.split('\n').pop())) {
                        // keep waiting for the final part of multiline response
                        return;
                    }

                    if (this.options.debug || this.options.transactionLog) {
                        this.logger.debug(
                            {
                                tnx: 'server'
                            },
                            str.replace(/\r?\n$/, '')
                        );
                    }

                    if (!str.trim()) {
                        // skip unexpected empty lines
                        setImmediate(() => this._processResponse(true));
                    }

                    let action = this._responseActions.shift();

                    if (typeof action === 'function') {
                        action.call(this, str);
                        setImmediate(() => this._processResponse(true));
                    } else {
                        return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');
                    }
                }

                /**
                 * Send a command to the server, append \r\n
                 *
                 * @param {String} str String to be sent to the server
                 * @param {String} logStr Optional string to be used for logging instead of the actual string
                 */
                _sendCommand(str, logStr) {
                    if (this._destroyed) {
                        // Connection already closed, can't send any more data
                        return;
                    }

                    if (this._socket.destroyed) {
                        return this.close();
                    }

                    if (this.options.debug || this.options.transactionLog) {
                        this.logger.debug(
                            {
                                tnx: 'client'
                            },
                            (logStr || str || '').toString().replace(/\r?\n$/, '')
                        );
                    }

                    this._socket.write(Buffer.from(str + '\r\n', 'utf-8'));
                }

                /**
                 * Initiates a new message by submitting envelope data, starting with
                 * MAIL FROM: command
                 *
                 * @param {Object} envelope Envelope object in the form of
                 *        {from:'...', to:['...']}
                 *        or
                 *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}
                 */
                _setEnvelope(envelope, callback) {
                    let args = [];
                    let useSmtpUtf8 = false;

                    this._envelope = envelope || {};
                    this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();

                    this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());

                    if (!this._envelope.to.length) {
                        return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));
                    }

                    if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
                        return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));
                    }

                    // check if the sender address uses only ASCII characters,
                    // otherwise require usage of SMTPUTF8 extension
                    if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
                        useSmtpUtf8 = true;
                    }

                    for (let i = 0, len = this._envelope.to.length; i < len; i++) {
                        if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
                            return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));
                        }

                        // check if the recipients addresses use only ASCII characters,
                        // otherwise require usage of SMTPUTF8 extension
                        if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
                            useSmtpUtf8 = true;
                        }
                    }

                    // clone the recipients array for latter manipulation
                    this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
                    this._envelope.rejected = [];
                    this._envelope.rejectedErrors = [];
                    this._envelope.accepted = [];

                    if (this._envelope.dsn) {
                        try {
                            this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
                        } catch (err) {
                            return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));
                        }
                    }

                    this._responseActions.push(str => {
                        this._actionMAIL(str, callback);
                    });

                    // If the server supports SMTPUTF8 and the envelope includes an internationalized
                    // email address then append SMTPUTF8 keyword to the MAIL FROM command
                    if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {
                        args.push('SMTPUTF8');
                        this._usingSmtpUtf8 = true;
                    }

                    // If the server supports 8BITMIME and the message might contain non-ascii bytes
                    // then append the 8BITMIME keyword to the MAIL FROM command
                    if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {
                        args.push('BODY=8BITMIME');
                        this._using8BitMime = true;
                    }

                    if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {
                        args.push('SIZE=' + this._envelope.size);
                    }

                    // If the server supports DSN and the envelope includes an DSN prop
                    // then append DSN params to the MAIL FROM command
                    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {
                        if (this._envelope.dsn.ret) {
                            args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));
                        }
                        if (this._envelope.dsn.envid) {
                            args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));
                        }
                    }

                    this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));
                }

                _setDsnEnvelope(params) {
                    let ret = (params.ret || params.return || '').toString().toUpperCase() || null;
                    if (ret) {
                        switch (ret) {
                            case 'HDRS':
                            case 'HEADERS':
                                ret = 'HDRS';
                                break;
                            case 'FULL':
                            case 'BODY':
                                ret = 'FULL';
                                break;
                        }
                    }

                    if (ret && !['FULL', 'HDRS'].includes(ret)) {
                        throw new Error('ret: ' + JSON.stringify(ret));
                    }

                    let envid = (params.envid || params.id || '').toString() || null;

                    let notify = params.notify || null;
                    if (notify) {
                        if (typeof notify === 'string') {
                            notify = notify.split(',');
                        }
                        notify = notify.map(n => n.trim().toUpperCase());
                        let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];
                        let invaliNotify = notify.filter(n => !validNotify.includes(n));
                        if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {
                            throw new Error('notify: ' + JSON.stringify(notify.join(',')));
                        }
                        notify = notify.join(',');
                    }

                    let orcpt = (params.recipient || params.orcpt || '').toString() || null;
                    if (orcpt && orcpt.indexOf(';') < 0) {
                        orcpt = 'rfc822;' + orcpt;
                    }

                    return {
                        ret,
                        envid,
                        notify,
                        orcpt
                    };
                }

                _getDsnRcptToArgs() {
                    let args = [];
                    // If the server supports DSN and the envelope includes an DSN prop
                    // then append DSN params to the RCPT TO command
                    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {
                        if (this._envelope.dsn.notify) {
                            args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));
                        }
                        if (this._envelope.dsn.orcpt) {
                            args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));
                        }
                    }
                    return args.length ? ' ' + args.join(' ') : '';
                }

                _createSendStream(callback) {
                    let dataStream = new DataStream();
                    let logStream;

                    if (this.options.lmtp) {
                        this._envelope.accepted.forEach((recipient, i) => {
                            let final = i === this._envelope.accepted.length - 1;
                            this._responseActions.push(str => {
                                this._actionLMTPStream(recipient, final, str, callback);
                            });
                        });
                    } else {
                        this._responseActions.push(str => {
                            this._actionSMTPStream(str, callback);
                        });
                    }

                    dataStream.pipe(this._socket, {
                        end: false
                    });

                    if (this.options.debug) {
                        logStream = new PassThrough();
                        logStream.on('readable', () => {
                            let chunk;
                            while ((chunk = logStream.read())) {
                                this.logger.debug(
                                    {
                                        tnx: 'message'
                                    },
                                    chunk.toString('binary').replace(/\r?\n$/, '')
                                );
                            }
                        });
                        dataStream.pipe(logStream);
                    }

                    dataStream.once('end', () => {
                        this.logger.info(
                            {
                                tnx: 'message',
                                inByteCount: dataStream.inByteCount,
                                outByteCount: dataStream.outByteCount
                            },
                            '<%s bytes encoded mime message (source size %s bytes)>',
                            dataStream.outByteCount,
                            dataStream.inByteCount
                        );
                    });

                    return dataStream;
                }

                /** ACTIONS **/

                /**
                 * Will be run after the connection is created and the server sends
                 * a greeting. If the incoming message starts with 220 initiate
                 * SMTP session by sending EHLO command
                 *
                 * @param {String} str Message from the server
                 */
                _actionGreeting(str) {
                    clearTimeout(this._greetingTimeout);

                    if (str.substr(0, 3) !== '220') {
                        this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');
                        return;
                    }

                    if (this.options.lmtp) {
                        this._responseActions.push(this._actionLHLO);
                        this._sendCommand('LHLO ' + this.name);
                    } else {
                        this._responseActions.push(this._actionEHLO);
                        this._sendCommand('EHLO ' + this.name);
                    }
                }

                /**
                 * Handles server response for LHLO command. If it yielded in
                 * error, emit 'error', otherwise treat this as an EHLO response
                 *
                 * @param {String} str Message from the server
                 */
                _actionLHLO(str) {
                    if (str.charAt(0) !== '2') {
                        this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');
                        return;
                    }

                    this._actionEHLO(str);
                }

                /**
                 * Handles server response for EHLO command. If it yielded in
                 * error, try HELO instead, otherwise initiate TLS negotiation
                 * if STARTTLS is supported by the server or move into the
                 * authentication phase.
                 *
                 * @param {String} str Message from the server
                 */
                _actionEHLO(str) {
                    let match;

                    if (str.substr(0, 3) === '421') {
                        this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');
                        return;
                    }

                    if (str.charAt(0) !== '2') {
                        if (this.options.requireTLS) {
                            this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');
                            return;
                        }

                        // Try HELO instead
                        this._responseActions.push(this._actionHELO);
                        this._sendCommand('HELO ' + this.name);
                        return;
                    }

                    // Detect if the server supports STARTTLS
                    if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
                        this._sendCommand('STARTTLS');
                        this._responseActions.push(this._actionSTARTTLS);
                        return;
                    }

                    // Detect if the server supports SMTPUTF8
                    if (/[ -]SMTPUTF8\b/im.test(str)) {
                        this._supportedExtensions.push('SMTPUTF8');
                    }

                    // Detect if the server supports DSN
                    if (/[ -]DSN\b/im.test(str)) {
                        this._supportedExtensions.push('DSN');
                    }

                    // Detect if the server supports 8BITMIME
                    if (/[ -]8BITMIME\b/im.test(str)) {
                        this._supportedExtensions.push('8BITMIME');
                    }

                    // Detect if the server supports PIPELINING
                    if (/[ -]PIPELINING\b/im.test(str)) {
                        this._supportedExtensions.push('PIPELINING');
                    }

                    // Detect if the server supports AUTH
                    if (/[ -]AUTH\b/i.test(str)) {
                        this.allowsAuth = true;
                    }

                    // Detect if the server supports PLAIN auth
                    if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
                        this._supportedAuth.push('PLAIN');
                    }

                    // Detect if the server supports LOGIN auth
                    if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
                        this._supportedAuth.push('LOGIN');
                    }

                    // Detect if the server supports CRAM-MD5 auth
                    if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
                        this._supportedAuth.push('CRAM-MD5');
                    }

                    // Detect if the server supports XOAUTH2 auth
                    if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
                        this._supportedAuth.push('XOAUTH2');
                    }

                    // Detect if the server supports SIZE extensions (and the max allowed size)
                    if ((match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im))) {
                        this._supportedExtensions.push('SIZE');
                        this._maxAllowedSize = Number(match[1]) || 0;
                    }

                    this.emit('connect');
                }

                /**
                 * Handles server response for HELO command. If it yielded in
                 * error, emit 'error', otherwise move into the authentication phase.
                 *
                 * @param {String} str Message from the server
                 */
                _actionHELO(str) {
                    if (str.charAt(0) !== '2') {
                        this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');
                        return;
                    }

                    // assume that authentication is enabled (most probably is not though)
                    this.allowsAuth = true;

                    this.emit('connect');
                }

                /**
                 * Handles server response for STARTTLS command. If there's an error
                 * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
                 * succeedes restart the EHLO
                 *
                 * @param {String} str Message from the server
                 */
                _actionSTARTTLS(str) {
                    if (str.charAt(0) !== '2') {
                        if (this.options.opportunisticTLS) {
                            this.logger.info(
                                {
                                    tnx: 'smtp'
                                },
                                'Failed STARTTLS upgrade, continuing unencrypted'
                            );
                            return this.emit('connect');
                        }
                        this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');
                        return;
                    }

                    this._upgradeConnection((err, secured) => {
                        if (err) {
                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');
                            return;
                        }

                        this.logger.info(
                            {
                                tnx: 'smtp'
                            },
                            'Connection upgraded with STARTTLS'
                        );

                        if (secured) {
                            // restart session
                            if (this.options.lmtp) {
                                this._responseActions.push(this._actionLHLO);
                                this._sendCommand('LHLO ' + this.name);
                            } else {
                                this._responseActions.push(this._actionEHLO);
                                this._sendCommand('EHLO ' + this.name);
                            }
                        } else {
                            this.emit('connect');
                        }
                    });
                }

                /**
                 * Handle the response for AUTH LOGIN command. We are expecting
                 * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as
                 * response needs to be base64 encoded username. We do not need
                 * exact match but settle with 334 response in general as some
                 * hosts invalidly use a longer message than VXNlcm5hbWU6
                 *
                 * @param {String} str Message from the server
                 */
                _actionAUTH_LOGIN_USER(str, callback) {
                    if (!/^334[ -]/.test(str)) {
                        // expecting '334 VXNlcm5hbWU6'
                        callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', 'EAUTH', str, 'AUTH LOGIN'));
                        return;
                    }

                    this._responseActions.push(str => {
                        this._actionAUTH_LOGIN_PASS(str, callback);
                    });

                    this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));
                }

                /**
                 * Handle the response for AUTH CRAM-MD5 command. We are expecting
                 * '334 <challenge string>'. Data to be sent as response needs to be
                 * base64 decoded challenge string, MD5 hashed using the password as
                 * a HMAC key, prefixed by the username and a space, and finally all
                 * base64 encoded again.
                 *
                 * @param {String} str Message from the server
                 */
                _actionAUTH_CRAM_MD5(str, callback) {
                    let challengeMatch = str.match(/^334\s+(.+)$/);
                    let challengeString = '';

                    if (!challengeMatch) {
                        return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));
                    } else {
                        challengeString = challengeMatch[1];
                    }

                    // Decode from base64
                    let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),
                        hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);

                    hmacMD5.update(base64decoded);

                    let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');

                    this._responseActions.push(str => {
                        this._actionAUTH_CRAM_MD5_PASS(str, callback);
                    });

                    this._sendCommand(
                        Buffer.from(prepended).toString('base64'),
                        // hidden hash for logs
                        Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64')
                    );
                }

                /**
                 * Handles the response to CRAM-MD5 authentication, if there's no error,
                 * the user can be considered logged in. Start waiting for a message to send
                 *
                 * @param {String} str Message from the server
                 */
                _actionAUTH_CRAM_MD5_PASS(str, callback) {
                    if (!str.match(/^235\s+/)) {
                        return callback(this._formatError('Invalid login sequence while waiting for "235"', 'EAUTH', str, 'AUTH CRAM-MD5'));
                    }

                    this.logger.info(
                        {
                            tnx: 'smtp',
                            username: this._auth.user,
                            action: 'authenticated',
                            method: this._authMethod
                        },
                        'User %s authenticated',
                        JSON.stringify(this._auth.user)
                    );
                    this.authenticated = true;
                    callback(null, true);
                }

                /**
                 * Handle the response for AUTH LOGIN command. We are expecting
                 * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as
                 * response needs to be base64 encoded password.
                 *
                 * @param {String} str Message from the server
                 */
                _actionAUTH_LOGIN_PASS(str, callback) {
                    if (!/^334[ -]/.test(str)) {
                        // expecting '334 UGFzc3dvcmQ6'
                        return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', 'EAUTH', str, 'AUTH LOGIN'));
                    }

                    this._responseActions.push(str => {
                        this._actionAUTHComplete(str, callback);
                    });

                    this._sendCommand(
                        Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),
                        // Hidden pass for logs
                        Buffer.from('/* secret */', 'utf-8').toString('base64')
                    );
                }

                /**
                 * Handles the response for authentication, if there's no error,
                 * the user can be considered logged in. Start waiting for a message to send
                 *
                 * @param {String} str Message from the server
                 */
                _actionAUTHComplete(str, isRetry, callback) {
                    if (!callback && typeof isRetry === 'function') {
                        callback = isRetry;
                        isRetry = false;
                    }

                    if (str.substr(0, 3) === '334') {
                        this._responseActions.push(str => {
                            if (isRetry || this._authMethod !== 'XOAUTH2') {
                                this._actionAUTHComplete(str, true, callback);
                            } else {
                                // fetch a new OAuth2 access token
                                setImmediate(() => this._handleXOauth2Token(true, callback));
                            }
                        });
                        this._sendCommand('');
                        return;
                    }

                    if (str.charAt(0) !== '2') {
                        this.logger.info(
                            {
                                tnx: 'smtp',
                                username: this._auth.user,
                                action: 'authfail',
                                method: this._authMethod
                            },
                            'User %s failed to authenticate',
                            JSON.stringify(this._auth.user)
                        );
                        return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));
                    }

                    this.logger.info(
                        {
                            tnx: 'smtp',
                            username: this._auth.user,
                            action: 'authenticated',
                            method: this._authMethod
                        },
                        'User %s authenticated',
                        JSON.stringify(this._auth.user)
                    );
                    this.authenticated = true;
                    callback(null, true);
                }

                /**
                 * Handle response for a MAIL FROM: command
                 *
                 * @param {String} str Message from the server
                 */
                _actionMAIL(str, callback) {
                    let message, curRecipient;
                    if (Number(str.charAt(0)) !== 2) {
                        if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
                            message = 'Internationalized mailbox name not allowed';
                        } else {
                            message = 'Mail command failed';
                        }
                        return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));
                    }

                    if (!this._envelope.rcptQueue.length) {
                        return callback(this._formatError('Can\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));
                    } else {
                        this._recipientQueue = [];

                        if (this._supportedExtensions.includes('PIPELINING')) {
                            while (this._envelope.rcptQueue.length) {
                                curRecipient = this._envelope.rcptQueue.shift();
                                this._recipientQueue.push(curRecipient);
                                this._responseActions.push(str => {
                                    this._actionRCPT(str, callback);
                                });
                                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());
                            }
                        } else {
                            curRecipient = this._envelope.rcptQueue.shift();
                            this._recipientQueue.push(curRecipient);
                            this._responseActions.push(str => {
                                this._actionRCPT(str, callback);
                            });
                            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());
                        }
                    }
                }

                /**
                 * Handle response for a RCPT TO: command
                 *
                 * @param {String} str Message from the server
                 */
                _actionRCPT(str, callback) {
                    let message,
                        err,
                        curRecipient = this._recipientQueue.shift();
                    if (Number(str.charAt(0)) !== 2) {
                        // this is a soft error
                        if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
                            message = 'Internationalized mailbox name not allowed';
                        } else {
                            message = 'Recipient command failed';
                        }
                        this._envelope.rejected.push(curRecipient);
                        // store error for the failed recipient
                        err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');
                        err.recipient = curRecipient;
                        this._envelope.rejectedErrors.push(err);
                    } else {
                        this._envelope.accepted.push(curRecipient);
                    }

                    if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
                        if (this._envelope.rejected.length < this._envelope.to.length) {
                            this._responseActions.push(str => {
                                this._actionDATA(str, callback);
                            });
                            this._sendCommand('DATA');
                        } else {
                            err = this._formatError('Can\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');
                            err.rejected = this._envelope.rejected;
                            err.rejectedErrors = this._envelope.rejectedErrors;
                            return callback(err);
                        }
                    } else if (this._envelope.rcptQueue.length) {
                        curRecipient = this._envelope.rcptQueue.shift();
                        this._recipientQueue.push(curRecipient);
                        this._responseActions.push(str => {
                            this._actionRCPT(str, callback);
                        });
                        this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());
                    }
                }

                /**
                 * Handle response for a DATA command
                 *
                 * @param {String} str Message from the server
                 */
                _actionDATA(str, callback) {
                    // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24
                    // some servers might use 250 instead, so lets check for 2 or 3 as the first digit
                    if (!/^[23]/.test(str)) {
                        return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));
                    }

                    let response = {
                        accepted: this._envelope.accepted,
                        rejected: this._envelope.rejected
                    };

                    if (this._envelope.rejectedErrors.length) {
                        response.rejectedErrors = this._envelope.rejectedErrors;
                    }

                    callback(null, response);
                }

                /**
                 * Handle response for a DATA stream when using SMTP
                 * We expect a single response that defines if the sending succeeded or failed
                 *
                 * @param {String} str Message from the server
                 */
                _actionSMTPStream(str, callback) {
                    if (Number(str.charAt(0)) !== 2) {
                        // Message failed
                        return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));
                    } else {
                        // Message sent succesfully
                        return callback(null, str);
                    }
                }

                /**
                 * Handle response for a DATA stream
                 * We expect a separate response for every recipient. All recipients can either
                 * succeed or fail separately
                 *
                 * @param {String} recipient The recipient this response applies to
                 * @param {Boolean} final Is this the final recipient?
                 * @param {String} str Message from the server
                 */
                _actionLMTPStream(recipient, final, str, callback) {
                    let err;
                    if (Number(str.charAt(0)) !== 2) {
                        // Message failed
                        err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');
                        err.recipient = recipient;
                        this._envelope.rejected.push(recipient);
                        this._envelope.rejectedErrors.push(err);
                        for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {
                            if (this._envelope.accepted[i] === recipient) {
                                this._envelope.accepted.splice(i, 1);
                            }
                        }
                    }
                    if (final) {
                        return callback(null, str);
                    }
                }

                _handleXOauth2Token(isRetry, callback) {
                    this._auth.oauth2.getToken(isRetry, (err, accessToken) => {
                        if (err) {
                            this.logger.info(
                                {
                                    tnx: 'smtp',
                                    username: this._auth.user,
                                    action: 'authfail',
                                    method: this._authMethod
                                },
                                'User %s failed to authenticate',
                                JSON.stringify(this._auth.user)
                            );
                            return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));
                        }
                        this._responseActions.push(str => {
                            this._actionAUTHComplete(str, isRetry, callback);
                        });
                        this._sendCommand(
                            'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken),
                            //  Hidden for logs
                            'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */')
                        );
                    });
                }

                /**
                 *
                 * @param {string} command
                 * @private
                 */
                _isDestroyedMessage(command) {
                    if (this._destroyed) {
                        return 'Cannot ' + command + ' - smtp connection is already destroyed.';
                    }

                    if (this._socket) {
                        if (this._socket.destroyed) {
                            return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';
                        }

                        if (!this._socket.writable) {
                            return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';
                        }
                    }
                }

                _getHostname() {
                    // defaul hostname is machine hostname or [IP]
                    let defaultHostname = os.hostname() || '';

                    // ignore if not FQDN
                    if (defaultHostname.indexOf('.') < 0) {
                        defaultHostname = '[127.0.0.1]';
                    }

                    // IP should be enclosed in []
                    if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
                        defaultHostname = '[' + defaultHostname + ']';
                    }

                    return defaultHostname;
                }
            }

            module.exports = SMTPConnection;


            /***/
        }),
        /* 581 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.REQUEST_HEADER = exports.INVOCATION_ID_HEADER = exports.NO_RETRY_INCREMENT = exports.TIMEOUT_RETRY_COST = exports.RETRY_COST = exports.INITIAL_RETRY_TOKENS = exports.THROTTLING_RETRY_DELAY_BASE = exports.MAXIMUM_RETRY_DELAY = exports.DEFAULT_RETRY_DELAY_BASE = void 0;
            exports.DEFAULT_RETRY_DELAY_BASE = 100;
            exports.MAXIMUM_RETRY_DELAY = 20 * 1000;
            exports.THROTTLING_RETRY_DELAY_BASE = 500;
            exports.INITIAL_RETRY_TOKENS = 500;
            exports.RETRY_COST = 5;
            exports.TIMEOUT_RETRY_COST = 10;
            exports.NO_RETRY_INCREMENT = 1;
            exports.INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
            exports.REQUEST_HEADER = "amz-sdk-request";


            /***/
        }),
        /* 582 */,
        /* 583 */,
        /* 584 */,
        /* 585 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const stream = __webpack_require__(413);
            const Transform = stream.Transform;

            /**
             * Ensures that only <LF> is used for linebreaks
             *
             * @param {Object} options Stream options
             */
            class LeWindows extends Transform {
                constructor(options) {
                    super(options);
                    // init Transform
                    this.options = options || {};
                }

                /**
                 * Escapes dots
                 */
                _transform(chunk, encoding, done) {
                    let buf;
                    let lastPos = 0;

                    for (let i = 0, len = chunk.length; i < len; i++) {
                        if (chunk[i] === 0x0d) {
                            // \n
                            buf = chunk.slice(lastPos, i);
                            lastPos = i + 1;
                            this.push(buf);
                        }
                    }
                    if (lastPos && lastPos < chunk.length) {
                        buf = chunk.slice(lastPos);
                        this.push(buf);
                    } else if (!lastPos) {
                        this.push(chunk);
                    }
                    done();
                }
            }

            module.exports = LeWindows;


            /***/
        }),
        /* 586 */,
        /* 587 */,
        /* 588 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(408), exports);


            /***/
        }),
        /* 589 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.normalizeProvider = void 0;
            const normalizeProvider = (input) => {
                if (typeof input === "function")
                    return input;
                const promisified = Promise.resolve(input);
                return () => promisified;
            };
            exports.normalizeProvider = normalizeProvider;


            /***/
        }),
        /* 590 */,
        /* 591 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromWebToken = void 0;
            const property_provider_1 = __webpack_require__(118);
            const fromWebToken = (init) => () => {
                const {
                    roleArn,
                    roleSessionName,
                    webIdentityToken,
                    providerId,
                    policyArns,
                    policy,
                    durationSeconds,
                    roleAssumerWithWebIdentity,
                } = init;
                if (!roleAssumerWithWebIdentity) {
                    throw new property_provider_1.CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity,` +
                        ` but no role assumption callback was provided.`, false);
                }
                return roleAssumerWithWebIdentity({
                    RoleArn: roleArn,
                    RoleSessionName: roleSessionName !== null && roleSessionName !== void 0 ? roleSessionName : `aws-sdk-js-session-${Date.now()}`,
                    WebIdentityToken: webIdentityToken,
                    ProviderId: providerId,
                    PolicyArns: policyArns,
                    Policy: policy,
                    DurationSeconds: durationSeconds,
                });
            };
            exports.fromWebToken = fromWebToken;


            /***/
        }),
        /* 592 */,
        /* 593 */,
        /* 594 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            var isPlainObject = __webpack_require__(279);
            var universalUserAgent = __webpack_require__(922);

            function lowercaseKeys(object) {
                if (!object) {
                    return {};
                }

                return Object.keys(object).reduce((newObj, key) => {
                    newObj[key.toLowerCase()] = object[key];
                    return newObj;
                }, {});
            }

            function mergeDeep(defaults, options) {
                const result = Object.assign({}, defaults);
                Object.keys(options).forEach(key => {
                    if (isPlainObject.isPlainObject(options[key])) {
                        if (!(key in defaults)) Object.assign(result, {
                            [key]: options[key]
                        }); else result[key] = mergeDeep(defaults[key], options[key]);
                    } else {
                        Object.assign(result, {
                            [key]: options[key]
                        });
                    }
                });
                return result;
            }

            function removeUndefinedProperties(obj) {
                for (const key in obj) {
                    if (obj[key] === undefined) {
                        delete obj[key];
                    }
                }

                return obj;
            }

            function merge(defaults, route, options) {
                if (typeof route === "string") {
                    let [method, url] = route.split(" ");
                    options = Object.assign(url ? {
                        method,
                        url
                    } : {
                        url: method
                    }, options);
                } else {
                    options = Object.assign({}, route);
                } // lowercase header names before merging with defaults to avoid duplicates


                options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging

                removeUndefinedProperties(options);
                removeUndefinedProperties(options.headers);
                const mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten

                if (defaults && defaults.mediaType.previews.length) {
                    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(preview => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
                }

                mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(preview => preview.replace(/-preview/, ""));
                return mergedOptions;
            }

            function addQueryParameters(url, parameters) {
                const separator = /\?/.test(url) ? "&" : "?";
                const names = Object.keys(parameters);

                if (names.length === 0) {
                    return url;
                }

                return url + separator + names.map(name => {
                    if (name === "q") {
                        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
                    }

                    return `${name}=${encodeURIComponent(parameters[name])}`;
                }).join("&");
            }

            const urlVariableRegex = /\{[^}]+\}/g;

            function removeNonChars(variableName) {
                return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
            }

            function extractUrlVariableNames(url) {
                const matches = url.match(urlVariableRegex);

                if (!matches) {
                    return [];
                }

                return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
            }

            function omit(object, keysToOmit) {
                return Object.keys(object).filter(option => !keysToOmit.includes(option)).reduce((obj, key) => {
                    obj[key] = object[key];
                    return obj;
                }, {});
            }

// Based on https://github.com/bramstein/url-template, licensed under BSD
// TODO: create separate package.
//
// Copyright (c) 2012-2014, Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

            /* istanbul ignore file */
            function encodeReserved(str) {
                return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
                    if (!/%[0-9A-Fa-f]/.test(part)) {
                        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
                    }

                    return part;
                }).join("");
            }

            function encodeUnreserved(str) {
                return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
                    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
                });
            }

            function encodeValue(operator, value, key) {
                value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);

                if (key) {
                    return encodeUnreserved(key) + "=" + value;
                } else {
                    return value;
                }
            }

            function isDefined(value) {
                return value !== undefined && value !== null;
            }

            function isKeyOperator(operator) {
                return operator === ";" || operator === "&" || operator === "?";
            }

            function getValues(context, operator, key, modifier) {
                var value = context[key],
                    result = [];

                if (isDefined(value) && value !== "") {
                    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                        value = value.toString();

                        if (modifier && modifier !== "*") {
                            value = value.substring(0, parseInt(modifier, 10));
                        }

                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
                    } else {
                        if (modifier === "*") {
                            if (Array.isArray(value)) {
                                value.filter(isDefined).forEach(function (value) {
                                    result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
                                });
                            } else {
                                Object.keys(value).forEach(function (k) {
                                    if (isDefined(value[k])) {
                                        result.push(encodeValue(operator, value[k], k));
                                    }
                                });
                            }
                        } else {
                            const tmp = [];

                            if (Array.isArray(value)) {
                                value.filter(isDefined).forEach(function (value) {
                                    tmp.push(encodeValue(operator, value));
                                });
                            } else {
                                Object.keys(value).forEach(function (k) {
                                    if (isDefined(value[k])) {
                                        tmp.push(encodeUnreserved(k));
                                        tmp.push(encodeValue(operator, value[k].toString()));
                                    }
                                });
                            }

                            if (isKeyOperator(operator)) {
                                result.push(encodeUnreserved(key) + "=" + tmp.join(","));
                            } else if (tmp.length !== 0) {
                                result.push(tmp.join(","));
                            }
                        }
                    }
                } else {
                    if (operator === ";") {
                        if (isDefined(value)) {
                            result.push(encodeUnreserved(key));
                        }
                    } else if (value === "" && (operator === "&" || operator === "?")) {
                        result.push(encodeUnreserved(key) + "=");
                    } else if (value === "") {
                        result.push("");
                    }
                }

                return result;
            }

            function parseUrl(template) {
                return {
                    expand: expand.bind(null, template)
                };
            }

            function expand(template, context) {
                var operators = ["+", "#", ".", "/", ";", "?", "&"];
                return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
                    if (expression) {
                        let operator = "";
                        const values = [];

                        if (operators.indexOf(expression.charAt(0)) !== -1) {
                            operator = expression.charAt(0);
                            expression = expression.substr(1);
                        }

                        expression.split(/,/g).forEach(function (variable) {
                            var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                            values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
                        });

                        if (operator && operator !== "+") {
                            var separator = ",";

                            if (operator === "?") {
                                separator = "&";
                            } else if (operator !== "#") {
                                separator = operator;
                            }

                            return (values.length !== 0 ? operator : "") + values.join(separator);
                        } else {
                            return values.join(",");
                        }
                    } else {
                        return encodeReserved(literal);
                    }
                });
            }

            function parse(options) {
                // https://fetch.spec.whatwg.org/#methods
                let method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible

                let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
                let headers = Object.assign({}, options.headers);
                let body;
                let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]); // extract variable names from URL to calculate remaining variables later

                const urlVariableNames = extractUrlVariableNames(url);
                url = parseUrl(url).expand(parameters);

                if (!/^http/.test(url)) {
                    url = options.baseUrl + url;
                }

                const omittedParameters = Object.keys(options).filter(option => urlVariableNames.includes(option)).concat("baseUrl");
                const remainingParameters = omit(parameters, omittedParameters);
                const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);

                if (!isBinaryRequest) {
                    if (options.mediaType.format) {
                        // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
                        headers.accept = headers.accept.split(/,/).map(preview => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
                    }

                    if (options.mediaType.previews.length) {
                        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
                        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map(preview => {
                            const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
                            return `application/vnd.github.${preview}-preview${format}`;
                        }).join(",");
                    }
                } // for GET/HEAD requests, set URL query parameters from remaining parameters
                // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters


                if (["GET", "HEAD"].includes(method)) {
                    url = addQueryParameters(url, remainingParameters);
                } else {
                    if ("data" in remainingParameters) {
                        body = remainingParameters.data;
                    } else {
                        if (Object.keys(remainingParameters).length) {
                            body = remainingParameters;
                        } else {
                            headers["content-length"] = 0;
                        }
                    }
                } // default content-type for JSON if body is set


                if (!headers["content-type"] && typeof body !== "undefined") {
                    headers["content-type"] = "application/json; charset=utf-8";
                } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
                // fetch does not allow to set `content-length` header, but we can set body to an empty string


                if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
                    body = "";
                } // Only return body/request keys if present


                return Object.assign({
                    method,
                    url,
                    headers
                }, typeof body !== "undefined" ? {
                    body
                } : null, options.request ? {
                    request: options.request
                } : null);
            }

            function endpointWithDefaults(defaults, route, options) {
                return parse(merge(defaults, route, options));
            }

            function withDefaults(oldDefaults, newDefaults) {
                const DEFAULTS = merge(oldDefaults, newDefaults);
                const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
                return Object.assign(endpoint, {
                    DEFAULTS,
                    defaults: withDefaults.bind(null, DEFAULTS),
                    merge: merge.bind(null, DEFAULTS),
                    parse
                });
            }

            const VERSION = "6.0.12";

            const userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`; // DEFAULTS has all properties set that EndpointOptions has, except url.
// So we use RequestParameters and add method as additional required property.

            const DEFAULTS = {
                method: "GET",
                baseUrl: "https://api.github.com",
                headers: {
                    accept: "application/vnd.github.v3+json",
                    "user-agent": userAgent
                },
                mediaType: {
                    format: "",
                    previews: []
                }
            };

            const endpoint = withDefaults(null, DEFAULTS);

            exports.endpoint = endpoint;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 595 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            var register = __webpack_require__(434)
            var addHook = __webpack_require__(807)
            var removeHook = __webpack_require__(695)

// bind with array of arguments: https://stackoverflow.com/a/21792913
            var bind = Function.bind
            var bindable = bind.bind(bind)

            function bindApi(hook, state, name) {
                var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state])
                hook.api = {remove: removeHookRef}
                hook.remove = removeHookRef

                ;['before', 'error', 'after', 'wrap'].forEach(function (kind) {
                    var args = name ? [state, kind, name] : [state, kind]
                    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args)
                })
            }

            function HookSingular() {
                var singularHookName = 'h'
                var singularHookState = {
                    registry: {}
                }
                var singularHook = register.bind(null, singularHookState, singularHookName)
                bindApi(singularHook, singularHookState, singularHookName)
                return singularHook
            }

            function HookCollection() {
                var state = {
                    registry: {}
                }

                var hook = register.bind(null, state)
                bindApi(hook, state)

                return hook
            }

            var collectionHookDeprecationMessageDisplayed = false

            function Hook() {
                if (!collectionHookDeprecationMessageDisplayed) {
                    console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4')
                    collectionHookDeprecationMessageDisplayed = true
                }
                return HookCollection()
            }

            Hook.Singular = HookSingular.bind()
            Hook.Collection = HookCollection.bind()

            module.exports = Hook
// expose constructors as a named property for TypeScript
            module.exports.Hook = Hook
            module.exports.Singular = Hook.Singular
            module.exports.Collection = Hook.Collection


            /***/
        }),
        /* 596 */,
        /* 597 */,
        /* 598 */,
        /* 599 */,
        /* 600 */,
        /* 601 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveAssumeRoleCredentials = exports.isAssumeRoleProfile = void 0;
            const property_provider_1 = __webpack_require__(118);
            const shared_ini_file_loader_1 = __webpack_require__(706);
            const resolveCredentialSource_1 = __webpack_require__(844);
            const resolveProfileData_1 = __webpack_require__(558);
            const isAssumeRoleProfile = (arg) => Boolean(arg) &&
                typeof arg === "object" &&
                typeof arg.role_arn === "string" &&
                ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 &&
                ["undefined", "string"].indexOf(typeof arg.external_id) > -1 &&
                ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 &&
                (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
            exports.isAssumeRoleProfile = isAssumeRoleProfile;
            const isAssumeRoleWithSourceProfile = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
            const isAssumeRoleWithProviderProfile = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
            const resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
                const data = profiles[profileName];
                if (!options.roleAssumer) {
                    throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
                }
                const {source_profile} = data;
                if (source_profile && source_profile in visitedProfiles) {
                    throw new property_provider_1.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile` +
                        ` ${(0, shared_ini_file_loader_1.getProfileName)(options)}. Profiles visited: ` +
                        Object.keys(visitedProfiles).join(", "), false);
                }
                const sourceCredsProvider = source_profile
                    ? (0, resolveProfileData_1.resolveProfileData)(source_profile, profiles, options, {
                        ...visitedProfiles,
                        [source_profile]: true,
                    })
                    : (0, resolveCredentialSource_1.resolveCredentialSource)(data.credential_source, profileName)();
                const params = {
                    RoleArn: data.role_arn,
                    RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
                    ExternalId: data.external_id,
                };
                const {mfa_serial} = data;
                if (mfa_serial) {
                    if (!options.mfaCodeProvider) {
                        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
                    }
                    params.SerialNumber = mfa_serial;
                    params.TokenCode = await options.mfaCodeProvider(mfa_serial);
                }
                const sourceCreds = await sourceCredsProvider;
                return options.roleAssumer(sourceCreds, params);
            };
            exports.resolveAssumeRoleCredentials = resolveAssumeRoleCredentials;


            /***/
        }),
        /* 602 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteConfigurationSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteConfigurationSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteConfigurationSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteConfigurationSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteConfigurationSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteConfigurationSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteConfigurationSetCommand)(output, context);
                }
            }

            exports.DeleteConfigurationSetCommand = DeleteConfigurationSetCommand;


            /***/
        }),
        /* 603 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.paginateListCustomVerificationEmailTemplates = void 0;
            const ListCustomVerificationEmailTemplatesCommand_1 = __webpack_require__(458);
            const SES_1 = __webpack_require__(302);
            const SESClient_1 = __webpack_require__(522);
            const makePagedClientRequest = async (client, input, ...args) => {
                return await client.send(new ListCustomVerificationEmailTemplatesCommand_1.ListCustomVerificationEmailTemplatesCommand(input), ...args);
            };
            const makePagedRequest = async (client, input, ...args) => {
                return await client.listCustomVerificationEmailTemplates(input, ...args);
            };

            async function* paginateListCustomVerificationEmailTemplates(config, input, ...additionalArguments) {
                let token = config.startingToken || undefined;
                let hasNext = true;
                let page;
                while (hasNext) {
                    input.NextToken = token;
                    input["MaxResults"] = config.pageSize;
                    if (config.client instanceof SES_1.SES) {
                        page = await makePagedRequest(config.client, input, ...additionalArguments);
                    } else if (config.client instanceof SESClient_1.SESClient) {
                        page = await makePagedClientRequest(config.client, input, ...additionalArguments);
                    } else {
                        throw new Error("Invalid client, expected SES | SESClient");
                    }
                    yield page;
                    token = page.NextToken;
                    hasNext = !!token;
                }
                return undefined;
            }

            exports.paginateListCustomVerificationEmailTemplates = paginateListCustomVerificationEmailTemplates;


            /***/
        }),
        /* 604 */,
        /* 605 */
        /***/ (function (module) {

            module.exports = require("http");

            /***/
        }),
        /* 606 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.clearCredentialCache = exports.getSigningKey = exports.createScope = void 0;
            const util_hex_encoding_1 = __webpack_require__(341);
            const constants_1 = __webpack_require__(70);
            const signingKeyCache = {};
            const cacheQueue = [];
            const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;
            exports.createScope = createScope;
            const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
                const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
                const cacheKey = `${shortDate}:${region}:${service}:${(0, util_hex_encoding_1.toHex)(credsHash)}:${credentials.sessionToken}`;
                if (cacheKey in signingKeyCache) {
                    return signingKeyCache[cacheKey];
                }
                cacheQueue.push(cacheKey);
                while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {
                    delete signingKeyCache[cacheQueue.shift()];
                }
                let key = `AWS4${credentials.secretAccessKey}`;
                for (const signable of [shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]) {
                    key = await hmac(sha256Constructor, key, signable);
                }
                return (signingKeyCache[cacheKey] = key);
            };
            exports.getSigningKey = getSigningKey;
            const clearCredentialCache = () => {
                cacheQueue.length = 0;
                Object.keys(signingKeyCache).forEach((cacheKey) => {
                    delete signingKeyCache[cacheKey];
                });
            };
            exports.clearCredentialCache = clearCredentialCache;
            const hmac = (ctor, secret, data) => {
                const hash = new ctor(secret);
                hash.update(data);
                return hash.digest();
            };


            /***/
        }),
        /* 607 */,
        /* 608 */,
        /* 609 */,
        /* 610 */,
        /* 611 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.AssumeRoleWithWebIdentityCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(575);
            const Aws_query_1 = __webpack_require__(139);

            class AssumeRoleWithWebIdentityCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "STSClient";
                    const commandName = "AssumeRoleWithWebIdentityCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryAssumeRoleWithWebIdentityCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryAssumeRoleWithWebIdentityCommand)(output, context);
                }
            }

            exports.AssumeRoleWithWebIdentityCommand = AssumeRoleWithWebIdentityCommand;


            /***/
        }),
        /* 612 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.splitEvery = void 0;

            function splitEvery(value, delimiter, numDelimiters) {
                if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
                    throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
                }
                const segments = value.split(delimiter);
                if (numDelimiters === 1) {
                    return segments;
                }
                const compoundSegments = [];
                let currentSegment = "";
                for (let i = 0; i < segments.length; i++) {
                    if (currentSegment === "") {
                        currentSegment = segments[i];
                    } else {
                        currentSegment += delimiter + segments[i];
                    }
                    if ((i + 1) % numDelimiters === 0) {
                        compoundSegments.push(currentSegment);
                        currentSegment = "";
                    }
                }
                if (currentSegment !== "") {
                    compoundSegments.push(currentSegment);
                }
                return compoundSegments;
            }

            exports.splitEvery = splitEvery;


            /***/
        }),
        /* 613 */
        /***/ (function (module) {

            module.exports = eval("require")("encoding");


            /***/
        }),
        /* 614 */
        /***/ (function (module) {

            module.exports = require("events");

            /***/
        }),
        /* 615 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = void 0;
            const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
            const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
            exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
                environmentVariableSelector: (env) => {
                    return env[AWS_DEFAULTS_MODE_ENV];
                },
                configFileSelector: (profile) => {
                    return profile[AWS_DEFAULTS_MODE_CONFIG];
                },
                default: "legacy",
            };


            /***/
        }),
        /* 616 */,
        /* 617 */
        /***/ (function (module) {

            module.exports = eval("require")("aws-crt");


            /***/
        }),
        /* 618 */,
        /* 619 */,
        /* 620 */,
        /* 621 */,
        /* 622 */
        /***/ (function (module) {

            module.exports = require("path");

            /***/
        }),
        /* 623 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.defaultUserAgent = exports.UA_APP_ID_INI_NAME = exports.UA_APP_ID_ENV_NAME = void 0;
            const node_config_provider_1 = __webpack_require__(588);
            const os_1 = __webpack_require__(87);
            const process_1 = __webpack_require__(765);
            const is_crt_available_1 = __webpack_require__(66);
            exports.UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
            exports.UA_APP_ID_INI_NAME = "sdk-ua-app-id";
            const defaultUserAgent = ({serviceId, clientVersion}) => {
                const sections = [
                    ["aws-sdk-js", clientVersion],
                    [`os/${(0, os_1.platform)()}`, (0, os_1.release)()],
                    ["lang/js"],
                    ["md/nodejs", `${process_1.versions.node}`],
                ];
                const crtAvailable = (0, is_crt_available_1.isCrtAvailable)();
                if (crtAvailable) {
                    sections.push(crtAvailable);
                }
                if (serviceId) {
                    sections.push([`api/${serviceId}`, clientVersion]);
                }
                if (process_1.env.AWS_EXECUTION_ENV) {
                    sections.push([`exec-env/${process_1.env.AWS_EXECUTION_ENV}`]);
                }
                const appIdPromise = (0, node_config_provider_1.loadConfig)({
                    environmentVariableSelector: (env) => env[exports.UA_APP_ID_ENV_NAME],
                    configFileSelector: (profile) => profile[exports.UA_APP_ID_INI_NAME],
                    default: undefined,
                })();
                let resolvedUserAgent = undefined;
                return async () => {
                    if (!resolvedUserAgent) {
                        const appId = await appIdPromise;
                        resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
                    }
                    return resolvedUserAgent;
                };
            };
            exports.defaultUserAgent = defaultUserAgent;


            /***/
        }),
        /* 624 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(982), exports);
            tslib_1.__exportStar(__webpack_require__(490), exports);


            /***/
        }),
        /* 625 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.defaultDelayDecider = void 0;
            const constants_1 = __webpack_require__(581);
            const defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(constants_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
            exports.defaultDelayDecider = defaultDelayDecider;


            /***/
        }),
        /* 626 */,
        /* 627 */,
        /* 628 */,
        /* 629 */
        /***/ (function (module) {

            module.exports = {
                "Aacute": "",
                "aacute": "",
                "Acirc": "",
                "acirc": "",
                "acute": "",
                "AElig": "",
                "aelig": "",
                "Agrave": "",
                "agrave": "",
                "amp": "&",
                "AMP": "&",
                "Aring": "",
                "aring": "",
                "Atilde": "",
                "atilde": "",
                "Auml": "",
                "auml": "",
                "brvbar": "",
                "Ccedil": "",
                "ccedil": "",
                "cedil": "",
                "cent": "",
                "copy": "",
                "COPY": "",
                "curren": "",
                "deg": "",
                "divide": "",
                "Eacute": "",
                "eacute": "",
                "Ecirc": "",
                "ecirc": "",
                "Egrave": "",
                "egrave": "",
                "ETH": "",
                "eth": "",
                "Euml": "",
                "euml": "",
                "frac12": "",
                "frac14": "",
                "frac34": "",
                "gt": ">",
                "GT": ">",
                "Iacute": "",
                "iacute": "",
                "Icirc": "",
                "icirc": "",
                "iexcl": "",
                "Igrave": "",
                "igrave": "",
                "iquest": "",
                "Iuml": "",
                "iuml": "",
                "laquo": "",
                "lt": "<",
                "LT": "<",
                "macr": "",
                "micro": "",
                "middot": "",
                "nbsp": "",
                "not": "",
                "Ntilde": "",
                "ntilde": "",
                "Oacute": "",
                "oacute": "",
                "Ocirc": "",
                "ocirc": "",
                "Ograve": "",
                "ograve": "",
                "ordf": "",
                "ordm": "",
                "Oslash": "",
                "oslash": "",
                "Otilde": "",
                "otilde": "",
                "Ouml": "",
                "ouml": "",
                "para": "",
                "plusmn": "",
                "pound": "",
                "quot": "\"",
                "QUOT": "\"",
                "raquo": "",
                "reg": "",
                "REG": "",
                "sect": "",
                "shy": "",
                "sup1": "",
                "sup2": "",
                "sup3": "",
                "szlig": "",
                "THORN": "",
                "thorn": "",
                "times": "",
                "Uacute": "",
                "uacute": "",
                "Ucirc": "",
                "ucirc": "",
                "Ugrave": "",
                "ugrave": "",
                "uml": "",
                "Uuml": "",
                "uuml": "",
                "Yacute": "",
                "yacute": "",
                "yen": "",
                "yuml": ""
            };

            /***/
        }),
        /* 630 */,
        /* 631 */
        /***/ (function (module) {

            module.exports = require("net");

            /***/
        }),
        /* 632 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const spawn = __webpack_require__(129).spawn;
            const packageData = __webpack_require__(786);
            const shared = __webpack_require__(190);

            /**
             * Generates a Transport object for Sendmail
             *
             * Possible options can be the following:
             *
             *  * **path** optional path to sendmail binary
             *  * **newline** either 'windows' or 'unix'
             *  * **args** an array of arguments for the sendmail binary
             *
             * @constructor
             * @param {Object} optional config parameter for Sendmail
             */
            class SendmailTransport {
                constructor(options) {
                    options = options || {};

                    // use a reference to spawn for mocking purposes
                    this._spawn = spawn;

                    this.options = options || {};

                    this.name = 'Sendmail';
                    this.version = packageData.version;

                    this.path = 'sendmail';
                    this.args = false;
                    this.winbreak = false;

                    this.logger = shared.getLogger(this.options, {
                        component: this.options.component || 'sendmail'
                    });

                    if (options) {
                        if (typeof options === 'string') {
                            this.path = options;
                        } else if (typeof options === 'object') {
                            if (options.path) {
                                this.path = options.path;
                            }
                            if (Array.isArray(options.args)) {
                                this.args = options.args;
                            }
                            this.winbreak = ['win', 'windows', 'dos', '\r\n'].includes((options.newline || '').toString().toLowerCase());
                        }
                    }
                }

                /**
                 * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
                 *
                 * @param {Object} emailMessage MailComposer object
                 * @param {Function} callback Callback function to run when the sending is completed
                 */
                send(mail, done) {
                    // Sendmail strips this header line by itself
                    mail.message.keepBcc = true;

                    let envelope = mail.data.envelope || mail.message.getEnvelope();
                    let messageId = mail.message.messageId();
                    let args;
                    let sendmail;
                    let returned;

                    const hasInvalidAddresses = []
                        .concat(envelope.from || [])
                        .concat(envelope.to || [])
                        .some(addr => /^-/.test(addr));
                    if (hasInvalidAddresses) {
                        return done(new Error('Can not send mail. Invalid envelope addresses.'));
                    }

                    if (this.args) {
                        // force -i to keep single dots
                        args = ['-i'].concat(this.args).concat(envelope.to);
                    } else {
                        args = ['-i'].concat(envelope.from ? ['-f', envelope.from] : []).concat(envelope.to);
                    }

                    let callback = err => {
                        if (returned) {
                            // ignore any additional responses, already done
                            return;
                        }
                        returned = true;
                        if (typeof done === 'function') {
                            if (err) {
                                return done(err);
                            } else {
                                return done(null, {
                                    envelope: mail.data.envelope || mail.message.getEnvelope(),
                                    messageId,
                                    response: 'Messages queued for delivery'
                                });
                            }
                        }
                    };

                    try {
                        sendmail = this._spawn(this.path, args);
                    } catch (E) {
                        this.logger.error(
                            {
                                err: E,
                                tnx: 'spawn',
                                messageId
                            },
                            'Error occurred while spawning sendmail. %s',
                            E.message
                        );
                        return callback(E);
                    }

                    if (sendmail) {
                        sendmail.on('error', err => {
                            this.logger.error(
                                {
                                    err,
                                    tnx: 'spawn',
                                    messageId
                                },
                                'Error occurred when sending message %s. %s',
                                messageId,
                                err.message
                            );
                            callback(err);
                        });

                        sendmail.once('exit', code => {
                            if (!code) {
                                return callback();
                            }
                            let err;
                            if (code === 127) {
                                err = new Error('Sendmail command not found, process exited with code ' + code);
                            } else {
                                err = new Error('Sendmail exited with code ' + code);
                            }

                            this.logger.error(
                                {
                                    err,
                                    tnx: 'stdin',
                                    messageId
                                },
                                'Error sending message %s to sendmail. %s',
                                messageId,
                                err.message
                            );
                            callback(err);
                        });
                        sendmail.once('close', callback);

                        sendmail.stdin.on('error', err => {
                            this.logger.error(
                                {
                                    err,
                                    tnx: 'stdin',
                                    messageId
                                },
                                'Error occurred when piping message %s to sendmail. %s',
                                messageId,
                                err.message
                            );
                            callback(err);
                        });

                        let recipients = [].concat(envelope.to || []);
                        if (recipients.length > 3) {
                            recipients.push('...and ' + recipients.splice(2).length + ' more');
                        }
                        this.logger.info(
                            {
                                tnx: 'send',
                                messageId
                            },
                            'Sending message %s to <%s>',
                            messageId,
                            recipients.join(', ')
                        );

                        let sourceStream = mail.message.createReadStream();
                        sourceStream.once('error', err => {
                            this.logger.error(
                                {
                                    err,
                                    tnx: 'stdin',
                                    messageId
                                },
                                'Error occurred when generating message %s. %s',
                                messageId,
                                err.message
                            );
                            sendmail.kill('SIGINT'); // do not deliver the message
                            callback(err);
                        });

                        sourceStream.pipe(sendmail.stdin);
                    } else {
                        return callback(new Error('sendmail was not found'));
                    }
                }
            }

            module.exports = SendmailTransport;


            /***/
        }),
        /* 633 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.setSocketTimeout = void 0;
            const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
                request.setTimeout(timeoutInMs, () => {
                    request.destroy();
                    reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), {name: "TimeoutError"}));
                });
            };
            exports.setSocketTimeout = setSocketTimeout;


            /***/
        }),
        /* 634 */,
        /* 635 */,
        /* 636 */,
        /* 637 */,
        /* 638 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                Object.defineProperty(o, k2, {
                    enumerable: true, get: function () {
                        return m[k];
                    }
                });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", {enumerable: true, value: v});
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getOctokitOptions = exports.GitHub = exports.context = void 0;
            const Context = __importStar(__webpack_require__(433));
            const Utils = __importStar(__webpack_require__(692));
// octokit + plugins
            const core_1 = __webpack_require__(49);
            const plugin_rest_endpoint_methods_1 = __webpack_require__(23);
            const plugin_paginate_rest_1 = __webpack_require__(763);
            exports.context = new Context.Context();
            const baseUrl = Utils.getApiBaseUrl();
            const defaults = {
                baseUrl,
                request: {
                    agent: Utils.getProxyAgent(baseUrl)
                }
            };
            exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(defaults);

            /**
             * Convience function to correctly format Octokit Options to pass into the constructor.
             *
             * @param     token    the repo PAT or GITHUB_TOKEN
             * @param     options  other options to set
             */
            function getOctokitOptions(token, options) {
                const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
                // Auth
                const auth = Utils.getAuthString(token, opts);
                if (auth) {
                    opts.auth = auth;
                }
                return opts;
            }

            exports.getOctokitOptions = getOctokitOptions;
//# sourceMappingURL=utils.js.map

            /***/
        }),
        /* 639 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 640 */,
        /* 641 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.PutIdentityPolicyCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class PutIdentityPolicyCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "PutIdentityPolicyCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.PutIdentityPolicyRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.PutIdentityPolicyResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryPutIdentityPolicyCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryPutIdentityPolicyCommand)(output, context);
                }
            }

            exports.PutIdentityPolicyCommand = PutIdentityPolicyCommand;


            /***/
        }),
        /* 642 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getPayloadHash = void 0;
            const is_array_buffer_1 = __webpack_require__(865);
            const util_hex_encoding_1 = __webpack_require__(341);
            const constants_1 = __webpack_require__(70);
            const getPayloadHash = async ({headers, body}, hashConstructor) => {
                for (const headerName of Object.keys(headers)) {
                    if (headerName.toLowerCase() === constants_1.SHA256_HEADER) {
                        return headers[headerName];
                    }
                }
                if (body == undefined) {
                    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
                } else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, is_array_buffer_1.isArrayBuffer)(body)) {
                    const hashCtor = new hashConstructor();
                    hashCtor.update(body);
                    return (0, util_hex_encoding_1.toHex)(await hashCtor.digest());
                }
                return constants_1.UNSIGNED_PAYLOAD;
            };
            exports.getPayloadHash = getPayloadHash;


            /***/
        }),
        /* 643 */,
        /* 644 */,
        /* 645 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(11), exports);
            tslib_1.__exportStar(__webpack_require__(850), exports);
            tslib_1.__exportStar(__webpack_require__(274), exports);


            /***/
        }),
        /* 646 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            var wrappy = __webpack_require__(818)
            module.exports = wrappy(once)
            module.exports.strict = wrappy(onceStrict)

            once.proto = once(function () {
                Object.defineProperty(Function.prototype, 'once', {
                    value: function () {
                        return once(this)
                    },
                    configurable: true
                })

                Object.defineProperty(Function.prototype, 'onceStrict', {
                    value: function () {
                        return onceStrict(this)
                    },
                    configurable: true
                })
            })

            function once(fn) {
                var f = function () {
                    if (f.called) return f.value
                    f.called = true
                    return f.value = fn.apply(this, arguments)
                }
                f.called = false
                return f
            }

            function onceStrict(fn) {
                var f = function () {
                    if (f.called)
                        throw new Error(f.onceError)
                    f.called = true
                    return f.value = fn.apply(this, arguments)
                }
                var name = fn.name || 'Function wrapped with `once`'
                f.onceError = name + " shouldn't be called more than once"
                f.called = false
                return f
            }


            /***/
        }),
        /* 647 */,
        /* 648 */,
        /* 649 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SetIdentityNotificationTopicCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SetIdentityNotificationTopicCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SetIdentityNotificationTopicCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SetIdentityNotificationTopicRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SetIdentityNotificationTopicResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySetIdentityNotificationTopicCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySetIdentityNotificationTopicCommand)(output, context);
                }
            }

            exports.SetIdentityNotificationTopicCommand = SetIdentityNotificationTopicCommand;


            /***/
        }),
        /* 650 */,
        /* 651 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SendCustomVerificationEmailCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SendCustomVerificationEmailCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SendCustomVerificationEmailCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SendCustomVerificationEmailRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SendCustomVerificationEmailResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySendCustomVerificationEmailCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySendCustomVerificationEmailCommand)(output, context);
                }
            }

            exports.SendCustomVerificationEmailCommand = SendCustomVerificationEmailCommand;


            /***/
        }),
        /* 652 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";
            /* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */


            const crypto = __webpack_require__(417);
            const os = __webpack_require__(87);
            const fs = __webpack_require__(747);
            const punycode = __webpack_require__(213);
            const PassThrough = __webpack_require__(413).PassThrough;
            const shared = __webpack_require__(190);

            const mimeFuncs = __webpack_require__(103);
            const qp = __webpack_require__(529);
            const base64 = __webpack_require__(528);
            const addressparser = __webpack_require__(656);
            const fetch = __webpack_require__(204);
            const LastNewline = __webpack_require__(755);

            const LeWindows = __webpack_require__(791);
            const LeUnix = __webpack_require__(585);

            /**
             * Creates a new mime tree node. Assumes 'multipart/*' as the content type
             * if it is a branch, anything else counts as leaf. If rootNode is missing from
             * the options, assumes this is the root.
             *
             * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)
             * @param {Object} [options] optional options
             * @param {Object} [options.rootNode] root node for this tree
             * @param {Object} [options.parentNode] immediate parent for this node
             * @param {Object} [options.filename] filename for an attachment node
             * @param {String} [options.baseBoundary] shared part of the unique multipart boundary
             * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers
             * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing
             * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'
             */
            class MimeNode {
                constructor(contentType, options) {
                    this.nodeCounter = 0;

                    options = options || {};

                    /**
                     * shared part of the unique multipart boundary
                     */
                    this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');
                    this.boundaryPrefix = options.boundaryPrefix || '--_NmP';

                    this.disableFileAccess = !!options.disableFileAccess;
                    this.disableUrlAccess = !!options.disableUrlAccess;

                    this.normalizeHeaderKey = options.normalizeHeaderKey;

                    /**
                     * If date headers is missing and current node is the root, this value is used instead
                     */
                    this.date = new Date();

                    /**
                     * Root node for current mime tree
                     */
                    this.rootNode = options.rootNode || this;

                    /**
                     * If true include Bcc in generated headers (if available)
                     */
                    this.keepBcc = !!options.keepBcc;

                    /**
                     * If filename is specified but contentType is not (probably an attachment)
                     * detect the content type from filename extension
                     */
                    if (options.filename) {
                        /**
                         * Filename for this node. Useful with attachments
                         */
                        this.filename = options.filename;
                        if (!contentType) {
                            contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());
                        }
                    }

                    /**
                     * Indicates which encoding should be used for header strings: "Q" or "B"
                     */
                    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();

                    /**
                     * Immediate parent for this node (or undefined if not set)
                     */
                    this.parentNode = options.parentNode;

                    /**
                     * Hostname for default message-id values
                     */
                    this.hostname = options.hostname;

                    /**
                     * If set to 'win' then uses \r\n, if 'linux' then \n. If not set (or `raw` is used) then newlines are kept as is.
                     */
                    this.newline = options.newline;

                    /**
                     * An array for possible child nodes
                     */
                    this.childNodes = [];

                    /**
                     * Used for generating unique boundaries (prepended to the shared base)
                     */
                    this._nodeId = ++this.rootNode.nodeCounter;

                    /**
                     * A list of header values for this node in the form of [{key:'', value:''}]
                     */
                    this._headers = [];

                    /**
                     * True if the content only uses ASCII printable characters
                     * @type {Boolean}
                     */
                    this._isPlainText = false;

                    /**
                     * True if the content is plain text but has longer lines than allowed
                     * @type {Boolean}
                     */
                    this._hasLongLines = false;

                    /**
                     * If set, use instead this value for envelopes instead of generating one
                     * @type {Boolean}
                     */
                    this._envelope = false;

                    /**
                     * If set then use this value as the stream content instead of building it
                     * @type {String|Buffer|Stream}
                     */
                    this._raw = false;

                    /**
                     * Additional transform streams that the message will be piped before
                     * exposing by createReadStream
                     * @type {Array}
                     */
                    this._transforms = [];

                    /**
                     * Additional process functions that the message will be piped through before
                     * exposing by createReadStream. These functions are run after transforms
                     * @type {Array}
                     */
                    this._processFuncs = [];

                    /**
                     * If content type is set (or derived from the filename) add it to headers
                     */
                    if (contentType) {
                        this.setHeader('Content-Type', contentType);
                    }
                }

                /////// PUBLIC METHODS

                /**
                 * Creates and appends a child node.Arguments provided are passed to MimeNode constructor
                 *
                 * @param {String} [contentType] Optional content type
                 * @param {Object} [options] Optional options object
                 * @return {Object} Created node object
                 */
                createChild(contentType, options) {
                    if (!options && typeof contentType === 'object') {
                        options = contentType;
                        contentType = undefined;
                    }
                    let node = new MimeNode(contentType, options);
                    this.appendChild(node);
                    return node;
                }

                /**
                 * Appends an existing node to the mime tree. Removes the node from an existing
                 * tree if needed
                 *
                 * @param {Object} childNode node to be appended
                 * @return {Object} Appended node object
                 */
                appendChild(childNode) {
                    if (childNode.rootNode !== this.rootNode) {
                        childNode.rootNode = this.rootNode;
                        childNode._nodeId = ++this.rootNode.nodeCounter;
                    }

                    childNode.parentNode = this;

                    this.childNodes.push(childNode);
                    return childNode;
                }

                /**
                 * Replaces current node with another node
                 *
                 * @param {Object} node Replacement node
                 * @return {Object} Replacement node
                 */
                replace(node) {
                    if (node === this) {
                        return this;
                    }

                    this.parentNode.childNodes.forEach((childNode, i) => {
                        if (childNode === this) {
                            node.rootNode = this.rootNode;
                            node.parentNode = this.parentNode;
                            node._nodeId = this._nodeId;

                            this.rootNode = this;
                            this.parentNode = undefined;

                            node.parentNode.childNodes[i] = node;
                        }
                    });

                    return node;
                }

                /**
                 * Removes current node from the mime tree
                 *
                 * @return {Object} removed node
                 */
                remove() {
                    if (!this.parentNode) {
                        return this;
                    }

                    for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {
                        if (this.parentNode.childNodes[i] === this) {
                            this.parentNode.childNodes.splice(i, 1);
                            this.parentNode = undefined;
                            this.rootNode = this;
                            return this;
                        }
                    }
                }

                /**
                 * Sets a header value. If the value for selected key exists, it is overwritten.
                 * You can set multiple values as well by using [{key:'', value:''}] or
                 * {key: 'value'} as the first argument.
                 *
                 * @param {String|Array|Object} key Header key or a list of key value pairs
                 * @param {String} value Header value
                 * @return {Object} current node
                 */
                setHeader(key, value) {
                    let added = false,
                        headerValue;

                    // Allow setting multiple headers at once
                    if (!value && key && typeof key === 'object') {
                        // allow {key:'content-type', value: 'text/plain'}
                        if (key.key && 'value' in key) {
                            this.setHeader(key.key, key.value);
                        } else if (Array.isArray(key)) {
                            // allow [{key:'content-type', value: 'text/plain'}]
                            key.forEach(i => {
                                this.setHeader(i.key, i.value);
                            });
                        } else {
                            // allow {'content-type': 'text/plain'}
                            Object.keys(key).forEach(i => {
                                this.setHeader(i, key[i]);
                            });
                        }
                        return this;
                    }

                    key = this._normalizeHeaderKey(key);

                    headerValue = {
                        key,
                        value
                    };

                    // Check if the value exists and overwrite
                    for (let i = 0, len = this._headers.length; i < len; i++) {
                        if (this._headers[i].key === key) {
                            if (!added) {
                                // replace the first match
                                this._headers[i] = headerValue;
                                added = true;
                            } else {
                                // remove following matches
                                this._headers.splice(i, 1);
                                i--;
                                len--;
                            }
                        }
                    }

                    // match not found, append the value
                    if (!added) {
                        this._headers.push(headerValue);
                    }

                    return this;
                }

                /**
                 * Adds a header value. If the value for selected key exists, the value is appended
                 * as a new field and old one is not touched.
                 * You can set multiple values as well by using [{key:'', value:''}] or
                 * {key: 'value'} as the first argument.
                 *
                 * @param {String|Array|Object} key Header key or a list of key value pairs
                 * @param {String} value Header value
                 * @return {Object} current node
                 */
                addHeader(key, value) {
                    // Allow setting multiple headers at once
                    if (!value && key && typeof key === 'object') {
                        // allow {key:'content-type', value: 'text/plain'}
                        if (key.key && key.value) {
                            this.addHeader(key.key, key.value);
                        } else if (Array.isArray(key)) {
                            // allow [{key:'content-type', value: 'text/plain'}]
                            key.forEach(i => {
                                this.addHeader(i.key, i.value);
                            });
                        } else {
                            // allow {'content-type': 'text/plain'}
                            Object.keys(key).forEach(i => {
                                this.addHeader(i, key[i]);
                            });
                        }
                        return this;
                    } else if (Array.isArray(value)) {
                        value.forEach(val => {
                            this.addHeader(key, val);
                        });
                        return this;
                    }

                    this._headers.push({
                        key: this._normalizeHeaderKey(key),
                        value
                    });

                    return this;
                }

                /**
                 * Retrieves the first mathcing value of a selected key
                 *
                 * @param {String} key Key to search for
                 * @retun {String} Value for the key
                 */
                getHeader(key) {
                    key = this._normalizeHeaderKey(key);
                    for (let i = 0, len = this._headers.length; i < len; i++) {
                        if (this._headers[i].key === key) {
                            return this._headers[i].value;
                        }
                    }
                }

                /**
                 * Sets body content for current node. If the value is a string, charset is added automatically
                 * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify
                 * the charset yourself
                 *
                 * @param (String|Buffer) content Body content
                 * @return {Object} current node
                 */
                setContent(content) {
                    this.content = content;
                    if (typeof this.content.pipe === 'function') {
                        // pre-stream handler. might be triggered if a stream is set as content
                        // and 'error' fires before anything is done with this stream
                        this._contentErrorHandler = err => {
                            this.content.removeListener('error', this._contentErrorHandler);
                            this.content = err;
                        };
                        this.content.once('error', this._contentErrorHandler);
                    } else if (typeof this.content === 'string') {
                        this._isPlainText = mimeFuncs.isPlainText(this.content);
                        if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {
                            // If there are lines longer than 76 symbols/bytes do not use 7bit
                            this._hasLongLines = true;
                        }
                    }
                    return this;
                }

                build(callback) {
                    let promise;

                    if (!callback) {
                        promise = new Promise((resolve, reject) => {
                            callback = shared.callbackPromise(resolve, reject);
                        });
                    }

                    let stream = this.createReadStream();
                    let buf = [];
                    let buflen = 0;
                    let returned = false;

                    stream.on('readable', () => {
                        let chunk;

                        while ((chunk = stream.read()) !== null) {
                            buf.push(chunk);
                            buflen += chunk.length;
                        }
                    });

                    stream.once('error', err => {
                        if (returned) {
                            return;
                        }
                        returned = true;

                        return callback(err);
                    });

                    stream.once('end', chunk => {
                        if (returned) {
                            return;
                        }
                        returned = true;

                        if (chunk && chunk.length) {
                            buf.push(chunk);
                            buflen += chunk.length;
                        }
                        return callback(null, Buffer.concat(buf, buflen));
                    });

                    return promise;
                }

                getTransferEncoding() {
                    let transferEncoding = false;
                    let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();

                    if (this.content) {
                        transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();
                        if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {
                            if (/^text\//i.test(contentType)) {
                                // If there are no special symbols, no need to modify the text
                                if (this._isPlainText && !this._hasLongLines) {
                                    transferEncoding = '7bit';
                                } else if (typeof this.content === 'string' || this.content instanceof Buffer) {
                                    // detect preferred encoding for string value
                                    transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';
                                } else {
                                    // we can not check content for a stream, so either use preferred encoding or fallback to QP
                                    transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';
                                }
                            } else if (!/^(multipart|message)\//i.test(contentType)) {
                                transferEncoding = transferEncoding || 'base64';
                            }
                        }
                    }
                    return transferEncoding;
                }

                /**
                 * Builds the header block for the mime node. Append \r\n\r\n before writing the content
                 *
                 * @returns {String} Headers
                 */
                buildHeaders() {
                    let transferEncoding = this.getTransferEncoding();
                    let headers = [];

                    if (transferEncoding) {
                        this.setHeader('Content-Transfer-Encoding', transferEncoding);
                    }

                    if (this.filename && !this.getHeader('Content-Disposition')) {
                        this.setHeader('Content-Disposition', 'attachment');
                    }

                    // Ensure mandatory header fields
                    if (this.rootNode === this) {
                        if (!this.getHeader('Date')) {
                            this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));
                        }

                        // ensure that Message-Id is present
                        this.messageId();

                        if (!this.getHeader('MIME-Version')) {
                            this.setHeader('MIME-Version', '1.0');
                        }
                    }

                    this._headers.forEach(header => {
                        let key = header.key;
                        let value = header.value;
                        let structured;
                        let param;
                        let options = {};
                        let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];

                        if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {
                            Object.keys(value).forEach(key => {
                                if (key !== 'value') {
                                    options[key] = value[key];
                                }
                            });
                            value = (value.value || '').toString();
                            if (!value.trim()) {
                                return;
                            }
                        }

                        if (options.prepared) {
                            // header value is
                            if (options.foldLines) {
                                headers.push(mimeFuncs.foldLines(key + ': ' + value));
                            } else {
                                headers.push(key + ': ' + value);
                            }
                            return;
                        }

                        switch (header.key) {
                            case 'Content-Disposition':
                                structured = mimeFuncs.parseHeaderValue(value);
                                if (this.filename) {
                                    structured.params.filename = this.filename;
                                }
                                value = mimeFuncs.buildHeaderValue(structured);
                                break;

                            case 'Content-Type':
                                structured = mimeFuncs.parseHeaderValue(value);

                                this._handleContentType(structured);

                                if (structured.value.match(/^text\/plain\b/) && typeof this.content === 'string' && /[\u0080-\uFFFF]/.test(this.content)) {
                                    structured.params.charset = 'utf-8';
                                }

                                value = mimeFuncs.buildHeaderValue(structured);

                                if (this.filename) {
                                    // add support for non-compliant clients like QQ webmail
                                    // we can't build the value with buildHeaderValue as the value is non standard and
                                    // would be converted to parameter continuation encoding that we do not want
                                    param = this._encodeWords(this.filename);

                                    if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                                        // include value in quotes if needed
                                        param = '"' + param + '"';
                                    }
                                    value += '; name=' + param;
                                }
                                break;

                            case 'Bcc':
                                if (!this.keepBcc) {
                                    // skip BCC values
                                    return;
                                }
                                break;
                        }

                        value = this._encodeHeaderValue(key, value);

                        // skip empty lines
                        if (!(value || '').toString().trim()) {
                            return;
                        }

                        if (typeof this.normalizeHeaderKey === 'function') {
                            let normalized = this.normalizeHeaderKey(key, value);
                            if (normalized && typeof normalized === 'string' && normalized.length) {
                                key = normalized;
                            }
                        }

                        headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));
                    });

                    return headers.join('\r\n');
                }

                /**
                 * Streams the rfc2822 message from the current node. If this is a root node,
                 * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)
                 *
                 * @return {String} Compiled message
                 */
                createReadStream(options) {
                    options = options || {};

                    let stream = new PassThrough(options);
                    let outputStream = stream;
                    let transform;

                    this.stream(stream, options, err => {
                        if (err) {
                            outputStream.emit('error', err);
                            return;
                        }
                        stream.end();
                    });

                    for (let i = 0, len = this._transforms.length; i < len; i++) {
                        transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];
                        outputStream.once('error', err => {
                            transform.emit('error', err);
                        });
                        outputStream = outputStream.pipe(transform);
                    }

                    // ensure terminating newline after possible user transforms
                    transform = new LastNewline();
                    outputStream.once('error', err => {
                        transform.emit('error', err);
                    });
                    outputStream = outputStream.pipe(transform);

                    // dkim and stuff
                    for (let i = 0, len = this._processFuncs.length; i < len; i++) {
                        transform = this._processFuncs[i];
                        outputStream = transform(outputStream);
                    }

                    if (this.newline) {
                        const winbreak = ['win', 'windows', 'dos', '\r\n'].includes(this.newline.toString().toLowerCase());
                        const newlineTransform = winbreak ? new LeWindows() : new LeUnix();

                        const stream = outputStream.pipe(newlineTransform);
                        outputStream.on('error', err => stream.emit('error', err));
                        return stream;
                    }

                    return outputStream;
                }

                /**
                 * Appends a transform stream object to the transforms list. Final output
                 * is passed through this stream before exposing
                 *
                 * @param {Object} transform Read-Write stream
                 */
                transform(transform) {
                    this._transforms.push(transform);
                }

                /**
                 * Appends a post process function. The functon is run after transforms and
                 * uses the following syntax
                 *
                 *   processFunc(input) -> outputStream
                 *
                 * @param {Object} processFunc Read-Write stream
                 */
                processFunc(processFunc) {
                    this._processFuncs.push(processFunc);
                }

                stream(outputStream, options, done) {
                    let transferEncoding = this.getTransferEncoding();
                    let contentStream;
                    let localStream;

                    // protect actual callback against multiple triggering
                    let returned = false;
                    let callback = err => {
                        if (returned) {
                            return;
                        }
                        returned = true;
                        done(err);
                    };

                    // for multipart nodes, push child nodes
                    // for content nodes end the stream
                    let finalize = () => {
                        let childId = 0;
                        let processChildNode = () => {
                            if (childId >= this.childNodes.length) {
                                outputStream.write('\r\n--' + this.boundary + '--\r\n');
                                return callback();
                            }
                            let child = this.childNodes[childId++];
                            outputStream.write((childId > 1 ? '\r\n' : '') + '--' + this.boundary + '\r\n');
                            child.stream(outputStream, options, err => {
                                if (err) {
                                    return callback(err);
                                }
                                setImmediate(processChildNode);
                            });
                        };

                        if (this.multipart) {
                            setImmediate(processChildNode);
                        } else {
                            return callback();
                        }
                    };

                    // pushes node content
                    let sendContent = () => {
                        if (this.content) {
                            if (Object.prototype.toString.call(this.content) === '[object Error]') {
                                // content is already errored
                                return callback(this.content);
                            }

                            if (typeof this.content.pipe === 'function') {
                                this.content.removeListener('error', this._contentErrorHandler);
                                this._contentErrorHandler = err => callback(err);
                                this.content.once('error', this._contentErrorHandler);
                            }

                            let createStream = () => {
                                if (['quoted-printable', 'base64'].includes(transferEncoding)) {
                                    contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);

                                    contentStream.pipe(outputStream, {
                                        end: false
                                    });
                                    contentStream.once('end', finalize);
                                    contentStream.once('error', err => callback(err));

                                    localStream = this._getStream(this.content);
                                    localStream.pipe(contentStream);
                                } else {
                                    // anything that is not QP or Base54 passes as-is
                                    localStream = this._getStream(this.content);
                                    localStream.pipe(outputStream, {
                                        end: false
                                    });
                                    localStream.once('end', finalize);
                                }

                                localStream.once('error', err => callback(err));
                            };

                            if (this.content._resolve) {
                                let chunks = [];
                                let chunklen = 0;
                                let returned = false;
                                let sourceStream = this._getStream(this.content);
                                sourceStream.on('error', err => {
                                    if (returned) {
                                        return;
                                    }
                                    returned = true;
                                    callback(err);
                                });
                                sourceStream.on('readable', () => {
                                    let chunk;
                                    while ((chunk = sourceStream.read()) !== null) {
                                        chunks.push(chunk);
                                        chunklen += chunk.length;
                                    }
                                });
                                sourceStream.on('end', () => {
                                    if (returned) {
                                        return;
                                    }
                                    returned = true;
                                    this.content._resolve = false;
                                    this.content._resolvedValue = Buffer.concat(chunks, chunklen);
                                    setImmediate(createStream);
                                });
                            } else {
                                setImmediate(createStream);
                            }
                            return;
                        } else {
                            return setImmediate(finalize);
                        }
                    };

                    if (this._raw) {
                        setImmediate(() => {
                            if (Object.prototype.toString.call(this._raw) === '[object Error]') {
                                // content is already errored
                                return callback(this._raw);
                            }

                            // remove default error handler (if set)
                            if (typeof this._raw.pipe === 'function') {
                                this._raw.removeListener('error', this._contentErrorHandler);
                            }

                            let raw = this._getStream(this._raw);
                            raw.pipe(outputStream, {
                                end: false
                            });
                            raw.on('error', err => outputStream.emit('error', err));
                            raw.on('end', finalize);
                        });
                    } else {
                        outputStream.write(this.buildHeaders() + '\r\n\r\n');
                        setImmediate(sendContent);
                    }
                }

                /**
                 * Sets envelope to be used instead of the generated one
                 *
                 * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
                 */
                setEnvelope(envelope) {
                    let list;

                    this._envelope = {
                        from: false,
                        to: []
                    };

                    if (envelope.from) {
                        list = [];
                        this._convertAddresses(this._parseAddresses(envelope.from), list);
                        list = list.filter(address => address && address.address);
                        if (list.length && list[0]) {
                            this._envelope.from = list[0].address;
                        }
                    }
                    ['to', 'cc', 'bcc'].forEach(key => {
                        if (envelope[key]) {
                            this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
                        }
                    });

                    this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);

                    let standardFields = ['to', 'cc', 'bcc', 'from'];
                    Object.keys(envelope).forEach(key => {
                        if (!standardFields.includes(key)) {
                            this._envelope[key] = envelope[key];
                        }
                    });

                    return this;
                }

                /**
                 * Generates and returns an object with parsed address fields
                 *
                 * @return {Object} Address object
                 */
                getAddresses() {
                    let addresses = {};

                    this._headers.forEach(header => {
                        let key = header.key.toLowerCase();
                        if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {
                            if (!Array.isArray(addresses[key])) {
                                addresses[key] = [];
                            }

                            this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
                        }
                    });

                    return addresses;
                }

                /**
                 * Generates and returns SMTP envelope with the sender address and a list of recipients addresses
                 *
                 * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
                 */
                getEnvelope() {
                    if (this._envelope) {
                        return this._envelope;
                    }

                    let envelope = {
                        from: false,
                        to: []
                    };
                    this._headers.forEach(header => {
                        let list = [];
                        if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {
                            this._convertAddresses(this._parseAddresses(header.value), list);
                            if (list.length && list[0]) {
                                envelope.from = list[0].address;
                            }
                        } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {
                            this._convertAddresses(this._parseAddresses(header.value), envelope.to);
                        }
                    });

                    envelope.to = envelope.to.map(to => to.address);

                    return envelope;
                }

                /**
                 * Returns Message-Id value. If it does not exist, then creates one
                 *
                 * @return {String} Message-Id value
                 */
                messageId() {
                    let messageId = this.getHeader('Message-ID');
                    // You really should define your own Message-Id field!
                    if (!messageId) {
                        messageId = this._generateMessageId();
                        this.setHeader('Message-ID', messageId);
                    }
                    return messageId;
                }

                /**
                 * Sets pregenerated content that will be used as the output of this node
                 *
                 * @param {String|Buffer|Stream} Raw MIME contents
                 */
                setRaw(raw) {
                    this._raw = raw;

                    if (this._raw && typeof this._raw.pipe === 'function') {
                        // pre-stream handler. might be triggered if a stream is set as content
                        // and 'error' fires before anything is done with this stream
                        this._contentErrorHandler = err => {
                            this._raw.removeListener('error', this._contentErrorHandler);
                            this._raw = err;
                        };
                        this._raw.once('error', this._contentErrorHandler);
                    }

                    return this;
                }

                /////// PRIVATE METHODS

                /**
                 * Detects and returns handle to a stream related with the content.
                 *
                 * @param {Mixed} content Node content
                 * @returns {Object} Stream object
                 */
                _getStream(content) {
                    let contentStream;

                    if (content._resolvedValue) {
                        // pass string or buffer content as a stream
                        contentStream = new PassThrough();
                        setImmediate(() => contentStream.end(content._resolvedValue));
                        return contentStream;
                    } else if (typeof content.pipe === 'function') {
                        // assume as stream
                        return content;
                    } else if (content && typeof content.path === 'string' && !content.href) {
                        if (this.disableFileAccess) {
                            contentStream = new PassThrough();
                            setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));
                            return contentStream;
                        }
                        // read file
                        return fs.createReadStream(content.path);
                    } else if (content && typeof content.href === 'string') {
                        if (this.disableUrlAccess) {
                            contentStream = new PassThrough();
                            setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));
                            return contentStream;
                        }
                        // fetch URL
                        return fetch(content.href, {headers: content.httpHeaders});
                    } else {
                        // pass string or buffer content as a stream
                        contentStream = new PassThrough();
                        setImmediate(() => contentStream.end(content || ''));
                        return contentStream;
                    }
                }

                /**
                 * Parses addresses. Takes in a single address or an array or an
                 * array of address arrays (eg. To: [[first group], [second group],...])
                 *
                 * @param {Mixed} addresses Addresses to be parsed
                 * @return {Array} An array of address objects
                 */
                _parseAddresses(addresses) {
                    return [].concat.apply(
                        [],
                        [].concat(addresses).map(address => {
                            // eslint-disable-line prefer-spread
                            if (address && address.address) {
                                address.address = this._normalizeAddress(address.address);
                                address.name = address.name || '';
                                return [address];
                            }
                            return addressparser(address);
                        })
                    );
                }

                /**
                 * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-
                 *
                 * @param {String} key Key to be normalized
                 * @return {String} key in Camel-Case form
                 */
                _normalizeHeaderKey(key) {
                    key = (key || '')
                        .toString()
                        // no newlines in keys
                        .replace(/\r?\n|\r/g, ' ')
                        .trim()
                        .toLowerCase()
                        // use uppercase words, except MIME
                        .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())
                        // special case
                        .replace(/^Content-Features$/i, 'Content-features');

                    return key;
                }

                /**
                 * Checks if the content type is multipart and defines boundary if needed.
                 * Doesn't return anything, modifies object argument instead.
                 *
                 * @param {Object} structured Parsed header value for 'Content-Type' key
                 */
                _handleContentType(structured) {
                    this.contentType = structured.value.trim().toLowerCase();

                    this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;

                    if (this.multipart) {
                        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
                    } else {
                        this.boundary = false;
                    }
                }

                /**
                 * Generates a multipart boundary value
                 *
                 * @return {String} boundary value
                 */
                _generateBoundary() {
                    return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;
                }

                /**
                 * Encodes a header value for use in the generated rfc2822 email.
                 *
                 * @param {String} key Header key
                 * @param {String} value Header value
                 */
                _encodeHeaderValue(key, value) {
                    key = this._normalizeHeaderKey(key);

                    switch (key) {
                        // Structured headers
                        case 'From':
                        case 'Sender':
                        case 'To':
                        case 'Cc':
                        case 'Bcc':
                        case 'Reply-To':
                            return this._convertAddresses(this._parseAddresses(value));

                        // values enclosed in <>
                        case 'Message-ID':
                        case 'In-Reply-To':
                        case 'Content-Id':
                            value = (value || '').toString().replace(/\r?\n|\r/g, ' ');

                            if (value.charAt(0) !== '<') {
                                value = '<' + value;
                            }

                            if (value.charAt(value.length - 1) !== '>') {
                                value = value + '>';
                            }
                            return value;

                        // space separated list of values enclosed in <>
                        case 'References':
                            value = [].concat
                                .apply(
                                    [],
                                    [].concat(value || '').map(elm => {
                                        // eslint-disable-line prefer-spread
                                        elm = (elm || '')
                                            .toString()
                                            .replace(/\r?\n|\r/g, ' ')
                                            .trim();
                                        return elm.replace(/<[^>]*>/g, str => str.replace(/\s/g, '')).split(/\s+/);
                                    })
                                )
                                .map(elm => {
                                    if (elm.charAt(0) !== '<') {
                                        elm = '<' + elm;
                                    }
                                    if (elm.charAt(elm.length - 1) !== '>') {
                                        elm = elm + '>';
                                    }
                                    return elm;
                                });

                            return value.join(' ').trim();

                        case 'Date':
                            if (Object.prototype.toString.call(value) === '[object Date]') {
                                return value.toUTCString().replace(/GMT/, '+0000');
                            }

                            value = (value || '').toString().replace(/\r?\n|\r/g, ' ');
                            return this._encodeWords(value);

                        case 'Content-Type':
                        case 'Content-Disposition':
                            // if it includes a filename then it is already encoded
                            return (value || '').toString().replace(/\r?\n|\r/g, ' ');

                        default:
                            value = (value || '').toString().replace(/\r?\n|\r/g, ' ');
                            // encodeWords only encodes if needed, otherwise the original string is returned
                            return this._encodeWords(value);
                    }
                }

                /**
                 * Rebuilds address object using punycode and other adjustments
                 *
                 * @param {Array} addresses An array of address objects
                 * @param {Array} [uniqueList] An array to be populated with addresses
                 * @return {String} address string
                 */
                _convertAddresses(addresses, uniqueList) {
                    let values = [];

                    uniqueList = uniqueList || [];

                    [].concat(addresses || []).forEach(address => {
                        if (address.address) {
                            address.address = this._normalizeAddress(address.address);

                            if (!address.name) {
                                values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);
                            } else if (address.name) {
                                values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
                            }

                            if (address.address) {
                                if (!uniqueList.filter(a => a.address === address.address).length) {
                                    uniqueList.push(address);
                                }
                            }
                        } else if (address.group) {
                            let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();
                            values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
                        }
                    });

                    return values.join(', ');
                }

                /**
                 * Normalizes an email address
                 *
                 * @param {Array} address An array of address objects
                 * @return {String} address string
                 */
                _normalizeAddress(address) {
                    address = (address || '')
                        .toString()
                        .replace(/[\x00-\x1F<>]+/g, ' ') // remove unallowed characters
                        .trim();

                    let lastAt = address.lastIndexOf('@');
                    if (lastAt < 0) {
                        // Bare username
                        return address;
                    }

                    let user = address.substr(0, lastAt);
                    let domain = address.substr(lastAt + 1);

                    // Usernames are not touched and are kept as is even if these include unicode
                    // Domains are punycoded by default
                    // 'jgeva.ee' will be converted to 'xn--jgeva-dua.ee'
                    // non-unicode domains are left as is

                    let encodedDomain;

                    try {
                        encodedDomain = punycode.toASCII(domain.toLowerCase());
                    } catch (err) {
                        // keep as is?
                    }

                    if (user.indexOf(' ') >= 0) {
                        if (user.charAt(0) !== '"') {
                            user = '"' + user;
                        }
                        if (user.substr(-1) !== '"') {
                            user = user + '"';
                        }
                    }

                    return `${user}@${encodedDomain}`;
                }

                /**
                 * If needed, mime encodes the name part
                 *
                 * @param {String} name Name part of an address
                 * @returns {String} Mime word encoded string if needed
                 */
                _encodeAddressName(name) {
                    if (!/^[\w ']*$/.test(name)) {
                        if (/^[\x20-\x7e]*$/.test(name)) {
                            return '"' + name.replace(/([\\"])/g, '\\$1') + '"';
                        } else {
                            return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
                        }
                    }
                    return name;
                }

                /**
                 * If needed, mime encodes the name part
                 *
                 * @param {String} name Name part of an address
                 * @returns {String} Mime word encoded string if needed
                 */
                _encodeWords(value) {
                    // set encodeAll parameter to true even though it is against the recommendation of RFC2047,
                    // by default only words that include non-ascii should be converted into encoded words
                    // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace
                    return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);
                }

                /**
                 * Detects best mime encoding for a text value
                 *
                 * @param {String} value Value to check for
                 * @return {String} either 'Q' or 'B'
                 */
                _getTextEncoding(value) {
                    value = (value || '').toString();

                    let encoding = this.textEncoding;
                    let latinLen;
                    let nonLatinLen;

                    if (!encoding) {
                        // count latin alphabet symbols and 8-bit range symbols + control symbols
                        // if there are more latin characters, then use quoted-printable
                        // encoding, otherwise use base64
                        nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex
                        latinLen = (value.match(/[a-z]/gi) || []).length;
                        // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B
                        encoding = nonLatinLen < latinLen ? 'Q' : 'B';
                    }
                    return encoding;
                }

                /**
                 * Generates a message id
                 *
                 * @return {String} Random Message-ID value
                 */
                _generateMessageId() {
                    return (
                        '<' +
                        [2, 2, 2, 6].reduce(
                            // crux to generate UUID-like random strings
                            (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),
                            crypto.randomBytes(4).toString('hex')
                        ) +
                        '@' +
                        // try to use the domain of the FROM address or fallback to server hostname
                        (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() +
                        '>'
                    );
                }
            }

            module.exports = MimeNode;


            /***/
        }),
        /* 653 */,
        /* 654 */,
        /* 655 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(921), exports);


            /***/
        }),
        /* 656 */
        /***/ (function (module) {

            "use strict";


            /**
             * Converts tokens for a single address into an address object
             *
             * @param {Array} tokens Tokens object
             * @return {Object} Address object
             */
            function _handleAddress(tokens) {
                let token;
                let isGroup = false;
                let state = 'text';
                let address;
                let addresses = [];
                let data = {
                    address: [],
                    comment: [],
                    group: [],
                    text: []
                };
                let i;
                let len;

                // Filter out <addresses>, (comments) and regular text
                for (i = 0, len = tokens.length; i < len; i++) {
                    token = tokens[i];
                    if (token.type === 'operator') {
                        switch (token.value) {
                            case '<':
                                state = 'address';
                                break;
                            case '(':
                                state = 'comment';
                                break;
                            case ':':
                                state = 'group';
                                isGroup = true;
                                break;
                            default:
                                state = 'text';
                        }
                    } else if (token.value) {
                        if (state === 'address') {
                            // handle use case where unquoted name includes a "<"
                            // Apple Mail truncates everything between an unexpected < and an address
                            // and so will we
                            token.value = token.value.replace(/^[^<]*<\s*/, '');
                        }
                        data[state].push(token.value);
                    }
                }

                // If there is no text but a comment, replace the two
                if (!data.text.length && data.comment.length) {
                    data.text = data.comment;
                    data.comment = [];
                }

                if (isGroup) {
                    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
                    data.text = data.text.join(' ');
                    addresses.push({
                        name: data.text || (address && address.name),
                        group: data.group.length ? addressparser(data.group.join(',')) : []
                    });
                } else {
                    // If no address was found, try to detect one from regular text
                    if (!data.address.length && data.text.length) {
                        for (i = data.text.length - 1; i >= 0; i--) {
                            if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                                data.address = data.text.splice(i, 1);
                                break;
                            }
                        }

                        let _regexHandler = function (address) {
                            if (!data.address.length) {
                                data.address = [address.trim()];
                                return ' ';
                            } else {
                                return address;
                            }
                        };

                        // still no address
                        if (!data.address.length) {
                            for (i = data.text.length - 1; i >= 0; i--) {
                                // fixed the regex to parse email address correctly when email address has more than one @
                                data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                                if (data.address.length) {
                                    break;
                                }
                            }
                        }
                    }

                    // If there's still is no text but a comment exixts, replace the two
                    if (!data.text.length && data.comment.length) {
                        data.text = data.comment;
                        data.comment = [];
                    }

                    // Keep only the first address occurence, push others to regular text
                    if (data.address.length > 1) {
                        data.text = data.text.concat(data.address.splice(1));
                    }

                    // Join values with spaces
                    data.text = data.text.join(' ');
                    data.address = data.address.join(' ');

                    if (!data.address && isGroup) {
                        return [];
                    } else {
                        address = {
                            address: data.address || data.text || '',
                            name: data.text || data.address || ''
                        };

                        if (address.address === address.name) {
                            if ((address.address || '').match(/@/)) {
                                address.name = '';
                            } else {
                                address.address = '';
                            }
                        }

                        addresses.push(address);
                    }
                }

                return addresses;
            }

            /**
             * Creates a Tokenizer object for tokenizing address field strings
             *
             * @constructor
             * @param {String} str Address field string
             */
            class Tokenizer {
                constructor(str) {
                    this.str = (str || '').toString();
                    this.operatorCurrent = '';
                    this.operatorExpecting = '';
                    this.node = null;
                    this.escaped = false;

                    this.list = [];
                    /**
                     * Operator tokens and which tokens are expected to end the sequence
                     */
                    this.operators = {
                        '"': '"',
                        '(': ')',
                        '<': '>',
                        ',': '',
                        ':': ';',
                        // Semicolons are not a legal delimiter per the RFC2822 grammar other
                        // than for terminating a group, but they are also not valid for any
                        // other use in this context.  Given that some mail clients have
                        // historically allowed the semicolon as a delimiter equivalent to the
                        // comma in their UI, it makes sense to treat them the same as a comma
                        // when used outside of a group.
                        ';': ''
                    };
                }

                /**
                 * Tokenizes the original input string
                 *
                 * @return {Array} An array of operator|text tokens
                 */
                tokenize() {
                    let chr,
                        list = [];
                    for (let i = 0, len = this.str.length; i < len; i++) {
                        chr = this.str.charAt(i);
                        this.checkChar(chr);
                    }

                    this.list.forEach(node => {
                        node.value = (node.value || '').toString().trim();
                        if (node.value) {
                            list.push(node);
                        }
                    });

                    return list;
                }

                /**
                 * Checks if a character is an operator or text and acts accordingly
                 *
                 * @param {String} chr Character from the address field
                 */
                checkChar(chr) {
                    if (this.escaped) {
                        // ignore next condition blocks
                    } else if (chr === this.operatorExpecting) {
                        this.node = {
                            type: 'operator',
                            value: chr
                        };
                        this.list.push(this.node);
                        this.node = null;
                        this.operatorExpecting = '';
                        this.escaped = false;
                        return;
                    } else if (!this.operatorExpecting && chr in this.operators) {
                        this.node = {
                            type: 'operator',
                            value: chr
                        };
                        this.list.push(this.node);
                        this.node = null;
                        this.operatorExpecting = this.operators[chr];
                        this.escaped = false;
                        return;
                    } else if (['"', "'"].includes(this.operatorExpecting) && chr === '\\') {
                        this.escaped = true;
                        return;
                    }

                    if (!this.node) {
                        this.node = {
                            type: 'text',
                            value: ''
                        };
                        this.list.push(this.node);
                    }

                    if (chr === '\n') {
                        // Convert newlines to spaces. Carriage return is ignored as \r and \n usually
                        // go together anyway and there already is a WS for \n. Lone \r means something is fishy.
                        chr = ' ';
                    }

                    if (chr.charCodeAt(0) >= 0x21 || [' ', '\t'].includes(chr)) {
                        // skip command bytes
                        this.node.value += chr;
                    }

                    this.escaped = false;
                }
            }

            /**
             * Parses structured e-mail addresses from an address field
             *
             * Example:
             *
             *    'Name <address@domain>'
             *
             * will be converted to
             *
             *     [{name: 'Name', address: 'address@domain'}]
             *
             * @param {String} str Address field
             * @return {Array} An array of address objects
             */
            function addressparser(str, options) {
                options = options || {};

                let tokenizer = new Tokenizer(str);
                let tokens = tokenizer.tokenize();

                let addresses = [];
                let address = [];
                let parsedAddresses = [];

                tokens.forEach(token => {
                    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {
                        if (address.length) {
                            addresses.push(address);
                        }
                        address = [];
                    } else {
                        address.push(token);
                    }
                });

                if (address.length) {
                    addresses.push(address);
                }

                addresses.forEach(address => {
                    address = _handleAddress(address);
                    if (address.length) {
                        parsedAddresses = parsedAddresses.concat(address);
                    }
                });

                if (options.flatten) {
                    let addresses = [];
                    let walkAddressList = list => {
                        list.forEach(address => {
                            if (address.group) {
                                return walkAddressList(address.group);
                            } else {
                                addresses.push(address);
                            }
                        });
                    };
                    walkAddressList(parsedAddresses);
                    return addresses;
                }

                return parsedAddresses;
            }

// expose to the world
            module.exports = addressparser;


            /***/
        }),
        /* 657 */,
        /* 658 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.defaultRegionInfoProvider = void 0;
            const config_resolver_1 = __webpack_require__(772);
            const regionHash = {
                "aws-global": {
                    variants: [
                        {
                            hostname: "sts.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "us-east-1",
                },
                "us-east-1": {
                    variants: [
                        {
                            hostname: "sts-fips.us-east-1.amazonaws.com",
                            tags: ["fips"],
                        },
                    ],
                },
                "us-east-2": {
                    variants: [
                        {
                            hostname: "sts-fips.us-east-2.amazonaws.com",
                            tags: ["fips"],
                        },
                    ],
                },
                "us-gov-east-1": {
                    variants: [
                        {
                            hostname: "sts.us-gov-east-1.amazonaws.com",
                            tags: ["fips"],
                        },
                    ],
                },
                "us-gov-west-1": {
                    variants: [
                        {
                            hostname: "sts.us-gov-west-1.amazonaws.com",
                            tags: ["fips"],
                        },
                    ],
                },
                "us-west-1": {
                    variants: [
                        {
                            hostname: "sts-fips.us-west-1.amazonaws.com",
                            tags: ["fips"],
                        },
                    ],
                },
                "us-west-2": {
                    variants: [
                        {
                            hostname: "sts-fips.us-west-2.amazonaws.com",
                            tags: ["fips"],
                        },
                    ],
                },
            };
            const partitionHash = {
                aws: {
                    regions: [
                        "af-south-1",
                        "ap-east-1",
                        "ap-northeast-1",
                        "ap-northeast-2",
                        "ap-northeast-3",
                        "ap-south-1",
                        "ap-southeast-1",
                        "ap-southeast-2",
                        "ap-southeast-3",
                        "aws-global",
                        "ca-central-1",
                        "eu-central-1",
                        "eu-north-1",
                        "eu-south-1",
                        "eu-west-1",
                        "eu-west-2",
                        "eu-west-3",
                        "me-south-1",
                        "sa-east-1",
                        "us-east-1",
                        "us-east-1-fips",
                        "us-east-2",
                        "us-east-2-fips",
                        "us-west-1",
                        "us-west-1-fips",
                        "us-west-2",
                        "us-west-2-fips",
                    ],
                    regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "sts.{region}.amazonaws.com",
                            tags: [],
                        },
                        {
                            hostname: "sts-fips.{region}.amazonaws.com",
                            tags: ["fips"],
                        },
                        {
                            hostname: "sts-fips.{region}.api.aws",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "sts.{region}.api.aws",
                            tags: ["dualstack"],
                        },
                    ],
                },
                "aws-cn": {
                    regions: ["cn-north-1", "cn-northwest-1"],
                    regionRegex: "^cn\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "sts.{region}.amazonaws.com.cn",
                            tags: [],
                        },
                        {
                            hostname: "sts-fips.{region}.amazonaws.com.cn",
                            tags: ["fips"],
                        },
                        {
                            hostname: "sts-fips.{region}.api.amazonwebservices.com.cn",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "sts.{region}.api.amazonwebservices.com.cn",
                            tags: ["dualstack"],
                        },
                    ],
                },
                "aws-iso": {
                    regions: ["us-iso-east-1", "us-iso-west-1"],
                    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "sts.{region}.c2s.ic.gov",
                            tags: [],
                        },
                        {
                            hostname: "sts-fips.{region}.c2s.ic.gov",
                            tags: ["fips"],
                        },
                    ],
                },
                "aws-iso-b": {
                    regions: ["us-isob-east-1"],
                    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "sts.{region}.sc2s.sgov.gov",
                            tags: [],
                        },
                        {
                            hostname: "sts-fips.{region}.sc2s.sgov.gov",
                            tags: ["fips"],
                        },
                    ],
                },
                "aws-us-gov": {
                    regions: ["us-gov-east-1", "us-gov-east-1-fips", "us-gov-west-1", "us-gov-west-1-fips"],
                    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "sts.{region}.amazonaws.com",
                            tags: [],
                        },
                        {
                            hostname: "sts.{region}.amazonaws.com",
                            tags: ["fips"],
                        },
                        {
                            hostname: "sts-fips.{region}.api.aws",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "sts.{region}.api.aws",
                            tags: ["dualstack"],
                        },
                    ],
                },
            };
            const defaultRegionInfoProvider = async (region, options) => (0, config_resolver_1.getRegionInfo)(region, {
                ...options,
                signingService: "sts",
                regionHash,
                partitionHash,
            });
            exports.defaultRegionInfoProvider = defaultRegionInfoProvider;


            /***/
        }),
        /* 659 */,
        /* 660 */,
        /* 661 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRuntimeConfig = void 0;
            const tslib_1 = __webpack_require__(84);
            const package_json_1 = tslib_1.__importDefault(__webpack_require__(766));
            const config_resolver_1 = __webpack_require__(772);
            const hash_node_1 = __webpack_require__(974);
            const middleware_retry_1 = __webpack_require__(806);
            const node_config_provider_1 = __webpack_require__(588);
            const node_http_handler_1 = __webpack_require__(720);
            const util_base64_node_1 = __webpack_require__(295);
            const util_body_length_node_1 = __webpack_require__(237);
            const util_user_agent_node_1 = __webpack_require__(623);
            const util_utf8_node_1 = __webpack_require__(495);
            const runtimeConfig_shared_1 = __webpack_require__(981);
            const smithy_client_1 = __webpack_require__(449);
            const util_defaults_mode_node_1 = __webpack_require__(770);
            const getRuntimeConfig = (config) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
                const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
                const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
                return {
                    ...clientSharedValues,
                    ...config,
                    runtime: "node",
                    defaultsMode,
                    base64Decoder: (_a = config === null || config === void 0 ? void 0 : config.base64Decoder) !== null && _a !== void 0 ? _a : util_base64_node_1.fromBase64,
                    base64Encoder: (_b = config === null || config === void 0 ? void 0 : config.base64Encoder) !== null && _b !== void 0 ? _b : util_base64_node_1.toBase64,
                    bodyLengthChecker: (_c = config === null || config === void 0 ? void 0 : config.bodyLengthChecker) !== null && _c !== void 0 ? _c : util_body_length_node_1.calculateBodyLength,
                    defaultUserAgentProvider: (_d = config === null || config === void 0 ? void 0 : config.defaultUserAgentProvider) !== null && _d !== void 0 ? _d : (0, util_user_agent_node_1.defaultUserAgent)({
                        serviceId: clientSharedValues.serviceId,
                        clientVersion: package_json_1.default.version
                    }),
                    maxAttempts: (_e = config === null || config === void 0 ? void 0 : config.maxAttempts) !== null && _e !== void 0 ? _e : (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
                    region: (_f = config === null || config === void 0 ? void 0 : config.region) !== null && _f !== void 0 ? _f : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
                    requestHandler: (_g = config === null || config === void 0 ? void 0 : config.requestHandler) !== null && _g !== void 0 ? _g : new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
                    retryMode: (_h = config === null || config === void 0 ? void 0 : config.retryMode) !== null && _h !== void 0 ? _h : (0, node_config_provider_1.loadConfig)({
                        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                        default: async () => (await defaultConfigProvider()).retryMode || middleware_retry_1.DEFAULT_RETRY_MODE,
                    }),
                    sha256: (_j = config === null || config === void 0 ? void 0 : config.sha256) !== null && _j !== void 0 ? _j : hash_node_1.Hash.bind(null, "sha256"),
                    streamCollector: (_k = config === null || config === void 0 ? void 0 : config.streamCollector) !== null && _k !== void 0 ? _k : node_http_handler_1.streamCollector,
                    useDualstackEndpoint: (_l = config === null || config === void 0 ? void 0 : config.useDualstackEndpoint) !== null && _l !== void 0 ? _l : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
                    useFipsEndpoint: (_m = config === null || config === void 0 ? void 0 : config.useFipsEndpoint) !== null && _m !== void 0 ? _m : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
                    utf8Decoder: (_o = config === null || config === void 0 ? void 0 : config.utf8Decoder) !== null && _o !== void 0 ? _o : util_utf8_node_1.fromUtf8,
                    utf8Encoder: (_p = config === null || config === void 0 ? void 0 : config.utf8Encoder) !== null && _p !== void 0 ? _p : util_utf8_node_1.toUtf8,
                };
            };
            exports.getRuntimeConfig = getRuntimeConfig;


            /***/
        }),
        /* 662 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SESServiceException = void 0;
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(302), exports);
            tslib_1.__exportStar(__webpack_require__(522), exports);
            tslib_1.__exportStar(__webpack_require__(150), exports);
            tslib_1.__exportStar(__webpack_require__(371), exports);
            tslib_1.__exportStar(__webpack_require__(270), exports);
            tslib_1.__exportStar(__webpack_require__(655), exports);
            var SESServiceException_1 = __webpack_require__(353);
            Object.defineProperty(exports, "SESServiceException", {
                enumerable: true, get: function () {
                    return SESServiceException_1.SESServiceException;
                }
            });


            /***/
        }),
        /* 663 */,
        /* 664 */,
        /* 665 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            const usm = __webpack_require__(840);

            exports.implementation = class URLImpl {
                constructor(constructorArgs) {
                    const url = constructorArgs[0];
                    const base = constructorArgs[1];

                    let parsedBase = null;
                    if (base !== undefined) {
                        parsedBase = usm.basicURLParse(base);
                        if (parsedBase === "failure") {
                            throw new TypeError("Invalid base URL");
                        }
                    }

                    const parsedURL = usm.basicURLParse(url, {baseURL: parsedBase});
                    if (parsedURL === "failure") {
                        throw new TypeError("Invalid URL");
                    }

                    this._url = parsedURL;

                    // TODO: query stuff
                }

                get href() {
                    return usm.serializeURL(this._url);
                }

                set href(v) {
                    const parsedURL = usm.basicURLParse(v);
                    if (parsedURL === "failure") {
                        throw new TypeError("Invalid URL");
                    }

                    this._url = parsedURL;
                }

                get origin() {
                    return usm.serializeURLOrigin(this._url);
                }

                get protocol() {
                    return this._url.scheme + ":";
                }

                set protocol(v) {
                    usm.basicURLParse(v + ":", {url: this._url, stateOverride: "scheme start"});
                }

                get username() {
                    return this._url.username;
                }

                set username(v) {
                    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                        return;
                    }

                    usm.setTheUsername(this._url, v);
                }

                get password() {
                    return this._url.password;
                }

                set password(v) {
                    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                        return;
                    }

                    usm.setThePassword(this._url, v);
                }

                get host() {
                    const url = this._url;

                    if (url.host === null) {
                        return "";
                    }

                    if (url.port === null) {
                        return usm.serializeHost(url.host);
                    }

                    return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
                }

                set host(v) {
                    if (this._url.cannotBeABaseURL) {
                        return;
                    }

                    usm.basicURLParse(v, {url: this._url, stateOverride: "host"});
                }

                get hostname() {
                    if (this._url.host === null) {
                        return "";
                    }

                    return usm.serializeHost(this._url.host);
                }

                set hostname(v) {
                    if (this._url.cannotBeABaseURL) {
                        return;
                    }

                    usm.basicURLParse(v, {url: this._url, stateOverride: "hostname"});
                }

                get port() {
                    if (this._url.port === null) {
                        return "";
                    }

                    return usm.serializeInteger(this._url.port);
                }

                set port(v) {
                    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                        return;
                    }

                    if (v === "") {
                        this._url.port = null;
                    } else {
                        usm.basicURLParse(v, {url: this._url, stateOverride: "port"});
                    }
                }

                get pathname() {
                    if (this._url.cannotBeABaseURL) {
                        return this._url.path[0];
                    }

                    if (this._url.path.length === 0) {
                        return "";
                    }

                    return "/" + this._url.path.join("/");
                }

                set pathname(v) {
                    if (this._url.cannotBeABaseURL) {
                        return;
                    }

                    this._url.path = [];
                    usm.basicURLParse(v, {url: this._url, stateOverride: "path start"});
                }

                get search() {
                    if (this._url.query === null || this._url.query === "") {
                        return "";
                    }

                    return "?" + this._url.query;
                }

                set search(v) {
                    // TODO: query stuff

                    const url = this._url;

                    if (v === "") {
                        url.query = null;
                        return;
                    }

                    const input = v[0] === "?" ? v.substring(1) : v;
                    url.query = "";
                    usm.basicURLParse(input, {url, stateOverride: "query"});
                }

                get hash() {
                    if (this._url.fragment === null || this._url.fragment === "") {
                        return "";
                    }

                    return "#" + this._url.fragment;
                }

                set hash(v) {
                    if (v === "") {
                        this._url.fragment = null;
                        return;
                    }

                    const input = v[0] === "#" ? v.substring(1) : v;
                    this._url.fragment = "";
                    usm.basicURLParse(input, {url: this._url, stateOverride: "fragment"});
                }

                toJSON() {
                    return this.href;
                }
            };


            /***/
        }),
        /* 666 */,
        /* 667 */,
        /* 668 */,
        /* 669 */
        /***/ (function (module) {

            module.exports = require("util");

            /***/
        }),
        /* 670 */
        /***/ (function (module) {

            module.exports = require("buffer");

            /***/
        }),
        /* 671 */,
        /* 672 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CloneReceiptRuleSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CloneReceiptRuleSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CloneReceiptRuleSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CloneReceiptRuleSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.CloneReceiptRuleSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCloneReceiptRuleSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCloneReceiptRuleSetCommand)(output, context);
                }
            }

            exports.CloneReceiptRuleSetCommand = CloneReceiptRuleSetCommand;


            /***/
        }),
        /* 673 */,
        /* 674 */,
        /* 675 */,
        /* 676 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(67), exports);


            /***/
        }),
        /* 677 */,
        /* 678 */,
        /* 679 */,
        /* 680 */,
        /* 681 */,
        /* 682 */,
        /* 683 */,
        /* 684 */,
        /* 685 */,
        /* 686 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            var net = __webpack_require__(631);
            var tls = __webpack_require__(16);
            var http = __webpack_require__(605);
            var https = __webpack_require__(211);
            var events = __webpack_require__(614);
            var assert = __webpack_require__(59);
            var util = __webpack_require__(669);


            exports.httpOverHttp = httpOverHttp;
            exports.httpsOverHttp = httpsOverHttp;
            exports.httpOverHttps = httpOverHttps;
            exports.httpsOverHttps = httpsOverHttps;


            function httpOverHttp(options) {
                var agent = new TunnelingAgent(options);
                agent.request = http.request;
                return agent;
            }

            function httpsOverHttp(options) {
                var agent = new TunnelingAgent(options);
                agent.request = http.request;
                agent.createSocket = createSecureSocket;
                agent.defaultPort = 443;
                return agent;
            }

            function httpOverHttps(options) {
                var agent = new TunnelingAgent(options);
                agent.request = https.request;
                return agent;
            }

            function httpsOverHttps(options) {
                var agent = new TunnelingAgent(options);
                agent.request = https.request;
                agent.createSocket = createSecureSocket;
                agent.defaultPort = 443;
                return agent;
            }


            function TunnelingAgent(options) {
                var self = this;
                self.options = options || {};
                self.proxyOptions = self.options.proxy || {};
                self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
                self.requests = [];
                self.sockets = [];

                self.on('free', function onFree(socket, host, port, localAddress) {
                    var options = toOptions(host, port, localAddress);
                    for (var i = 0, len = self.requests.length; i < len; ++i) {
                        var pending = self.requests[i];
                        if (pending.host === options.host && pending.port === options.port) {
                            // Detect the request to connect same origin server,
                            // reuse the connection.
                            self.requests.splice(i, 1);
                            pending.request.onSocket(socket);
                            return;
                        }
                    }
                    socket.destroy();
                    self.removeSocket(socket);
                });
            }

            util.inherits(TunnelingAgent, events.EventEmitter);

            TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
                var self = this;
                var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

                if (self.sockets.length >= this.maxSockets) {
                    // We are over limit so we'll add it to the queue.
                    self.requests.push(options);
                    return;
                }

                // If we are under maxSockets create a new one.
                self.createSocket(options, function (socket) {
                    socket.on('free', onFree);
                    socket.on('close', onCloseOrRemove);
                    socket.on('agentRemove', onCloseOrRemove);
                    req.onSocket(socket);

                    function onFree() {
                        self.emit('free', socket, options);
                    }

                    function onCloseOrRemove(err) {
                        self.removeSocket(socket);
                        socket.removeListener('free', onFree);
                        socket.removeListener('close', onCloseOrRemove);
                        socket.removeListener('agentRemove', onCloseOrRemove);
                    }
                });
            };

            TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
                var self = this;
                var placeholder = {};
                self.sockets.push(placeholder);

                var connectOptions = mergeOptions({}, self.proxyOptions, {
                    method: 'CONNECT',
                    path: options.host + ':' + options.port,
                    agent: false,
                    headers: {
                        host: options.host + ':' + options.port
                    }
                });
                if (options.localAddress) {
                    connectOptions.localAddress = options.localAddress;
                }
                if (connectOptions.proxyAuth) {
                    connectOptions.headers = connectOptions.headers || {};
                    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
                        new Buffer(connectOptions.proxyAuth).toString('base64');
                }

                debug('making CONNECT request');
                var connectReq = self.request(connectOptions);
                connectReq.useChunkedEncodingByDefault = false; // for v0.6
                connectReq.once('response', onResponse); // for v0.6
                connectReq.once('upgrade', onUpgrade);   // for v0.6
                connectReq.once('connect', onConnect);   // for v0.7 or later
                connectReq.once('error', onError);
                connectReq.end();

                function onResponse(res) {
                    // Very hacky. This is necessary to avoid http-parser leaks.
                    res.upgrade = true;
                }

                function onUpgrade(res, socket, head) {
                    // Hacky.
                    process.nextTick(function () {
                        onConnect(res, socket, head);
                    });
                }

                function onConnect(res, socket, head) {
                    connectReq.removeAllListeners();
                    socket.removeAllListeners();

                    if (res.statusCode !== 200) {
                        debug('tunneling socket could not be established, statusCode=%d',
                            res.statusCode);
                        socket.destroy();
                        var error = new Error('tunneling socket could not be established, ' +
                            'statusCode=' + res.statusCode);
                        error.code = 'ECONNRESET';
                        options.request.emit('error', error);
                        self.removeSocket(placeholder);
                        return;
                    }
                    if (head.length > 0) {
                        debug('got illegal response body from proxy');
                        socket.destroy();
                        var error = new Error('got illegal response body from proxy');
                        error.code = 'ECONNRESET';
                        options.request.emit('error', error);
                        self.removeSocket(placeholder);
                        return;
                    }
                    debug('tunneling connection has established');
                    self.sockets[self.sockets.indexOf(placeholder)] = socket;
                    return cb(socket);
                }

                function onError(cause) {
                    connectReq.removeAllListeners();

                    debug('tunneling socket could not be established, cause=%s\n',
                        cause.message, cause.stack);
                    var error = new Error('tunneling socket could not be established, ' +
                        'cause=' + cause.message);
                    error.code = 'ECONNRESET';
                    options.request.emit('error', error);
                    self.removeSocket(placeholder);
                }
            };

            TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
                var pos = this.sockets.indexOf(socket)
                if (pos === -1) {
                    return;
                }
                this.sockets.splice(pos, 1);

                var pending = this.requests.shift();
                if (pending) {
                    // If we have pending requests and a socket gets closed a new one
                    // needs to be created to take over in the pool for the one that closed.
                    this.createSocket(pending, function (socket) {
                        pending.request.onSocket(socket);
                    });
                }
            };

            function createSecureSocket(options, cb) {
                var self = this;
                TunnelingAgent.prototype.createSocket.call(self, options, function (socket) {
                    var hostHeader = options.request.getHeader('host');
                    var tlsOptions = mergeOptions({}, self.options, {
                        socket: socket,
                        servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
                    });

                    // 0 is dummy port for v0.6
                    var secureSocket = tls.connect(0, tlsOptions);
                    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
                    cb(secureSocket);
                });
            }


            function toOptions(host, port, localAddress) {
                if (typeof host === 'string') { // since v0.10
                    return {
                        host: host,
                        port: port,
                        localAddress: localAddress
                    };
                }
                return host; // for v0.11 or later
            }

            function mergeOptions(target) {
                for (var i = 1, len = arguments.length; i < len; ++i) {
                    var overrides = arguments[i];
                    if (typeof overrides === 'object') {
                        var keys = Object.keys(overrides);
                        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
                            var k = keys[j];
                            if (overrides[k] !== undefined) {
                                target[k] = overrides[k];
                            }
                        }
                    }
                }
                return target;
            }


            var debug;
            if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
                debug = function () {
                    var args = Array.prototype.slice.call(arguments);
                    if (typeof args[0] === 'string') {
                        args[0] = 'TUNNEL: ' + args[0];
                    } else {
                        args.unshift('TUNNEL:');
                    }
                    console.error.apply(console, args);
                }
            } else {
                debug = function () {
                };
            }
            exports.debug = debug; // for test


            /***/
        }),
        /* 687 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.STSClient = void 0;
            const config_resolver_1 = __webpack_require__(772);
            const middleware_content_length_1 = __webpack_require__(193);
            const middleware_host_header_1 = __webpack_require__(318);
            const middleware_logger_1 = __webpack_require__(676);
            const middleware_retry_1 = __webpack_require__(806);
            const middleware_sdk_sts_1 = __webpack_require__(352);
            const middleware_user_agent_1 = __webpack_require__(624);
            const smithy_client_1 = __webpack_require__(449);
            const runtimeConfig_1 = __webpack_require__(250);

            class STSClient extends smithy_client_1.Client {
                constructor(configuration) {
                    const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
                    const _config_1 = (0, config_resolver_1.resolveRegionConfig)(_config_0);
                    const _config_2 = (0, config_resolver_1.resolveEndpointsConfig)(_config_1);
                    const _config_3 = (0, middleware_retry_1.resolveRetryConfig)(_config_2);
                    const _config_4 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_3);
                    const _config_5 = (0, middleware_sdk_sts_1.resolveStsAuthConfig)(_config_4, {stsClientCtor: STSClient});
                    const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
                    super(_config_6);
                    this.config = _config_6;
                    this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
                }

                destroy() {
                    super.destroy();
                }
            }

            exports.STSClient = STSClient;


            /***/
        }),
        /* 688 */,
        /* 689 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRuntimeConfig = void 0;
            const url_parser_1 = __webpack_require__(834);
            const endpoints_1 = __webpack_require__(72);
            const getRuntimeConfig = (config) => {
                var _a, _b, _c, _d, _e;
                return ({
                    apiVersion: "2010-12-01",
                    disableHostPrefix: (_a = config === null || config === void 0 ? void 0 : config.disableHostPrefix) !== null && _a !== void 0 ? _a : false,
                    logger: (_b = config === null || config === void 0 ? void 0 : config.logger) !== null && _b !== void 0 ? _b : {},
                    regionInfoProvider: (_c = config === null || config === void 0 ? void 0 : config.regionInfoProvider) !== null && _c !== void 0 ? _c : endpoints_1.defaultRegionInfoProvider,
                    serviceId: (_d = config === null || config === void 0 ? void 0 : config.serviceId) !== null && _d !== void 0 ? _d : "SES",
                    urlParser: (_e = config === null || config === void 0 ? void 0 : config.urlParser) !== null && _e !== void 0 ? _e : url_parser_1.parseUrl,
                });
            };
            exports.getRuntimeConfig = getRuntimeConfig;


            /***/
        }),
        /* 690 */,
        /* 691 */,
        /* 692 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                Object.defineProperty(o, k2, {
                    enumerable: true, get: function () {
                        return m[k];
                    }
                });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", {enumerable: true, value: v});
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
            const httpClient = __importStar(__webpack_require__(368));

            function getAuthString(token, options) {
                if (!token && !options.auth) {
                    throw new Error('Parameter token or opts.auth is required');
                } else if (token && options.auth) {
                    throw new Error('Parameters token and opts.auth may not both be specified');
                }
                return typeof options.auth === 'string' ? options.auth : `token ${token}`;
            }

            exports.getAuthString = getAuthString;

            function getProxyAgent(destinationUrl) {
                const hc = new httpClient.HttpClient();
                return hc.getAgent(destinationUrl);
            }

            exports.getProxyAgent = getProxyAgent;

            function getApiBaseUrl() {
                return process.env['GITHUB_API_URL'] || 'https://api.github.com';
            }

            exports.getApiBaseUrl = getApiBaseUrl;
//# sourceMappingURL=utils.js.map

            /***/
        }),
        /* 693 */,
        /* 694 */,
        /* 695 */
        /***/ (function (module) {

            module.exports = removeHook;

            function removeHook(state, name, method) {
                if (!state.registry[name]) {
                    return;
                }

                var index = state.registry[name]
                    .map(function (registered) {
                        return registered.orig;
                    })
                    .indexOf(method);

                if (index === -1) {
                    return;
                }

                state.registry[name].splice(index, 1);
            }


            /***/
        }),
        /* 696 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 697 */,
        /* 698 */,
        /* 699 */
        /***/ (function (module) {

            module.exports = {"amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": "\""};

            /***/
        }),
        /* 700 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
            const defaultStsRoleAssumers_1 = __webpack_require__(34);
            const STSClient_1 = __webpack_require__(687);
            const getDefaultRoleAssumer = (stsOptions = {}) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumer)(stsOptions, STSClient_1.STSClient);
            exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
            const getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumerWithWebIdentity)(stsOptions, STSClient_1.STSClient);
            exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
            const decorateDefaultCredentialProvider = (provider) => (input) => provider({
                roleAssumer: (0, exports.getDefaultRoleAssumer)(input),
                roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input),
                ...input,
            });
            exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


            /***/
        }),
        /* 701 */,
        /* 702 */,
        /* 703 */,
        /* 704 */
        /***/ (function (module) {

            module.exports = {
                "126": {"host": "smtp.126.com", "port": 465, "secure": true},
                "163": {"host": "smtp.163.com", "port": 465, "secure": true},
                "1und1": {"host": "smtp.1und1.de", "port": 465, "secure": true, "authMethod": "LOGIN"},
                "AOL": {"domains": ["aol.com"], "host": "smtp.aol.com", "port": 587},
                "DebugMail": {"host": "debugmail.io", "port": 25},
                "DynectEmail": {"aliases": ["Dynect"], "host": "smtp.dynect.net", "port": 25},
                "Ethereal": {"aliases": ["ethereal.email"], "host": "smtp.ethereal.email", "port": 587},
                "FastMail": {"domains": ["fastmail.fm"], "host": "smtp.fastmail.com", "port": 465, "secure": true},
                "GandiMail": {"aliases": ["Gandi", "Gandi Mail"], "host": "mail.gandi.net", "port": 587},
                "Gmail": {
                    "aliases": ["Google Mail"],
                    "domains": ["gmail.com", "googlemail.com"],
                    "host": "smtp.gmail.com",
                    "port": 465,
                    "secure": true
                },
                "Godaddy": {"host": "smtpout.secureserver.net", "port": 25},
                "GodaddyAsia": {"host": "smtp.asia.secureserver.net", "port": 25},
                "GodaddyEurope": {"host": "smtp.europe.secureserver.net", "port": 25},
                "hot.ee": {"host": "mail.hot.ee"},
                "Hotmail": {
                    "aliases": ["Outlook", "Outlook.com", "Hotmail.com"],
                    "domains": ["hotmail.com", "outlook.com"],
                    "host": "smtp-mail.outlook.com",
                    "port": 587
                },
                "iCloud": {
                    "aliases": ["Me", "Mac"],
                    "domains": ["me.com", "mac.com"],
                    "host": "smtp.mail.me.com",
                    "port": 587
                },
                "Infomaniak": {
                    "host": "mail.infomaniak.com",
                    "domains": ["ik.me", "ikmail.com", "etik.com"],
                    "port": 587
                },
                "mail.ee": {"host": "smtp.mail.ee"},
                "Mail.ru": {"host": "smtp.mail.ru", "port": 465, "secure": true},
                "Maildev": {"port": 1025, "ignoreTLS": true},
                "Mailgun": {"host": "smtp.mailgun.org", "port": 465, "secure": true},
                "Mailjet": {"host": "in.mailjet.com", "port": 587},
                "Mailosaur": {"host": "mailosaur.io", "port": 25},
                "Mailtrap": {"host": "smtp.mailtrap.io", "port": 2525},
                "Mandrill": {"host": "smtp.mandrillapp.com", "port": 587},
                "Naver": {"host": "smtp.naver.com", "port": 587},
                "One": {"host": "send.one.com", "port": 465, "secure": true},
                "OpenMailBox": {
                    "aliases": ["OMB", "openmailbox.org"],
                    "host": "smtp.openmailbox.org",
                    "port": 465,
                    "secure": true
                },
                "Outlook365": {"host": "smtp.office365.com", "port": 587, "secure": false},
                "OhMySMTP": {"host": "smtp.ohmysmtp.com", "port": 587, "secure": false},
                "Postmark": {"aliases": ["PostmarkApp"], "host": "smtp.postmarkapp.com", "port": 2525},
                "qiye.aliyun": {"host": "smtp.mxhichina.com", "port": "465", "secure": true},
                "QQ": {"domains": ["qq.com"], "host": "smtp.qq.com", "port": 465, "secure": true},
                "QQex": {
                    "aliases": ["QQ Enterprise"],
                    "domains": ["exmail.qq.com"],
                    "host": "smtp.exmail.qq.com",
                    "port": 465,
                    "secure": true
                },
                "SendCloud": {"host": "smtpcloud.sohu.com", "port": 25},
                "SendGrid": {"host": "smtp.sendgrid.net", "port": 587},
                "SendinBlue": {"host": "smtp-relay.sendinblue.com", "port": 587},
                "SendPulse": {"host": "smtp-pulse.com", "port": 465, "secure": true},
                "SES": {"host": "email-smtp.us-east-1.amazonaws.com", "port": 465, "secure": true},
                "SES-US-EAST-1": {"host": "email-smtp.us-east-1.amazonaws.com", "port": 465, "secure": true},
                "SES-US-WEST-2": {"host": "email-smtp.us-west-2.amazonaws.com", "port": 465, "secure": true},
                "SES-EU-WEST-1": {"host": "email-smtp.eu-west-1.amazonaws.com", "port": 465, "secure": true},
                "Sparkpost": {
                    "aliases": ["SparkPost", "SparkPost Mail"],
                    "domains": ["sparkpost.com"],
                    "host": "smtp.sparkpostmail.com",
                    "port": 587,
                    "secure": false
                },
                "Tipimail": {"host": "smtp.tipimail.com", "port": 587},
                "Yahoo": {"domains": ["yahoo.com"], "host": "smtp.mail.yahoo.com", "port": 465, "secure": true},
                "Yandex": {"domains": ["yandex.ru"], "host": "smtp.yandex.ru", "port": 465, "secure": true},
                "Zoho": {"host": "smtp.zoho.com", "port": 465, "secure": true, "authMethod": "LOGIN"}
            };

            /***/
        }),
        /* 705 */,
        /* 706 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(567), exports);
            tslib_1.__exportStar(__webpack_require__(323), exports);
            tslib_1.__exportStar(__webpack_require__(478), exports);
            tslib_1.__exportStar(__webpack_require__(764), exports);
            tslib_1.__exportStar(__webpack_require__(928), exports);
            tslib_1.__exportStar(__webpack_require__(931), exports);
            tslib_1.__exportStar(__webpack_require__(952), exports);


            /***/
        }),
        /* 707 */,
        /* 708 */,
        /* 709 */,
        /* 710 */,
        /* 711 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteReceiptRuleSetCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteReceiptRuleSetCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteReceiptRuleSetCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteReceiptRuleSetRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteReceiptRuleSetResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteReceiptRuleSetCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteReceiptRuleSetCommand)(output, context);
                }
            }

            exports.DeleteReceiptRuleSetCommand = DeleteReceiptRuleSetCommand;


            /***/
        }),
        /* 712 */,
        /* 713 */,
        /* 714 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.AdaptiveRetryStrategy = void 0;
            const config_1 = __webpack_require__(168);
            const DefaultRateLimiter_1 = __webpack_require__(74);
            const StandardRetryStrategy_1 = __webpack_require__(185);

            class AdaptiveRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
                constructor(maxAttemptsProvider, options) {
                    const {rateLimiter, ...superOptions} = options !== null && options !== void 0 ? options : {};
                    super(maxAttemptsProvider, superOptions);
                    this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new DefaultRateLimiter_1.DefaultRateLimiter();
                    this.mode = config_1.RETRY_MODES.ADAPTIVE;
                }

                async retry(next, args) {
                    return super.retry(next, args, {
                        beforeRequest: async () => {
                            return this.rateLimiter.getSendToken();
                        },
                        afterRequest: (response) => {
                            this.rateLimiter.updateClientSendingRate(response);
                        },
                    });
                }
            }

            exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


            /***/
        }),
        /* 715 */,
        /* 716 */,
        /* 717 */,
        /* 718 */,
        /* 719 */,
        /* 720 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(903), exports);
            tslib_1.__exportStar(__webpack_require__(27), exports);
            tslib_1.__exportStar(__webpack_require__(397), exports);


            /***/
        }),
        /* 721 */,
        /* 722 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.escapeUriPath = void 0;
            const escape_uri_1 = __webpack_require__(162);
            const escapeUriPath = (uri) => uri.split("/").map(escape_uri_1.escapeUri).join("/");
            exports.escapeUriPath = escapeUriPath;


            /***/
        }),
        /* 723 */,
        /* 724 */,
        /* 725 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(817), exports);
            tslib_1.__exportStar(__webpack_require__(120), exports);


            /***/
        }),
        /* 726 */,
        /* 727 */,
        /* 728 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.prepareRequest = void 0;
            const cloneRequest_1 = __webpack_require__(445);
            const constants_1 = __webpack_require__(70);
            const prepareRequest = (request) => {
                request = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
                for (const headerName of Object.keys(request.headers)) {
                    if (constants_1.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
                        delete request.headers[headerName];
                    }
                }
                return request;
            };
            exports.prepareRequest = prepareRequest;


            /***/
        }),
        /* 729 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.parseQueryString = void 0;

            function parseQueryString(querystring) {
                const query = {};
                querystring = querystring.replace(/^\?/, "");
                if (querystring) {
                    for (const pair of querystring.split("&")) {
                        let [key, value = null] = pair.split("=");
                        key = decodeURIComponent(key);
                        if (value) {
                            value = decodeURIComponent(value);
                        }
                        if (!(key in query)) {
                            query[key] = value;
                        } else if (Array.isArray(query[key])) {
                            query[key].push(value);
                        } else {
                            query[key] = [query[key], value];
                        }
                    }
                }
                return query;
            }

            exports.parseQueryString = parseQueryString;


            /***/
        }),
        /* 730 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.HttpRequest = void 0;

            class HttpRequest {
                constructor(options) {
                    this.method = options.method || "GET";
                    this.hostname = options.hostname || "localhost";
                    this.port = options.port;
                    this.query = options.query || {};
                    this.headers = options.headers || {};
                    this.body = options.body;
                    this.protocol = options.protocol
                        ? options.protocol.substr(-1) !== ":"
                            ? `${options.protocol}:`
                            : options.protocol
                        : "https:";
                    this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
                }

                static isInstance(request) {
                    if (!request)
                        return false;
                    const req = request;
                    return ("method" in req &&
                        "protocol" in req &&
                        "hostname" in req &&
                        "path" in req &&
                        typeof req["query"] === "object" &&
                        typeof req["headers"] === "object");
                }

                clone() {
                    const cloned = new HttpRequest({
                        ...this,
                        headers: {...this.headers},
                    });
                    if (cloned.query)
                        cloned.query = cloneQuery(cloned.query);
                    return cloned;
                }
            }

            exports.HttpRequest = HttpRequest;

            function cloneQuery(query) {
                return Object.keys(query).reduce((carry, paramName) => {
                    const param = query[paramName];
                    return {
                        ...carry,
                        [paramName]: Array.isArray(param) ? [...param] : param,
                    };
                }, {});
            }


            /***/
        }),
        /* 731 */,
        /* 732 */,
        /* 733 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const punycode = __webpack_require__(213);
            const mimeFuncs = __webpack_require__(103);
            const crypto = __webpack_require__(417);

            /**
             * Returns DKIM signature header line
             *
             * @param {Object} headers Parsed headers object from MessageParser
             * @param {String} bodyHash Base64 encoded hash of the message
             * @param {Object} options DKIM options
             * @param {String} options.domainName Domain name to be signed for
             * @param {String} options.keySelector DKIM key selector to use
             * @param {String} options.privateKey DKIM private key to use
             * @return {String} Complete header line
             */

            module.exports = (headers, hashAlgo, bodyHash, options) => {
                options = options || {};

                // all listed fields from RFC4871 #5.5
                let defaultFieldNames =
                    'From:Sender:Reply-To:Subject:Date:Message-ID:To:' +
                    'Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:' +
                    'Content-Description:Resent-Date:Resent-From:Resent-Sender:' +
                    'Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:' +
                    'List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:' +
                    'List-Owner:List-Archive';

                let fieldNames = options.headerFieldNames || defaultFieldNames;

                let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
                let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);

                let signer, signature;

                canonicalizedHeaderData.headers += 'dkim-signature:' + relaxedHeaderLine(dkimHeader);

                signer = crypto.createSign(('rsa-' + hashAlgo).toUpperCase());
                signer.update(canonicalizedHeaderData.headers);
                try {
                    signature = signer.sign(options.privateKey, 'base64');
                } catch (E) {
                    return false;
                }

                return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, '$&\r\n ').trim();
            };

            module.exports.relaxedHeaders = relaxedHeaders;

            function generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
                let dkim = [
                    'v=1',
                    'a=rsa-' + hashAlgo,
                    'c=relaxed/relaxed',
                    'd=' + punycode.toASCII(domainName),
                    'q=dns/txt',
                    's=' + keySelector,
                    'bh=' + bodyHash,
                    'h=' + fieldNames
                ].join('; ');

                return mimeFuncs.foldLines('DKIM-Signature: ' + dkim, 76) + ';\r\n b=';
            }

            function relaxedHeaders(headers, fieldNames, skipFields) {
                let includedFields = new Set();
                let skip = new Set();
                let headerFields = new Map();

                (skipFields || '')
                    .toLowerCase()
                    .split(':')
                    .forEach(field => {
                        skip.add(field.trim());
                    });

                (fieldNames || '')
                    .toLowerCase()
                    .split(':')
                    .filter(field => !skip.has(field.trim()))
                    .forEach(field => {
                        includedFields.add(field.trim());
                    });

                for (let i = headers.length - 1; i >= 0; i--) {
                    let line = headers[i];
                    // only include the first value from bottom to top
                    if (includedFields.has(line.key) && !headerFields.has(line.key)) {
                        headerFields.set(line.key, relaxedHeaderLine(line.line));
                    }
                }

                let headersList = [];
                let fields = [];
                includedFields.forEach(field => {
                    if (headerFields.has(field)) {
                        fields.push(field);
                        headersList.push(field + ':' + headerFields.get(field));
                    }
                });

                return {
                    headers: headersList.join('\r\n') + '\r\n',
                    fieldNames: fields.join(':')
                };
            }

            function relaxedHeaderLine(line) {
                return line
                    .substr(line.indexOf(':') + 1)
                    .replace(/\r?\n/g, '')
                    .replace(/\s+/g, ' ')
                    .trim();
            }


            /***/
        }),
        /* 734 */,
        /* 735 */,
        /* 736 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveSigV4AuthConfig = exports.resolveAwsAuthConfig = void 0;
            const property_provider_1 = __webpack_require__(118);
            const signature_v4_1 = __webpack_require__(159);
            const CREDENTIAL_EXPIRE_WINDOW = 300000;
            const resolveAwsAuthConfig = (input) => {
                const normalizedCreds = input.credentials
                    ? normalizeCredentialProvider(input.credentials)
                    : input.credentialDefaultProvider(input);
                const {signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256} = input;
                let signer;
                if (input.signer) {
                    signer = normalizeProvider(input.signer);
                } else {
                    signer = () => normalizeProvider(input.region)()
                        .then(async (region) => [
                            (await input.regionInfoProvider(region, {
                                useFipsEndpoint: await input.useFipsEndpoint(),
                                useDualstackEndpoint: await input.useDualstackEndpoint(),
                            })) || {},
                            region,
                        ])
                        .then(([regionInfo, region]) => {
                            const {signingRegion, signingService} = regionInfo;
                            input.signingRegion = input.signingRegion || signingRegion || region;
                            input.signingName = input.signingName || signingService || input.serviceId;
                            const params = {
                                ...input,
                                credentials: normalizedCreds,
                                region: input.signingRegion,
                                service: input.signingName,
                                sha256,
                                uriEscapePath: signingEscapePath,
                            };
                            const signerConstructor = input.signerConstructor || signature_v4_1.SignatureV4;
                            return new signerConstructor(params);
                        });
                }
                return {
                    ...input,
                    systemClockOffset,
                    signingEscapePath,
                    credentials: normalizedCreds,
                    signer,
                };
            };
            exports.resolveAwsAuthConfig = resolveAwsAuthConfig;
            const resolveSigV4AuthConfig = (input) => {
                const normalizedCreds = input.credentials
                    ? normalizeCredentialProvider(input.credentials)
                    : input.credentialDefaultProvider(input);
                const {signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256} = input;
                let signer;
                if (input.signer) {
                    signer = normalizeProvider(input.signer);
                } else {
                    signer = normalizeProvider(new signature_v4_1.SignatureV4({
                        credentials: normalizedCreds,
                        region: input.region,
                        service: input.signingName,
                        sha256,
                        uriEscapePath: signingEscapePath,
                    }));
                }
                return {
                    ...input,
                    systemClockOffset,
                    signingEscapePath,
                    credentials: normalizedCreds,
                    signer,
                };
            };
            exports.resolveSigV4AuthConfig = resolveSigV4AuthConfig;
            const normalizeProvider = (input) => {
                if (typeof input === "object") {
                    const promisified = Promise.resolve(input);
                    return () => promisified;
                }
                return input;
            };
            const normalizeCredentialProvider = (credentials) => {
                if (typeof credentials === "function") {
                    return (0, property_provider_1.memoize)(credentials, (credentials) => credentials.expiration !== undefined &&
                        credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials) => credentials.expiration !== undefined);
                }
                return normalizeProvider(credentials);
            };


            /***/
        }),
        /* 737 */,
        /* 738 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRuntimeConfig = void 0;
            const url_parser_1 = __webpack_require__(834);
            const endpoints_1 = __webpack_require__(658);
            const getRuntimeConfig = (config) => {
                var _a, _b, _c, _d, _e;
                return ({
                    apiVersion: "2011-06-15",
                    disableHostPrefix: (_a = config === null || config === void 0 ? void 0 : config.disableHostPrefix) !== null && _a !== void 0 ? _a : false,
                    logger: (_b = config === null || config === void 0 ? void 0 : config.logger) !== null && _b !== void 0 ? _b : {},
                    regionInfoProvider: (_c = config === null || config === void 0 ? void 0 : config.regionInfoProvider) !== null && _c !== void 0 ? _c : endpoints_1.defaultRegionInfoProvider,
                    serviceId: (_d = config === null || config === void 0 ? void 0 : config.serviceId) !== null && _d !== void 0 ? _d : "STS",
                    urlParser: (_e = config === null || config === void 0 ? void 0 : config.urlParser) !== null && _e !== void 0 ? _e : url_parser_1.parseUrl,
                });
            };
            exports.getRuntimeConfig = getRuntimeConfig;


            /***/
        }),
        /* 739 */,
        /* 740 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(905), exports);
            tslib_1.__exportStar(__webpack_require__(591), exports);


            /***/
        }),
        /* 741 */,
        /* 742 */,
        /* 743 */,
        /* 744 */,
        /* 745 */,
        /* 746 */,
        /* 747 */
        /***/ (function (module) {

            module.exports = require("fs");

            /***/
        }),
        /* 748 */,
        /* 749 */,
        /* 750 */,
        /* 751 */,
        /* 752 */,
        /* 753 */,
        /* 754 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.UpdateReceiptRuleCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class UpdateReceiptRuleCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "UpdateReceiptRuleCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.UpdateReceiptRuleRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.UpdateReceiptRuleResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryUpdateReceiptRuleCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryUpdateReceiptRuleCommand)(output, context);
                }
            }

            exports.UpdateReceiptRuleCommand = UpdateReceiptRuleCommand;


            /***/
        }),
        /* 755 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const Transform = __webpack_require__(413).Transform;

            class LastNewline extends Transform {
                constructor() {
                    super();
                    this.lastByte = false;
                }

                _transform(chunk, encoding, done) {
                    if (chunk.length) {
                        this.lastByte = chunk[chunk.length - 1];
                    }

                    this.push(chunk);
                    done();
                }

                _flush(done) {
                    if (this.lastByte === 0x0a) {
                        return done();
                    }
                    if (this.lastByte === 0x0d) {
                        this.push(Buffer.from('\n'));
                        return done();
                    }
                    this.push(Buffer.from('\r\n'));
                    return done();
                }
            }

            module.exports = LastNewline;


            /***/
        }),
        /* 756 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetTemplateResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetTemplateCommand)(output, context);
                }
            }

            exports.GetTemplateCommand = GetTemplateCommand;


            /***/
        }),
        /* 757 */,
        /* 758 */,
        /* 759 */,
        /* 760 */,
        /* 761 */
        /***/ (function (module) {

            module.exports = require("zlib");

            /***/
        }),
        /* 762 */,
        /* 763 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            const VERSION = "2.17.0";

            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);

                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);

                    if (enumerableOnly) {
                        symbols = symbols.filter(function (sym) {
                            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                        });
                    }

                    keys.push.apply(keys, symbols);
                }

                return keys;
            }

            function _objectSpread2(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};

                    if (i % 2) {
                        ownKeys(Object(source), true).forEach(function (key) {
                            _defineProperty(target, key, source[key]);
                        });
                    } else if (Object.getOwnPropertyDescriptors) {
                        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                    } else {
                        ownKeys(Object(source)).forEach(function (key) {
                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                        });
                    }
                }

                return target;
            }

            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }

                return obj;
            }

            /**
             * Some list response that can be paginated have a different response structure
             *
             * They have a `total_count` key in the response (search also has `incomplete_results`,
             * /installation/repositories also has `repository_selection`), as well as a key with
             * the list of the items which name varies from endpoint to endpoint.
             *
             * Octokit normalizes these responses so that paginated results are always returned following
             * the same structure. One challenge is that if the list response has only one page, no Link
             * header is provided, so this header alone is not sufficient to check wether a response is
             * paginated or not.
             *
             * We check if a "total_count" key is present in the response data, but also make sure that
             * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
             * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
             */
            function normalizePaginatedListResponse(response) {
                // endpoints can respond with 204 if repository is empty
                if (!response.data) {
                    return _objectSpread2(_objectSpread2({}, response), {}, {
                        data: []
                    });
                }

                const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
                if (!responseNeedsNormalization) return response; // keep the additional properties intact as there is currently no other way
                // to retrieve the same information.

                const incompleteResults = response.data.incomplete_results;
                const repositorySelection = response.data.repository_selection;
                const totalCount = response.data.total_count;
                delete response.data.incomplete_results;
                delete response.data.repository_selection;
                delete response.data.total_count;
                const namespaceKey = Object.keys(response.data)[0];
                const data = response.data[namespaceKey];
                response.data = data;

                if (typeof incompleteResults !== "undefined") {
                    response.data.incomplete_results = incompleteResults;
                }

                if (typeof repositorySelection !== "undefined") {
                    response.data.repository_selection = repositorySelection;
                }

                response.data.total_count = totalCount;
                return response;
            }

            function iterator(octokit, route, parameters) {
                const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
                const requestMethod = typeof route === "function" ? route : octokit.request;
                const method = options.method;
                const headers = options.headers;
                let url = options.url;
                return {
                    [Symbol.asyncIterator]: () => ({
                        async next() {
                            if (!url) return {
                                done: true
                            };

                            try {
                                const response = await requestMethod({
                                    method,
                                    url,
                                    headers
                                });
                                const normalizedResponse = normalizePaginatedListResponse(response); // `response.headers.link` format:
                                // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
                                // sets `url` to undefined if "next" URL is not present or `link` header is not set

                                url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
                                return {
                                    value: normalizedResponse
                                };
                            } catch (error) {
                                if (error.status !== 409) throw error;
                                url = "";
                                return {
                                    value: {
                                        status: 200,
                                        headers: {},
                                        data: []
                                    }
                                };
                            }
                        }

                    })
                };
            }

            function paginate(octokit, route, parameters, mapFn) {
                if (typeof parameters === "function") {
                    mapFn = parameters;
                    parameters = undefined;
                }

                return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
            }

            function gather(octokit, results, iterator, mapFn) {
                return iterator.next().then(result => {
                    if (result.done) {
                        return results;
                    }

                    let earlyExit = false;

                    function done() {
                        earlyExit = true;
                    }

                    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);

                    if (earlyExit) {
                        return results;
                    }

                    return gather(octokit, results, iterator, mapFn);
                });
            }

            const composePaginateRest = Object.assign(paginate, {
                iterator
            });

            const paginatingEndpoints = ["GET /app/hook/deliveries", "GET /app/installations", "GET /applications/grants", "GET /authorizations", "GET /enterprises/{enterprise}/actions/permissions/organizations", "GET /enterprises/{enterprise}/actions/runner-groups", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners", "GET /enterprises/{enterprise}/actions/runners", "GET /enterprises/{enterprise}/actions/runners/downloads", "GET /events", "GET /gists", "GET /gists/public", "GET /gists/starred", "GET /gists/{gist_id}/comments", "GET /gists/{gist_id}/commits", "GET /gists/{gist_id}/forks", "GET /installation/repositories", "GET /issues", "GET /marketplace_listing/plans", "GET /marketplace_listing/plans/{plan_id}/accounts", "GET /marketplace_listing/stubbed/plans", "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts", "GET /networks/{owner}/{repo}/events", "GET /notifications", "GET /organizations", "GET /orgs/{org}/actions/permissions/repositories", "GET /orgs/{org}/actions/runner-groups", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners", "GET /orgs/{org}/actions/runners", "GET /orgs/{org}/actions/runners/downloads", "GET /orgs/{org}/actions/secrets", "GET /orgs/{org}/actions/secrets/{secret_name}/repositories", "GET /orgs/{org}/blocks", "GET /orgs/{org}/credential-authorizations", "GET /orgs/{org}/events", "GET /orgs/{org}/failed_invitations", "GET /orgs/{org}/hooks", "GET /orgs/{org}/hooks/{hook_id}/deliveries", "GET /orgs/{org}/installations", "GET /orgs/{org}/invitations", "GET /orgs/{org}/invitations/{invitation_id}/teams", "GET /orgs/{org}/issues", "GET /orgs/{org}/members", "GET /orgs/{org}/migrations", "GET /orgs/{org}/migrations/{migration_id}/repositories", "GET /orgs/{org}/outside_collaborators", "GET /orgs/{org}/packages", "GET /orgs/{org}/projects", "GET /orgs/{org}/public_members", "GET /orgs/{org}/repos", "GET /orgs/{org}/secret-scanning/alerts", "GET /orgs/{org}/team-sync/groups", "GET /orgs/{org}/teams", "GET /orgs/{org}/teams/{team_slug}/discussions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/invitations", "GET /orgs/{org}/teams/{team_slug}/members", "GET /orgs/{org}/teams/{team_slug}/projects", "GET /orgs/{org}/teams/{team_slug}/repos", "GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings", "GET /orgs/{org}/teams/{team_slug}/teams", "GET /projects/columns/{column_id}/cards", "GET /projects/{project_id}/collaborators", "GET /projects/{project_id}/columns", "GET /repos/{owner}/{repo}/actions/artifacts", "GET /repos/{owner}/{repo}/actions/runners", "GET /repos/{owner}/{repo}/actions/runners/downloads", "GET /repos/{owner}/{repo}/actions/runs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs", "GET /repos/{owner}/{repo}/actions/secrets", "GET /repos/{owner}/{repo}/actions/workflows", "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs", "GET /repos/{owner}/{repo}/assignees", "GET /repos/{owner}/{repo}/autolinks", "GET /repos/{owner}/{repo}/branches", "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations", "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs", "GET /repos/{owner}/{repo}/code-scanning/alerts", "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", "GET /repos/{owner}/{repo}/code-scanning/analyses", "GET /repos/{owner}/{repo}/collaborators", "GET /repos/{owner}/{repo}/comments", "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/commits", "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head", "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments", "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", "GET /repos/{owner}/{repo}/commits/{ref}/check-runs", "GET /repos/{owner}/{repo}/commits/{ref}/check-suites", "GET /repos/{owner}/{repo}/commits/{ref}/statuses", "GET /repos/{owner}/{repo}/contributors", "GET /repos/{owner}/{repo}/deployments", "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses", "GET /repos/{owner}/{repo}/events", "GET /repos/{owner}/{repo}/forks", "GET /repos/{owner}/{repo}/git/matching-refs/{ref}", "GET /repos/{owner}/{repo}/hooks", "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries", "GET /repos/{owner}/{repo}/invitations", "GET /repos/{owner}/{repo}/issues", "GET /repos/{owner}/{repo}/issues/comments", "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/issues/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/comments", "GET /repos/{owner}/{repo}/issues/{issue_number}/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/labels", "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", "GET /repos/{owner}/{repo}/keys", "GET /repos/{owner}/{repo}/labels", "GET /repos/{owner}/{repo}/milestones", "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels", "GET /repos/{owner}/{repo}/notifications", "GET /repos/{owner}/{repo}/pages/builds", "GET /repos/{owner}/{repo}/projects", "GET /repos/{owner}/{repo}/pulls", "GET /repos/{owner}/{repo}/pulls/comments", "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments", "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits", "GET /repos/{owner}/{repo}/pulls/{pull_number}/files", "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments", "GET /repos/{owner}/{repo}/releases", "GET /repos/{owner}/{repo}/releases/{release_id}/assets", "GET /repos/{owner}/{repo}/secret-scanning/alerts", "GET /repos/{owner}/{repo}/stargazers", "GET /repos/{owner}/{repo}/subscribers", "GET /repos/{owner}/{repo}/tags", "GET /repos/{owner}/{repo}/teams", "GET /repositories", "GET /repositories/{repository_id}/environments/{environment_name}/secrets", "GET /scim/v2/enterprises/{enterprise}/Groups", "GET /scim/v2/enterprises/{enterprise}/Users", "GET /scim/v2/organizations/{org}/Users", "GET /search/code", "GET /search/commits", "GET /search/issues", "GET /search/labels", "GET /search/repositories", "GET /search/topics", "GET /search/users", "GET /teams/{team_id}/discussions", "GET /teams/{team_id}/discussions/{discussion_number}/comments", "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /teams/{team_id}/discussions/{discussion_number}/reactions", "GET /teams/{team_id}/invitations", "GET /teams/{team_id}/members", "GET /teams/{team_id}/projects", "GET /teams/{team_id}/repos", "GET /teams/{team_id}/team-sync/group-mappings", "GET /teams/{team_id}/teams", "GET /user/blocks", "GET /user/emails", "GET /user/followers", "GET /user/following", "GET /user/gpg_keys", "GET /user/installations", "GET /user/installations/{installation_id}/repositories", "GET /user/issues", "GET /user/keys", "GET /user/marketplace_purchases", "GET /user/marketplace_purchases/stubbed", "GET /user/memberships/orgs", "GET /user/migrations", "GET /user/migrations/{migration_id}/repositories", "GET /user/orgs", "GET /user/packages", "GET /user/public_emails", "GET /user/repos", "GET /user/repository_invitations", "GET /user/starred", "GET /user/subscriptions", "GET /user/teams", "GET /users", "GET /users/{username}/events", "GET /users/{username}/events/orgs/{org}", "GET /users/{username}/events/public", "GET /users/{username}/followers", "GET /users/{username}/following", "GET /users/{username}/gists", "GET /users/{username}/gpg_keys", "GET /users/{username}/keys", "GET /users/{username}/orgs", "GET /users/{username}/packages", "GET /users/{username}/projects", "GET /users/{username}/received_events", "GET /users/{username}/received_events/public", "GET /users/{username}/repos", "GET /users/{username}/starred", "GET /users/{username}/subscriptions"];

            function isPaginatingEndpoint(arg) {
                if (typeof arg === "string") {
                    return paginatingEndpoints.includes(arg);
                } else {
                    return false;
                }
            }

            /**
             * @param octokit Octokit instance
             * @param options Options passed to Octokit constructor
             */

            function paginateRest(octokit) {
                return {
                    paginate: Object.assign(paginate.bind(null, octokit), {
                        iterator: iterator.bind(null, octokit)
                    })
                };
            }

            paginateRest.VERSION = VERSION;

            exports.composePaginateRest = composePaginateRest;
            exports.isPaginatingEndpoint = isPaginatingEndpoint;
            exports.paginateRest = paginateRest;
            exports.paginatingEndpoints = paginatingEndpoints;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 764 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getSSOTokenFromFile = void 0;
            const fs_1 = __webpack_require__(747);
            const getSSOTokenFilepath_1 = __webpack_require__(478);
            const {readFile} = fs_1.promises;
            const getSSOTokenFromFile = async (ssoStartUrl) => {
                const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(ssoStartUrl);
                const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
                return JSON.parse(ssoTokenText);
            };
            exports.getSSOTokenFromFile = getSSOTokenFromFile;


            /***/
        }),
        /* 765 */
        /***/ (function (module) {

            module.exports = require("process");

            /***/
        }),
        /* 766 */
        /***/ (function (module) {

            module.exports = {
                "name": "@aws-sdk/client-sso",
                "description": "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
                "version": "3.56.0",
                "scripts": {
                    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
                    "build:cjs": "tsc -p tsconfig.cjs.json",
                    "build:docs": "typedoc",
                    "build:es": "tsc -p tsconfig.es.json",
                    "build:types": "tsc -p tsconfig.types.json",
                    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
                    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo"
                },
                "main": "./dist-cjs/index.js",
                "types": "./dist-types/index.d.ts",
                "module": "./dist-es/index.js",
                "sideEffects": false,
                "dependencies": {
                    "@aws-crypto/sha256-browser": "2.0.0",
                    "@aws-crypto/sha256-js": "2.0.0",
                    "@aws-sdk/config-resolver": "3.56.0",
                    "@aws-sdk/fetch-http-handler": "3.55.0",
                    "@aws-sdk/hash-node": "3.55.0",
                    "@aws-sdk/invalid-dependency": "3.55.0",
                    "@aws-sdk/middleware-content-length": "3.55.0",
                    "@aws-sdk/middleware-host-header": "3.55.0",
                    "@aws-sdk/middleware-logger": "3.55.0",
                    "@aws-sdk/middleware-retry": "3.56.0",
                    "@aws-sdk/middleware-serde": "3.55.0",
                    "@aws-sdk/middleware-stack": "3.55.0",
                    "@aws-sdk/middleware-user-agent": "3.55.0",
                    "@aws-sdk/node-config-provider": "3.56.0",
                    "@aws-sdk/node-http-handler": "3.55.0",
                    "@aws-sdk/protocol-http": "3.55.0",
                    "@aws-sdk/smithy-client": "3.55.0",
                    "@aws-sdk/types": "3.55.0",
                    "@aws-sdk/url-parser": "3.55.0",
                    "@aws-sdk/util-base64-browser": "3.55.0",
                    "@aws-sdk/util-base64-node": "3.55.0",
                    "@aws-sdk/util-body-length-browser": "3.55.0",
                    "@aws-sdk/util-body-length-node": "3.55.0",
                    "@aws-sdk/util-defaults-mode-browser": "3.55.0",
                    "@aws-sdk/util-defaults-mode-node": "3.56.0",
                    "@aws-sdk/util-user-agent-browser": "3.55.0",
                    "@aws-sdk/util-user-agent-node": "3.56.0",
                    "@aws-sdk/util-utf8-browser": "3.55.0",
                    "@aws-sdk/util-utf8-node": "3.55.0",
                    "tslib": "^2.3.1"
                },
                "devDependencies": {
                    "@aws-sdk/service-client-documentation-generator": "3.55.0",
                    "@tsconfig/recommended": "1.0.1",
                    "@types/node": "^12.7.5",
                    "concurrently": "7.0.0",
                    "downlevel-dts": "0.7.0",
                    "rimraf": "3.0.2",
                    "typedoc": "0.19.2",
                    "typescript": "~4.6.2"
                },
                "engines": {"node": ">=12.0.0"},
                "typesVersions": {"<4.0": {"dist-types/*": ["dist-types/ts3.4/*"]}},
                "files": ["dist-*"],
                "author": {"name": "AWS SDK for JavaScript Team", "url": "https://aws.amazon.com/javascript/"},
                "license": "Apache-2.0",
                "browser": {"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"},
                "react-native": {"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"},
                "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
                "repository": {
                    "type": "git",
                    "url": "https://github.com/aws/aws-sdk-js-v3.git",
                    "directory": "clients/client-sso"
                }
            };

            /***/
        }),
        /* 767 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 768 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin = exports.awsAuthMiddlewareOptions = exports.awsAuthMiddleware = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const getSkewCorrectedDate_1 = __webpack_require__(217);
            const getUpdatedSystemClockOffset_1 = __webpack_require__(450);
            const awsAuthMiddleware = (options) => (next, context) => async function (args) {
                if (!protocol_http_1.HttpRequest.isInstance(args.request))
                    return next(args);
                const signer = await options.signer();
                const output = await next({
                    ...args,
                    request: await signer.sign(args.request, {
                        signingDate: (0, getSkewCorrectedDate_1.getSkewCorrectedDate)(options.systemClockOffset),
                        signingRegion: context["signing_region"],
                        signingService: context["signing_service"],
                    }),
                }).catch((error) => {
                    var _a;
                    const serverTime = (_a = error.ServerTime) !== null && _a !== void 0 ? _a : getDateHeader(error.$response);
                    if (serverTime) {
                        options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(serverTime, options.systemClockOffset);
                    }
                    throw error;
                });
                const dateHeader = getDateHeader(output.response);
                if (dateHeader) {
                    options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(dateHeader, options.systemClockOffset);
                }
                return output;
            };
            exports.awsAuthMiddleware = awsAuthMiddleware;
            const getDateHeader = (response) => {
                var _a, _b, _c;
                return protocol_http_1.HttpResponse.isInstance(response) ? (_b = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.date) !== null && _b !== void 0 ? _b : (_c = response.headers) === null || _c === void 0 ? void 0 : _c.Date : undefined;
            };
            exports.awsAuthMiddlewareOptions = {
                name: "awsAuthMiddleware",
                tags: ["SIGNATURE", "AWSAUTH"],
                relation: "after",
                toMiddleware: "retryMiddleware",
                override: true,
            };
            const getAwsAuthPlugin = (options) => ({
                applyToStack: (clientStack) => {
                    clientStack.addRelativeTo((0, exports.awsAuthMiddleware)(options), exports.awsAuthMiddlewareOptions);
                },
            });
            exports.getAwsAuthPlugin = getAwsAuthPlugin;
            exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin;


            /***/
        }),
        /* 769 */,
        /* 770 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(461), exports);


            /***/
        }),
        /* 771 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _default = '00000000-0000-0000-0000-000000000000';
            exports.default = _default;

            /***/
        }),
        /* 772 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(324), exports);
            tslib_1.__exportStar(__webpack_require__(725), exports);
            tslib_1.__exportStar(__webpack_require__(918), exports);


            /***/
        }),
        /* 773 */,
        /* 774 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getArrayIfSingleItem = void 0;
            const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
            exports.getArrayIfSingleItem = getArrayIfSingleItem;


            /***/
        }),
        /* 775 */,
        /* 776 */,
        /* 777 */,
        /* 778 */,
        /* 779 */,
        /* 780 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(313), exports);
            tslib_1.__exportStar(__webpack_require__(331), exports);


            /***/
        }),
        /* 781 */,
        /* 782 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.paginateListAccountRoles = void 0;
            const ListAccountRolesCommand_1 = __webpack_require__(223);
            const SSO_1 = __webpack_require__(112);
            const SSOClient_1 = __webpack_require__(995);
            const makePagedClientRequest = async (client, input, ...args) => {
                return await client.send(new ListAccountRolesCommand_1.ListAccountRolesCommand(input), ...args);
            };
            const makePagedRequest = async (client, input, ...args) => {
                return await client.listAccountRoles(input, ...args);
            };

            async function* paginateListAccountRoles(config, input, ...additionalArguments) {
                let token = config.startingToken || undefined;
                let hasNext = true;
                let page;
                while (hasNext) {
                    input.nextToken = token;
                    input["maxResults"] = config.pageSize;
                    if (config.client instanceof SSO_1.SSO) {
                        page = await makePagedRequest(config.client, input, ...additionalArguments);
                    } else if (config.client instanceof SSOClient_1.SSOClient) {
                        page = await makePagedClientRequest(config.client, input, ...additionalArguments);
                    } else {
                        throw new Error("Invalid client, expected SSO | SSOClient");
                    }
                    yield page;
                    token = page.nextToken;
                    hasNext = !!token;
                }
                return undefined;
            }

            exports.paginateListAccountRoles = paginateListAccountRoles;


            /***/
        }),
        /* 783 */,
        /* 784 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;
            var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
            exports.default = _default;

            /***/
        }),
        /* 785 */,
        /* 786 */
        /***/ (function (module) {

            module.exports = {
                "name": "nodemailer",
                "version": "6.7.3",
                "description": "Easy as cake e-mail sending from your Node.js applications",
                "main": "lib/nodemailer.js",
                "scripts": {"test": "grunt"},
                "repository": {"type": "git", "url": "https://github.com/nodemailer/nodemailer.git"},
                "keywords": ["Nodemailer"],
                "author": "Andris Reinman",
                "license": "MIT",
                "bugs": {"url": "https://github.com/nodemailer/nodemailer/issues"},
                "homepage": "https://nodemailer.com/",
                "devDependencies": {
                    "@aws-sdk/client-ses": "3.54.1",
                    "aws-sdk": "2.1096.0",
                    "bunyan": "1.8.15",
                    "chai": "4.3.6",
                    "eslint-config-nodemailer": "1.2.0",
                    "eslint-config-prettier": "8.5.0",
                    "grunt": "1.4.1",
                    "grunt-cli": "1.4.3",
                    "grunt-eslint": "24.0.0",
                    "grunt-mocha-test": "0.13.3",
                    "libbase64": "1.2.1",
                    "libmime": "5.0.0",
                    "libqp": "1.1.0",
                    "mocha": "9.2.2",
                    "nodemailer-ntlm-auth": "1.0.1",
                    "proxy": "1.0.2",
                    "proxy-test-server": "1.0.0",
                    "sinon": "13.0.1",
                    "smtp-server": "3.10.0"
                },
                "engines": {"node": ">=6.0.0"}
            };

            /***/
        }),
        /* 787 */,
        /* 788 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CreateCustomVerificationEmailTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CreateCustomVerificationEmailTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CreateCustomVerificationEmailTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CreateCustomVerificationEmailTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCreateCustomVerificationEmailTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCreateCustomVerificationEmailTemplateCommand)(output, context);
                }
            }

            exports.CreateCustomVerificationEmailTemplateCommand = CreateCustomVerificationEmailTemplateCommand;


            /***/
        }),
        /* 789 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.serializeFloat = void 0;
            const serializeFloat = (value) => {
                if (value !== value) {
                    return "NaN";
                }
                switch (value) {
                    case Infinity:
                        return "Infinity";
                    case -Infinity:
                        return "-Infinity";
                    default:
                        return value;
                }
            };
            exports.serializeFloat = serializeFloat;


            /***/
        }),
        /* 790 */,
        /* 791 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const stream = __webpack_require__(413);
            const Transform = stream.Transform;

            /**
             * Ensures that only <CR><LF> sequences are used for linebreaks
             *
             * @param {Object} options Stream options
             */
            class LeWindows extends Transform {
                constructor(options) {
                    super(options);
                    // init Transform
                    this.options = options || {};
                    this.lastByte = false;
                }

                /**
                 * Escapes dots
                 */
                _transform(chunk, encoding, done) {
                    let buf;
                    let lastPos = 0;

                    for (let i = 0, len = chunk.length; i < len; i++) {
                        if (chunk[i] === 0x0a) {
                            // \n
                            if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {
                                if (i > lastPos) {
                                    buf = chunk.slice(lastPos, i);
                                    this.push(buf);
                                }
                                this.push(Buffer.from('\r\n'));
                                lastPos = i + 1;
                            }
                        }
                    }

                    if (lastPos && lastPos < chunk.length) {
                        buf = chunk.slice(lastPos);
                        this.push(buf);
                    } else if (!lastPos) {
                        this.push(chunk);
                    }

                    this.lastByte = chunk[chunk.length - 1];
                    done();
                }
            }

            module.exports = LeWindows;


            /***/
        }),
        /* 792 */,
        /* 793 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getResolvedSigningRegion = void 0;
            const getResolvedSigningRegion = (hostname, {signingRegion, regionRegex, useFipsEndpoint}) => {
                if (signingRegion) {
                    return signingRegion;
                } else if (useFipsEndpoint) {
                    const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
                    const regionRegexmatchArray = hostname.match(regionRegexJs);
                    if (regionRegexmatchArray) {
                        return regionRegexmatchArray[0].slice(1, -1);
                    }
                }
            };
            exports.getResolvedSigningRegion = getResolvedSigningRegion;


            /***/
        }),
        /* 794 */,
        /* 795 */,
        /* 796 */,
        /* 797 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getTransformedHeaders = void 0;
            const getTransformedHeaders = (headers) => {
                const transformedHeaders = {};
                for (const name of Object.keys(headers)) {
                    const headerValues = headers[name];
                    transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
                }
                return transformedHeaders;
            };
            exports.getTransformedHeaders = getTransformedHeaders;


            /***/
        }),
        /* 798 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.paginateListAccounts = void 0;
            const ListAccountsCommand_1 = __webpack_require__(994);
            const SSO_1 = __webpack_require__(112);
            const SSOClient_1 = __webpack_require__(995);
            const makePagedClientRequest = async (client, input, ...args) => {
                return await client.send(new ListAccountsCommand_1.ListAccountsCommand(input), ...args);
            };
            const makePagedRequest = async (client, input, ...args) => {
                return await client.listAccounts(input, ...args);
            };

            async function* paginateListAccounts(config, input, ...additionalArguments) {
                let token = config.startingToken || undefined;
                let hasNext = true;
                let page;
                while (hasNext) {
                    input.nextToken = token;
                    input["maxResults"] = config.pageSize;
                    if (config.client instanceof SSO_1.SSO) {
                        page = await makePagedRequest(config.client, input, ...additionalArguments);
                    } else if (config.client instanceof SSOClient_1.SSOClient) {
                        page = await makePagedClientRequest(config.client, input, ...additionalArguments);
                    } else {
                        throw new Error("Invalid client, expected SSO | SSOClient");
                    }
                    yield page;
                    token = page.nextToken;
                    hasNext = !!token;
                }
                return undefined;
            }

            exports.paginateListAccounts = paginateListAccounts;


            /***/
        }),
        /* 799 */,
        /* 800 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const Stream = __webpack_require__(413).Stream;
            const fetch = __webpack_require__(204);
            const crypto = __webpack_require__(417);
            const shared = __webpack_require__(190);

            /**
             * XOAUTH2 access_token generator for Gmail.
             * Create client ID for web applications in Google API console to use it.
             * See Offline Access for receiving the needed refreshToken for an user
             * https://developers.google.com/accounts/docs/OAuth2WebServer#offline
             *
             * Usage for generating access tokens with a custom method using provisionCallback:
             * provisionCallback(user, renew, callback)
             *   * user is the username to get the token for
             *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed
             *   * callback is the callback to run with (error, accessToken [, expires])
             *     * accessToken is a string
             *     * expires is an optional expire time in milliseconds
             * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself
             *
             * @constructor
             * @param {Object} options Client information for token generation
             * @param {String} options.user User e-mail address
             * @param {String} options.clientId Client ID value
             * @param {String} options.clientSecret Client secret value
             * @param {String} options.refreshToken Refresh token for an user
             * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'
             * @param {String} options.accessToken An existing valid accessToken
             * @param {String} options.privateKey Private key for JSW
             * @param {Number} options.expires Optional Access Token expire time in ms
             * @param {Number} options.timeout Optional TTL for Access Token in seconds
             * @param {Function} options.provisionCallback Function to run when a new access token is required
             */
            class XOAuth2 extends Stream {
                constructor(options, logger) {
                    super();

                    this.options = options || {};

                    if (options && options.serviceClient) {
                        if (!options.privateKey || !options.user) {
                            setImmediate(() => this.emit('error', new Error('Options "privateKey" and "user" are required for service account!')));
                            return;
                        }

                        let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
                        this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
                    }

                    this.logger = shared.getLogger(
                        {
                            logger
                        },
                        {
                            component: this.options.component || 'OAuth2'
                        }
                    );

                    this.provisionCallback = typeof this.options.provisionCallback === 'function' ? this.options.provisionCallback : false;

                    this.options.accessUrl = this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';
                    this.options.customHeaders = this.options.customHeaders || {};
                    this.options.customParams = this.options.customParams || {};

                    this.accessToken = this.options.accessToken || false;

                    if (this.options.expires && Number(this.options.expires)) {
                        this.expires = this.options.expires;
                    } else {
                        let timeout = Math.max(Number(this.options.timeout) || 0, 0);
                        this.expires = (timeout && Date.now() + timeout * 1000) || 0;
                    }
                }

                /**
                 * Returns or generates (if previous has expired) a XOAuth2 token
                 *
                 * @param {Boolean} renew If false then use cached access token (if available)
                 * @param {Function} callback Callback function with error object and token string
                 */
                getToken(renew, callback) {
                    if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
                        return callback(null, this.accessToken);
                    }

                    let generateCallback = (...args) => {
                        if (args[0]) {
                            this.logger.error(
                                {
                                    err: args[0],
                                    tnx: 'OAUTH2',
                                    user: this.options.user,
                                    action: 'renew'
                                },
                                'Failed generating new Access Token for %s',
                                this.options.user
                            );
                        } else {
                            this.logger.info(
                                {
                                    tnx: 'OAUTH2',
                                    user: this.options.user,
                                    action: 'renew'
                                },
                                'Generated new Access Token for %s',
                                this.options.user
                            );
                        }
                        callback(...args);
                    };

                    if (this.provisionCallback) {
                        this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {
                            if (!err && accessToken) {
                                this.accessToken = accessToken;
                                this.expires = expires || 0;
                            }
                            generateCallback(err, accessToken);
                        });
                    } else {
                        this.generateToken(generateCallback);
                    }
                }

                /**
                 * Updates token values
                 *
                 * @param {String} accessToken New access token
                 * @param {Number} timeout Access token lifetime in seconds
                 *
                 * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}
                 */
                updateToken(accessToken, timeout) {
                    this.accessToken = accessToken;
                    timeout = Math.max(Number(timeout) || 0, 0);
                    this.expires = (timeout && Date.now() + timeout * 1000) || 0;

                    this.emit('token', {
                        user: this.options.user,
                        accessToken: accessToken || '',
                        expires: this.expires
                    });
                }

                /**
                 * Generates a new XOAuth2 token with the credentials provided at initialization
                 *
                 * @param {Function} callback Callback function with error object and token string
                 */
                generateToken(callback) {
                    let urlOptions;
                    let loggedUrlOptions;
                    if (this.options.serviceClient) {
                        // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount
                        let iat = Math.floor(Date.now() / 1000); // unix time
                        let tokenData = {
                            iss: this.options.serviceClient,
                            scope: this.options.scope || 'https://mail.google.com/',
                            sub: this.options.user,
                            aud: this.options.accessUrl,
                            iat,
                            exp: iat + this.options.serviceRequestTimeout
                        };
                        let token;
                        try {
                            token = this.jwtSignRS256(tokenData);
                        } catch (err) {
                            return callback(new Error('Can\x27t generate token. Check your auth options'));
                        }

                        urlOptions = {
                            grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                            assertion: token
                        };

                        loggedUrlOptions = {
                            grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                            assertion: tokenData
                        };
                    } else {
                        if (!this.options.refreshToken) {
                            return callback(new Error('Can\x27t create new access token for user'));
                        }

                        // web app - https://developers.google.com/identity/protocols/OAuth2WebServer
                        urlOptions = {
                            client_id: this.options.clientId || '',
                            client_secret: this.options.clientSecret || '',
                            refresh_token: this.options.refreshToken,
                            grant_type: 'refresh_token'
                        };

                        loggedUrlOptions = {
                            client_id: this.options.clientId || '',
                            client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',
                            refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',
                            grant_type: 'refresh_token'
                        };
                    }

                    Object.keys(this.options.customParams).forEach(key => {
                        urlOptions[key] = this.options.customParams[key];
                        loggedUrlOptions[key] = this.options.customParams[key];
                    });

                    this.logger.debug(
                        {
                            tnx: 'OAUTH2',
                            user: this.options.user,
                            action: 'generate'
                        },
                        'Requesting token using: %s',
                        JSON.stringify(loggedUrlOptions)
                    );

                    this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {
                        let data;

                        if (error) {
                            return callback(error);
                        }

                        try {
                            data = JSON.parse(body.toString());
                        } catch (E) {
                            return callback(E);
                        }

                        if (!data || typeof data !== 'object') {
                            this.logger.debug(
                                {
                                    tnx: 'OAUTH2',
                                    user: this.options.user,
                                    action: 'post'
                                },
                                'Response: %s',
                                (body || '').toString()
                            );
                            return callback(new Error('Invalid authentication response'));
                        }

                        let logData = {};
                        Object.keys(data).forEach(key => {
                            if (key !== 'access_token') {
                                logData[key] = data[key];
                            } else {
                                logData[key] = (data[key] || '').toString().substr(0, 6) + '...';
                            }
                        });

                        this.logger.debug(
                            {
                                tnx: 'OAUTH2',
                                user: this.options.user,
                                action: 'post'
                            },
                            'Response: %s',
                            JSON.stringify(logData)
                        );

                        if (data.error) {
                            // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2
                            let errorMessage = data.error;
                            if (data.error_description) {
                                errorMessage += ': ' + data.error_description;
                            }
                            if (data.error_uri) {
                                errorMessage += ' (' + data.error_uri + ')';
                            }
                            return callback(new Error(errorMessage));
                        }

                        if (data.access_token) {
                            this.updateToken(data.access_token, data.expires_in);
                            return callback(null, this.accessToken);
                        }

                        return callback(new Error('No access token'));
                    });
                }

                /**
                 * Converts an access_token and user id into a base64 encoded XOAuth2 token
                 *
                 * @param {String} [accessToken] Access token string
                 * @return {String} Base64 encoded token for IMAP or SMTP login
                 */
                buildXOAuth2Token(accessToken) {
                    let authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];
                    return Buffer.from(authData.join('\x01'), 'utf-8').toString('base64');
                }

                /**
                 * Custom POST request handler.
                 * This is only needed to keep paths short in Windows  usually this module
                 * is a dependency of a dependency and if it tries to require something
                 * like the request module the paths get way too long to handle for Windows.
                 * As we do only a simple POST request we do not actually require complicated
                 * logic support (no redirects, no nothing) anyway.
                 *
                 * @param {String} url Url to POST to
                 * @param {String|Buffer} payload Payload to POST
                 * @param {Function} callback Callback function with (err, buff)
                 */
                postRequest(url, payload, params, callback) {
                    let returned = false;

                    let chunks = [];
                    let chunklen = 0;

                    let req = fetch(url, {
                        method: 'post',
                        headers: params.customHeaders,
                        body: payload,
                        allowErrorResponse: true
                    });

                    req.on('readable', () => {
                        let chunk;
                        while ((chunk = req.read()) !== null) {
                            chunks.push(chunk);
                            chunklen += chunk.length;
                        }
                    });

                    req.once('error', err => {
                        if (returned) {
                            return;
                        }
                        returned = true;
                        return callback(err);
                    });

                    req.once('end', () => {
                        if (returned) {
                            return;
                        }
                        returned = true;
                        return callback(null, Buffer.concat(chunks, chunklen));
                    });
                }

                /**
                 * Encodes a buffer or a string into Base64url format
                 *
                 * @param {Buffer|String} data The data to convert
                 * @return {String} The encoded string
                 */
                toBase64URL(data) {
                    if (typeof data === 'string') {
                        data = Buffer.from(data);
                    }

                    return data
                        .toString('base64')
                        .replace(/[=]+/g, '') // remove '='s
                        .replace(/\+/g, '-') // '+'  '-'
                        .replace(/\//g, '_'); // '/'  '_'
                }

                /**
                 * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)
                 *
                 * @param {Object} payload The payload to include in the generated token
                 * @return {String} The generated and signed token
                 */
                jwtSignRS256(payload) {
                    payload = ['{"alg":"RS256","typ":"JWT"}', JSON.stringify(payload)].map(val => this.toBase64URL(val)).join('.');
                    let signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);
                    return payload + '.' + this.toBase64URL(signature);
                }
            }

            module.exports = XOAuth2;


            /***/
        }),
        /* 801 */,
        /* 802 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.staticStabilityProvider = void 0;
            const getExtendedInstanceMetadataCredentials_1 = __webpack_require__(876);
            const staticStabilityProvider = (provider, options = {}) => {
                const logger = (options === null || options === void 0 ? void 0 : options.logger) || console;
                let pastCredentials;
                return async () => {
                    let credentials;
                    try {
                        credentials = await provider();
                        if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
                            credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(credentials, logger);
                        }
                    } catch (e) {
                        if (pastCredentials) {
                            logger.warn("Credential renew failed: ", e);
                            credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(pastCredentials, logger);
                        } else {
                            throw e;
                        }
                    }
                    pastCredentials = credentials;
                    return credentials;
                };
            };
            exports.staticStabilityProvider = staticStabilityProvider;


            /***/
        }),
        /* 803 */,
        /* 804 */,
        /* 805 */,
        /* 806 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(714), exports);
            tslib_1.__exportStar(__webpack_require__(74), exports);
            tslib_1.__exportStar(__webpack_require__(185), exports);
            tslib_1.__exportStar(__webpack_require__(168), exports);
            tslib_1.__exportStar(__webpack_require__(494), exports);
            tslib_1.__exportStar(__webpack_require__(625), exports);
            tslib_1.__exportStar(__webpack_require__(502), exports);
            tslib_1.__exportStar(__webpack_require__(225), exports);
            tslib_1.__exportStar(__webpack_require__(540), exports);
            tslib_1.__exportStar(__webpack_require__(696), exports);


            /***/
        }),
        /* 807 */
        /***/ (function (module) {

            module.exports = addHook;

            function addHook(state, kind, name, hook) {
                var orig = hook;
                if (!state.registry[name]) {
                    state.registry[name] = [];
                }

                if (kind === "before") {
                    hook = function (method, options) {
                        return Promise.resolve()
                            .then(orig.bind(null, options))
                            .then(method.bind(null, options));
                    };
                }

                if (kind === "after") {
                    hook = function (method, options) {
                        var result;
                        return Promise.resolve()
                            .then(method.bind(null, options))
                            .then(function (result_) {
                                result = result_;
                                return orig(result, options);
                            })
                            .then(function () {
                                return result;
                            });
                    };
                }

                if (kind === "error") {
                    hook = function (method, options) {
                        return Promise.resolve()
                            .then(method.bind(null, options))
                            .catch(function (error) {
                                return orig(error, options);
                            });
                    };
                }

                state.registry[name].push({
                    hook: hook,
                    orig: orig,
                });
            }


            /***/
        }),
        /* 808 */,
        /* 809 */,
        /* 810 */,
        /* 811 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.VerifyDomainIdentityCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class VerifyDomainIdentityCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "VerifyDomainIdentityCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.VerifyDomainIdentityRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.VerifyDomainIdentityResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryVerifyDomainIdentityCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryVerifyDomainIdentityCommand)(output, context);
                }
            }

            exports.VerifyDomainIdentityCommand = VerifyDomainIdentityCommand;


            /***/
        }),
        /* 812 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteConfigurationSetTrackingOptionsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteConfigurationSetTrackingOptionsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteConfigurationSetTrackingOptionsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteConfigurationSetTrackingOptionsRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteConfigurationSetTrackingOptionsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteConfigurationSetTrackingOptionsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteConfigurationSetTrackingOptionsCommand)(output, context);
                }
            }

            exports.DeleteConfigurationSetTrackingOptionsCommand = DeleteConfigurationSetTrackingOptionsCommand;


            /***/
        }),
        /* 813 */,
        /* 814 */,
        /* 815 */,
        /* 816 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.toDate = exports.iso8601 = void 0;
            const iso8601 = (time) => (0, exports.toDate)(time)
                .toISOString()
                .replace(/\.\d{3}Z$/, "Z");
            exports.iso8601 = iso8601;
            const toDate = (time) => {
                if (typeof time === "number") {
                    return new Date(time * 1000);
                }
                if (typeof time === "string") {
                    if (Number(time)) {
                        return new Date(Number(time) * 1000);
                    }
                    return new Date(time);
                }
                return time;
            };
            exports.toDate = toDate;


            /***/
        }),
        /* 817 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.NODE_REGION_CONFIG_FILE_OPTIONS = exports.NODE_REGION_CONFIG_OPTIONS = exports.REGION_INI_NAME = exports.REGION_ENV_NAME = void 0;
            exports.REGION_ENV_NAME = "AWS_REGION";
            exports.REGION_INI_NAME = "region";
            exports.NODE_REGION_CONFIG_OPTIONS = {
                environmentVariableSelector: (env) => env[exports.REGION_ENV_NAME],
                configFileSelector: (profile) => profile[exports.REGION_INI_NAME],
                default: () => {
                    throw new Error("Region is missing");
                },
            };
            exports.NODE_REGION_CONFIG_FILE_OPTIONS = {
                preferredFile: "credentials",
            };


            /***/
        }),
        /* 818 */
        /***/ (function (module) {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
            module.exports = wrappy

            function wrappy(fn, cb) {
                if (fn && cb) return wrappy(fn)(cb)

                if (typeof fn !== 'function')
                    throw new TypeError('need wrapper function')

                Object.keys(fn).forEach(function (k) {
                    wrapper[k] = fn[k]
                })

                return wrapper

                function wrapper() {
                    var args = new Array(arguments.length)
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i]
                    }
                    var ret = fn.apply(this, args)
                    var cb = args[args.length - 1]
                    if (typeof ret === 'function' && ret !== cb) {
                        Object.keys(cb).forEach(function (k) {
                            ret[k] = cb[k]
                        })
                    }
                    return ret
                }
            }


            /***/
        }),
        /* 819 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = rng;

            var _crypto = _interopRequireDefault(__webpack_require__(417));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

            let poolPtr = rnds8Pool.length;

            function rng() {
                if (poolPtr > rnds8Pool.length - 16) {
                    _crypto.default.randomFillSync(rnds8Pool);

                    poolPtr = 0;
                }

                return rnds8Pool.slice(poolPtr, poolPtr += 16);
            }

            /***/
        }),
        /* 820 */,
        /* 821 */,
        /* 822 */,
        /* 823 */,
        /* 824 */,
        /* 825 */,
        /* 826 */,
        /* 827 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.defaultProvider = void 0;
            const credential_provider_env_1 = __webpack_require__(240);
            const credential_provider_ini_1 = __webpack_require__(377);
            const credential_provider_process_1 = __webpack_require__(524);
            const credential_provider_sso_1 = __webpack_require__(321);
            const credential_provider_web_identity_1 = __webpack_require__(740);
            const property_provider_1 = __webpack_require__(118);
            const shared_ini_file_loader_1 = __webpack_require__(706);
            const remoteProvider_1 = __webpack_require__(466);
            const defaultProvider = (init = {}) => {
                const options = {
                    profile: process.env[shared_ini_file_loader_1.ENV_PROFILE],
                    ...init,
                    ...(!init.loadedConfig && {loadedConfig: (0, shared_ini_file_loader_1.loadSharedConfigFiles)(init)}),
                };
                const providerChain = (0, property_provider_1.chain)(...(options.profile ? [] : [(0, credential_provider_env_1.fromEnv)()]), (0, credential_provider_sso_1.fromSSO)(options), (0, credential_provider_ini_1.fromIni)(options), (0, credential_provider_process_1.fromProcess)(options), (0, credential_provider_web_identity_1.fromTokenFile)(options), (0, remoteProvider_1.remoteProvider)(options), async () => {
                    throw new property_provider_1.CredentialsProviderError("Could not load credentials from any providers", false);
                });
                return (0, property_provider_1.memoize)(providerChain, (credentials) => credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000, (credentials) => credentials.expiration !== undefined);
            };
            exports.defaultProvider = defaultProvider;


            /***/
        }),
        /* 828 */,
        /* 829 */,
        /* 830 */,
        /* 831 */,
        /* 832 */,
        /* 833 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getCanonicalQuery = void 0;
            const util_uri_escape_1 = __webpack_require__(927);
            const constants_1 = __webpack_require__(70);
            const getCanonicalQuery = ({query = {}}) => {
                const keys = [];
                const serialized = {};
                for (const key of Object.keys(query).sort()) {
                    if (key.toLowerCase() === constants_1.SIGNATURE_HEADER) {
                        continue;
                    }
                    keys.push(key);
                    const value = query[key];
                    if (typeof value === "string") {
                        serialized[key] = `${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`;
                    } else if (Array.isArray(value)) {
                        serialized[key] = value
                            .slice(0)
                            .sort()
                            .reduce((encoded, value) => encoded.concat([`${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`]), [])
                            .join("&");
                    }
                }
                return keys
                    .map((key) => serialized[key])
                    .filter((serialized) => serialized)
                    .join("&");
            };
            exports.getCanonicalQuery = getCanonicalQuery;


            /***/
        }),
        /* 834 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.parseUrl = void 0;
            const querystring_parser_1 = __webpack_require__(729);
            const parseUrl = (url) => {
                const {hostname, pathname, port, protocol, search} = new URL(url);
                let query;
                if (search) {
                    query = (0, querystring_parser_1.parseQueryString)(search);
                }
                return {
                    hostname,
                    port: port ? parseInt(port) : undefined,
                    protocol,
                    path: pathname,
                    query,
                };
            };
            exports.parseUrl = parseUrl;


            /***/
        }),
        /* 835 */
        /***/ (function (module) {

            module.exports = require("url");

            /***/
        }),
        /* 836 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListIdentityPoliciesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ListIdentityPoliciesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ListIdentityPoliciesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListIdentityPoliciesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListIdentityPoliciesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryListIdentityPoliciesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryListIdentityPoliciesCommand)(output, context);
                }
            }

            exports.ListIdentityPoliciesCommand = ListIdentityPoliciesCommand;


            /***/
        }),
        /* 837 */,
        /* 838 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.STSServiceException = void 0;
            const smithy_client_1 = __webpack_require__(449);

            class STSServiceException extends smithy_client_1.ServiceException {
                constructor(options) {
                    super(options);
                    Object.setPrototypeOf(this, STSServiceException.prototype);
                }
            }

            exports.STSServiceException = STSServiceException;


            /***/
        }),
        /* 839 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetFederationTokenCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const middleware_signing_1 = __webpack_require__(22);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(575);
            const Aws_query_1 = __webpack_require__(139);

            class GetFederationTokenCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "STSClient";
                    const commandName = "GetFederationTokenCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetFederationTokenRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetFederationTokenResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetFederationTokenCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetFederationTokenCommand)(output, context);
                }
            }

            exports.GetFederationTokenCommand = GetFederationTokenCommand;


            /***/
        }),
        /* 840 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";

            const punycode = __webpack_require__(213);
            const tr46 = __webpack_require__(359);

            const specialSchemes = {
                ftp: 21,
                file: null,
                gopher: 70,
                http: 80,
                https: 443,
                ws: 80,
                wss: 443
            };

            const failure = Symbol("failure");

            function countSymbols(str) {
                return punycode.ucs2.decode(str).length;
            }

            function at(input, idx) {
                const c = input[idx];
                return isNaN(c) ? undefined : String.fromCodePoint(c);
            }

            function isASCIIDigit(c) {
                return c >= 0x30 && c <= 0x39;
            }

            function isASCIIAlpha(c) {
                return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
            }

            function isASCIIAlphanumeric(c) {
                return isASCIIAlpha(c) || isASCIIDigit(c);
            }

            function isASCIIHex(c) {
                return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
            }

            function isSingleDot(buffer) {
                return buffer === "." || buffer.toLowerCase() === "%2e";
            }

            function isDoubleDot(buffer) {
                buffer = buffer.toLowerCase();
                return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
            }

            function isWindowsDriveLetterCodePoints(cp1, cp2) {
                return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
            }

            function isWindowsDriveLetterString(string) {
                return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
            }

            function isNormalizedWindowsDriveLetterString(string) {
                return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
            }

            function containsForbiddenHostCodePoint(string) {
                return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
            }

            function containsForbiddenHostCodePointExcludingPercent(string) {
                return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
            }

            function isSpecialScheme(scheme) {
                return specialSchemes[scheme] !== undefined;
            }

            function isSpecial(url) {
                return isSpecialScheme(url.scheme);
            }

            function defaultPort(scheme) {
                return specialSchemes[scheme];
            }

            function percentEncode(c) {
                let hex = c.toString(16).toUpperCase();
                if (hex.length === 1) {
                    hex = "0" + hex;
                }

                return "%" + hex;
            }

            function utf8PercentEncode(c) {
                const buf = new Buffer(c);

                let str = "";

                for (let i = 0; i < buf.length; ++i) {
                    str += percentEncode(buf[i]);
                }

                return str;
            }

            function utf8PercentDecode(str) {
                const input = new Buffer(str);
                const output = [];
                for (let i = 0; i < input.length; ++i) {
                    if (input[i] !== 37) {
                        output.push(input[i]);
                    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
                        output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
                        i += 2;
                    } else {
                        output.push(input[i]);
                    }
                }
                return new Buffer(output).toString();
            }

            function isC0ControlPercentEncode(c) {
                return c <= 0x1F || c > 0x7E;
            }

            const extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);

            function isPathPercentEncode(c) {
                return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
            }

            const extraUserinfoPercentEncodeSet =
                new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);

            function isUserinfoPercentEncode(c) {
                return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
            }

            function percentEncodeChar(c, encodeSetPredicate) {
                const cStr = String.fromCodePoint(c);

                if (encodeSetPredicate(c)) {
                    return utf8PercentEncode(cStr);
                }

                return cStr;
            }

            function parseIPv4Number(input) {
                let R = 10;

                if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
                    input = input.substring(2);
                    R = 16;
                } else if (input.length >= 2 && input.charAt(0) === "0") {
                    input = input.substring(1);
                    R = 8;
                }

                if (input === "") {
                    return 0;
                }

                const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
                if (regex.test(input)) {
                    return failure;
                }

                return parseInt(input, R);
            }

            function parseIPv4(input) {
                const parts = input.split(".");
                if (parts[parts.length - 1] === "") {
                    if (parts.length > 1) {
                        parts.pop();
                    }
                }

                if (parts.length > 4) {
                    return input;
                }

                const numbers = [];
                for (const part of parts) {
                    if (part === "") {
                        return input;
                    }
                    const n = parseIPv4Number(part);
                    if (n === failure) {
                        return input;
                    }

                    numbers.push(n);
                }

                for (let i = 0; i < numbers.length - 1; ++i) {
                    if (numbers[i] > 255) {
                        return failure;
                    }
                }
                if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
                    return failure;
                }

                let ipv4 = numbers.pop();
                let counter = 0;

                for (const n of numbers) {
                    ipv4 += n * Math.pow(256, 3 - counter);
                    ++counter;
                }

                return ipv4;
            }

            function serializeIPv4(address) {
                let output = "";
                let n = address;

                for (let i = 1; i <= 4; ++i) {
                    output = String(n % 256) + output;
                    if (i !== 4) {
                        output = "." + output;
                    }
                    n = Math.floor(n / 256);
                }

                return output;
            }

            function parseIPv6(input) {
                const address = [0, 0, 0, 0, 0, 0, 0, 0];
                let pieceIndex = 0;
                let compress = null;
                let pointer = 0;

                input = punycode.ucs2.decode(input);

                if (input[pointer] === 58) {
                    if (input[pointer + 1] !== 58) {
                        return failure;
                    }

                    pointer += 2;
                    ++pieceIndex;
                    compress = pieceIndex;
                }

                while (pointer < input.length) {
                    if (pieceIndex === 8) {
                        return failure;
                    }

                    if (input[pointer] === 58) {
                        if (compress !== null) {
                            return failure;
                        }
                        ++pointer;
                        ++pieceIndex;
                        compress = pieceIndex;
                        continue;
                    }

                    let value = 0;
                    let length = 0;

                    while (length < 4 && isASCIIHex(input[pointer])) {
                        value = value * 0x10 + parseInt(at(input, pointer), 16);
                        ++pointer;
                        ++length;
                    }

                    if (input[pointer] === 46) {
                        if (length === 0) {
                            return failure;
                        }

                        pointer -= length;

                        if (pieceIndex > 6) {
                            return failure;
                        }

                        let numbersSeen = 0;

                        while (input[pointer] !== undefined) {
                            let ipv4Piece = null;

                            if (numbersSeen > 0) {
                                if (input[pointer] === 46 && numbersSeen < 4) {
                                    ++pointer;
                                } else {
                                    return failure;
                                }
                            }

                            if (!isASCIIDigit(input[pointer])) {
                                return failure;
                            }

                            while (isASCIIDigit(input[pointer])) {
                                const number = parseInt(at(input, pointer));
                                if (ipv4Piece === null) {
                                    ipv4Piece = number;
                                } else if (ipv4Piece === 0) {
                                    return failure;
                                } else {
                                    ipv4Piece = ipv4Piece * 10 + number;
                                }
                                if (ipv4Piece > 255) {
                                    return failure;
                                }
                                ++pointer;
                            }

                            address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

                            ++numbersSeen;

                            if (numbersSeen === 2 || numbersSeen === 4) {
                                ++pieceIndex;
                            }
                        }

                        if (numbersSeen !== 4) {
                            return failure;
                        }

                        break;
                    } else if (input[pointer] === 58) {
                        ++pointer;
                        if (input[pointer] === undefined) {
                            return failure;
                        }
                    } else if (input[pointer] !== undefined) {
                        return failure;
                    }

                    address[pieceIndex] = value;
                    ++pieceIndex;
                }

                if (compress !== null) {
                    let swaps = pieceIndex - compress;
                    pieceIndex = 7;
                    while (pieceIndex !== 0 && swaps > 0) {
                        const temp = address[compress + swaps - 1];
                        address[compress + swaps - 1] = address[pieceIndex];
                        address[pieceIndex] = temp;
                        --pieceIndex;
                        --swaps;
                    }
                } else if (compress === null && pieceIndex !== 8) {
                    return failure;
                }

                return address;
            }

            function serializeIPv6(address) {
                let output = "";
                const seqResult = findLongestZeroSequence(address);
                const compress = seqResult.idx;
                let ignore0 = false;

                for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
                    if (ignore0 && address[pieceIndex] === 0) {
                        continue;
                    } else if (ignore0) {
                        ignore0 = false;
                    }

                    if (compress === pieceIndex) {
                        const separator = pieceIndex === 0 ? "::" : ":";
                        output += separator;
                        ignore0 = true;
                        continue;
                    }

                    output += address[pieceIndex].toString(16);

                    if (pieceIndex !== 7) {
                        output += ":";
                    }
                }

                return output;
            }

            function parseHost(input, isSpecialArg) {
                if (input[0] === "[") {
                    if (input[input.length - 1] !== "]") {
                        return failure;
                    }

                    return parseIPv6(input.substring(1, input.length - 1));
                }

                if (!isSpecialArg) {
                    return parseOpaqueHost(input);
                }

                const domain = utf8PercentDecode(input);
                const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
                if (asciiDomain === null) {
                    return failure;
                }

                if (containsForbiddenHostCodePoint(asciiDomain)) {
                    return failure;
                }

                const ipv4Host = parseIPv4(asciiDomain);
                if (typeof ipv4Host === "number" || ipv4Host === failure) {
                    return ipv4Host;
                }

                return asciiDomain;
            }

            function parseOpaqueHost(input) {
                if (containsForbiddenHostCodePointExcludingPercent(input)) {
                    return failure;
                }

                let output = "";
                const decoded = punycode.ucs2.decode(input);
                for (let i = 0; i < decoded.length; ++i) {
                    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
                }
                return output;
            }

            function findLongestZeroSequence(arr) {
                let maxIdx = null;
                let maxLen = 1; // only find elements > 1
                let currStart = null;
                let currLen = 0;

                for (let i = 0; i < arr.length; ++i) {
                    if (arr[i] !== 0) {
                        if (currLen > maxLen) {
                            maxIdx = currStart;
                            maxLen = currLen;
                        }

                        currStart = null;
                        currLen = 0;
                    } else {
                        if (currStart === null) {
                            currStart = i;
                        }
                        ++currLen;
                    }
                }

                // if trailing zeros
                if (currLen > maxLen) {
                    maxIdx = currStart;
                    maxLen = currLen;
                }

                return {
                    idx: maxIdx,
                    len: maxLen
                };
            }

            function serializeHost(host) {
                if (typeof host === "number") {
                    return serializeIPv4(host);
                }

                // IPv6 serializer
                if (host instanceof Array) {
                    return "[" + serializeIPv6(host) + "]";
                }

                return host;
            }

            function trimControlChars(url) {
                return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
            }

            function trimTabAndNewline(url) {
                return url.replace(/\u0009|\u000A|\u000D/g, "");
            }

            function shortenPath(url) {
                const path = url.path;
                if (path.length === 0) {
                    return;
                }
                if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
                    return;
                }

                path.pop();
            }

            function includesCredentials(url) {
                return url.username !== "" || url.password !== "";
            }

            function cannotHaveAUsernamePasswordPort(url) {
                return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
            }

            function isNormalizedWindowsDriveLetter(string) {
                return /^[A-Za-z]:$/.test(string);
            }

            function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
                this.pointer = 0;
                this.input = input;
                this.base = base || null;
                this.encodingOverride = encodingOverride || "utf-8";
                this.stateOverride = stateOverride;
                this.url = url;
                this.failure = false;
                this.parseError = false;

                if (!this.url) {
                    this.url = {
                        scheme: "",
                        username: "",
                        password: "",
                        host: null,
                        port: null,
                        path: [],
                        query: null,
                        fragment: null,

                        cannotBeABaseURL: false
                    };

                    const res = trimControlChars(this.input);
                    if (res !== this.input) {
                        this.parseError = true;
                    }
                    this.input = res;
                }

                const res = trimTabAndNewline(this.input);
                if (res !== this.input) {
                    this.parseError = true;
                }
                this.input = res;

                this.state = stateOverride || "scheme start";

                this.buffer = "";
                this.atFlag = false;
                this.arrFlag = false;
                this.passwordTokenSeenFlag = false;

                this.input = punycode.ucs2.decode(this.input);

                for (; this.pointer <= this.input.length; ++this.pointer) {
                    const c = this.input[this.pointer];
                    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);

                    // exec state machine
                    const ret = this["parse " + this.state](c, cStr);
                    if (!ret) {
                        break; // terminate algorithm
                    } else if (ret === failure) {
                        this.failure = true;
                        break;
                    }
                }
            }

            URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
                if (isASCIIAlpha(c)) {
                    this.buffer += cStr.toLowerCase();
                    this.state = "scheme";
                } else if (!this.stateOverride) {
                    this.state = "no scheme";
                    --this.pointer;
                } else {
                    this.parseError = true;
                    return failure;
                }

                return true;
            };

            URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
                if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
                    this.buffer += cStr.toLowerCase();
                } else if (c === 58) {
                    if (this.stateOverride) {
                        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
                            return false;
                        }

                        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
                            return false;
                        }

                        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
                            return false;
                        }

                        if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
                            return false;
                        }
                    }
                    this.url.scheme = this.buffer;
                    this.buffer = "";
                    if (this.stateOverride) {
                        return false;
                    }
                    if (this.url.scheme === "file") {
                        if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
                            this.parseError = true;
                        }
                        this.state = "file";
                    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
                        this.state = "special relative or authority";
                    } else if (isSpecial(this.url)) {
                        this.state = "special authority slashes";
                    } else if (this.input[this.pointer + 1] === 47) {
                        this.state = "path or authority";
                        ++this.pointer;
                    } else {
                        this.url.cannotBeABaseURL = true;
                        this.url.path.push("");
                        this.state = "cannot-be-a-base-URL path";
                    }
                } else if (!this.stateOverride) {
                    this.buffer = "";
                    this.state = "no scheme";
                    this.pointer = -1;
                } else {
                    this.parseError = true;
                    return failure;
                }

                return true;
            };

            URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
                if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {
                    return failure;
                } else if (this.base.cannotBeABaseURL && c === 35) {
                    this.url.scheme = this.base.scheme;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                    this.url.fragment = "";
                    this.url.cannotBeABaseURL = true;
                    this.state = "fragment";
                } else if (this.base.scheme === "file") {
                    this.state = "file";
                    --this.pointer;
                } else {
                    this.state = "relative";
                    --this.pointer;
                }

                return true;
            };

            URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
                if (c === 47 && this.input[this.pointer + 1] === 47) {
                    this.state = "special authority ignore slashes";
                    ++this.pointer;
                } else {
                    this.parseError = true;
                    this.state = "relative";
                    --this.pointer;
                }

                return true;
            };

            URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
                if (c === 47) {
                    this.state = "authority";
                } else {
                    this.state = "path";
                    --this.pointer;
                }

                return true;
            };

            URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
                this.url.scheme = this.base.scheme;
                if (isNaN(c)) {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                } else if (c === 47) {
                    this.state = "relative slash";
                } else if (c === 63) {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.url.path = this.base.path.slice();
                    this.url.query = "";
                    this.state = "query";
                } else if (c === 35) {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                    this.url.fragment = "";
                    this.state = "fragment";
                } else if (isSpecial(this.url) && c === 92) {
                    this.parseError = true;
                    this.state = "relative slash";
                } else {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.url.path = this.base.path.slice(0, this.base.path.length - 1);

                    this.state = "path";
                    --this.pointer;
                }

                return true;
            };

            URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
                if (isSpecial(this.url) && (c === 47 || c === 92)) {
                    if (c === 92) {
                        this.parseError = true;
                    }
                    this.state = "special authority ignore slashes";
                } else if (c === 47) {
                    this.state = "authority";
                } else {
                    this.url.username = this.base.username;
                    this.url.password = this.base.password;
                    this.url.host = this.base.host;
                    this.url.port = this.base.port;
                    this.state = "path";
                    --this.pointer;
                }

                return true;
            };

            URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
                if (c === 47 && this.input[this.pointer + 1] === 47) {
                    this.state = "special authority ignore slashes";
                    ++this.pointer;
                } else {
                    this.parseError = true;
                    this.state = "special authority ignore slashes";
                    --this.pointer;
                }

                return true;
            };

            URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
                if (c !== 47 && c !== 92) {
                    this.state = "authority";
                    --this.pointer;
                } else {
                    this.parseError = true;
                }

                return true;
            };

            URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
                if (c === 64) {
                    this.parseError = true;
                    if (this.atFlag) {
                        this.buffer = "%40" + this.buffer;
                    }
                    this.atFlag = true;

                    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
                    const len = countSymbols(this.buffer);
                    for (let pointer = 0; pointer < len; ++pointer) {
                        const codePoint = this.buffer.codePointAt(pointer);

                        if (codePoint === 58 && !this.passwordTokenSeenFlag) {
                            this.passwordTokenSeenFlag = true;
                            continue;
                        }
                        const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
                        if (this.passwordTokenSeenFlag) {
                            this.url.password += encodedCodePoints;
                        } else {
                            this.url.username += encodedCodePoints;
                        }
                    }
                    this.buffer = "";
                } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
                    (isSpecial(this.url) && c === 92)) {
                    if (this.atFlag && this.buffer === "") {
                        this.parseError = true;
                        return failure;
                    }
                    this.pointer -= countSymbols(this.buffer) + 1;
                    this.buffer = "";
                    this.state = "host";
                } else {
                    this.buffer += cStr;
                }

                return true;
            };

            URLStateMachine.prototype["parse hostname"] =
                URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
                    if (this.stateOverride && this.url.scheme === "file") {
                        --this.pointer;
                        this.state = "file host";
                    } else if (c === 58 && !this.arrFlag) {
                        if (this.buffer === "") {
                            this.parseError = true;
                            return failure;
                        }

                        const host = parseHost(this.buffer, isSpecial(this.url));
                        if (host === failure) {
                            return failure;
                        }

                        this.url.host = host;
                        this.buffer = "";
                        this.state = "port";
                        if (this.stateOverride === "hostname") {
                            return false;
                        }
                    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
                        (isSpecial(this.url) && c === 92)) {
                        --this.pointer;
                        if (isSpecial(this.url) && this.buffer === "") {
                            this.parseError = true;
                            return failure;
                        } else if (this.stateOverride && this.buffer === "" &&
                            (includesCredentials(this.url) || this.url.port !== null)) {
                            this.parseError = true;
                            return false;
                        }

                        const host = parseHost(this.buffer, isSpecial(this.url));
                        if (host === failure) {
                            return failure;
                        }

                        this.url.host = host;
                        this.buffer = "";
                        this.state = "path start";
                        if (this.stateOverride) {
                            return false;
                        }
                    } else {
                        if (c === 91) {
                            this.arrFlag = true;
                        } else if (c === 93) {
                            this.arrFlag = false;
                        }
                        this.buffer += cStr;
                    }

                    return true;
                };

            URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
                if (isASCIIDigit(c)) {
                    this.buffer += cStr;
                } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
                    (isSpecial(this.url) && c === 92) ||
                    this.stateOverride) {
                    if (this.buffer !== "") {
                        const port = parseInt(this.buffer);
                        if (port > Math.pow(2, 16) - 1) {
                            this.parseError = true;
                            return failure;
                        }
                        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
                        this.buffer = "";
                    }
                    if (this.stateOverride) {
                        return false;
                    }
                    this.state = "path start";
                    --this.pointer;
                } else {
                    this.parseError = true;
                    return failure;
                }

                return true;
            };

            const fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);

            URLStateMachine.prototype["parse file"] = function parseFile(c) {
                this.url.scheme = "file";

                if (c === 47 || c === 92) {
                    if (c === 92) {
                        this.parseError = true;
                    }
                    this.state = "file slash";
                } else if (this.base !== null && this.base.scheme === "file") {
                    if (isNaN(c)) {
                        this.url.host = this.base.host;
                        this.url.path = this.base.path.slice();
                        this.url.query = this.base.query;
                    } else if (c === 63) {
                        this.url.host = this.base.host;
                        this.url.path = this.base.path.slice();
                        this.url.query = "";
                        this.state = "query";
                    } else if (c === 35) {
                        this.url.host = this.base.host;
                        this.url.path = this.base.path.slice();
                        this.url.query = this.base.query;
                        this.url.fragment = "";
                        this.state = "fragment";
                    } else {
                        if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
                            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||
                            (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
                                !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {
                            this.url.host = this.base.host;
                            this.url.path = this.base.path.slice();
                            shortenPath(this.url);
                        } else {
                            this.parseError = true;
                        }

                        this.state = "path";
                        --this.pointer;
                    }
                } else {
                    this.state = "path";
                    --this.pointer;
                }

                return true;
            };

            URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
                if (c === 47 || c === 92) {
                    if (c === 92) {
                        this.parseError = true;
                    }
                    this.state = "file host";
                } else {
                    if (this.base !== null && this.base.scheme === "file") {
                        if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
                            this.url.path.push(this.base.path[0]);
                        } else {
                            this.url.host = this.base.host;
                        }
                    }
                    this.state = "path";
                    --this.pointer;
                }

                return true;
            };

            URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
                if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
                    --this.pointer;
                    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
                        this.parseError = true;
                        this.state = "path";
                    } else if (this.buffer === "") {
                        this.url.host = "";
                        if (this.stateOverride) {
                            return false;
                        }
                        this.state = "path start";
                    } else {
                        let host = parseHost(this.buffer, isSpecial(this.url));
                        if (host === failure) {
                            return failure;
                        }
                        if (host === "localhost") {
                            host = "";
                        }
                        this.url.host = host;

                        if (this.stateOverride) {
                            return false;
                        }

                        this.buffer = "";
                        this.state = "path start";
                    }
                } else {
                    this.buffer += cStr;
                }

                return true;
            };

            URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
                if (isSpecial(this.url)) {
                    if (c === 92) {
                        this.parseError = true;
                    }
                    this.state = "path";

                    if (c !== 47 && c !== 92) {
                        --this.pointer;
                    }
                } else if (!this.stateOverride && c === 63) {
                    this.url.query = "";
                    this.state = "query";
                } else if (!this.stateOverride && c === 35) {
                    this.url.fragment = "";
                    this.state = "fragment";
                } else if (c !== undefined) {
                    this.state = "path";
                    if (c !== 47) {
                        --this.pointer;
                    }
                }

                return true;
            };

            URLStateMachine.prototype["parse path"] = function parsePath(c) {
                if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||
                    (!this.stateOverride && (c === 63 || c === 35))) {
                    if (isSpecial(this.url) && c === 92) {
                        this.parseError = true;
                    }

                    if (isDoubleDot(this.buffer)) {
                        shortenPath(this.url);
                        if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
                            this.url.path.push("");
                        }
                    } else if (isSingleDot(this.buffer) && c !== 47 &&
                        !(isSpecial(this.url) && c === 92)) {
                        this.url.path.push("");
                    } else if (!isSingleDot(this.buffer)) {
                        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
                            if (this.url.host !== "" && this.url.host !== null) {
                                this.parseError = true;
                                this.url.host = "";
                            }
                            this.buffer = this.buffer[0] + ":";
                        }
                        this.url.path.push(this.buffer);
                    }
                    this.buffer = "";
                    if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
                        while (this.url.path.length > 1 && this.url.path[0] === "") {
                            this.parseError = true;
                            this.url.path.shift();
                        }
                    }
                    if (c === 63) {
                        this.url.query = "";
                        this.state = "query";
                    }
                    if (c === 35) {
                        this.url.fragment = "";
                        this.state = "fragment";
                    }
                } else {
                    // TODO: If c is not a URL code point and not "%", parse error.

                    if (c === 37 &&
                        (!isASCIIHex(this.input[this.pointer + 1]) ||
                            !isASCIIHex(this.input[this.pointer + 2]))) {
                        this.parseError = true;
                    }

                    this.buffer += percentEncodeChar(c, isPathPercentEncode);
                }

                return true;
            };

            URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
                if (c === 63) {
                    this.url.query = "";
                    this.state = "query";
                } else if (c === 35) {
                    this.url.fragment = "";
                    this.state = "fragment";
                } else {
                    // TODO: Add: not a URL code point
                    if (!isNaN(c) && c !== 37) {
                        this.parseError = true;
                    }

                    if (c === 37 &&
                        (!isASCIIHex(this.input[this.pointer + 1]) ||
                            !isASCIIHex(this.input[this.pointer + 2]))) {
                        this.parseError = true;
                    }

                    if (!isNaN(c)) {
                        this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
                    }
                }

                return true;
            };

            URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
                if (isNaN(c) || (!this.stateOverride && c === 35)) {
                    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
                        this.encodingOverride = "utf-8";
                    }

                    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
                    for (let i = 0; i < buffer.length; ++i) {
                        if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
                            buffer[i] === 0x3C || buffer[i] === 0x3E) {
                            this.url.query += percentEncode(buffer[i]);
                        } else {
                            this.url.query += String.fromCodePoint(buffer[i]);
                        }
                    }

                    this.buffer = "";
                    if (c === 35) {
                        this.url.fragment = "";
                        this.state = "fragment";
                    }
                } else {
                    // TODO: If c is not a URL code point and not "%", parse error.
                    if (c === 37 &&
                        (!isASCIIHex(this.input[this.pointer + 1]) ||
                            !isASCIIHex(this.input[this.pointer + 2]))) {
                        this.parseError = true;
                    }

                    this.buffer += cStr;
                }

                return true;
            };

            URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
                if (isNaN(c)) { // do nothing
                } else if (c === 0x0) {
                    this.parseError = true;
                } else {
                    // TODO: If c is not a URL code point and not "%", parse error.
                    if (c === 37 &&
                        (!isASCIIHex(this.input[this.pointer + 1]) ||
                            !isASCIIHex(this.input[this.pointer + 2]))) {
                        this.parseError = true;
                    }

                    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
                }

                return true;
            };

            function serializeURL(url, excludeFragment) {
                let output = url.scheme + ":";
                if (url.host !== null) {
                    output += "//";

                    if (url.username !== "" || url.password !== "") {
                        output += url.username;
                        if (url.password !== "") {
                            output += ":" + url.password;
                        }
                        output += "@";
                    }

                    output += serializeHost(url.host);

                    if (url.port !== null) {
                        output += ":" + url.port;
                    }
                } else if (url.host === null && url.scheme === "file") {
                    output += "//";
                }

                if (url.cannotBeABaseURL) {
                    output += url.path[0];
                } else {
                    for (const string of url.path) {
                        output += "/" + string;
                    }
                }

                if (url.query !== null) {
                    output += "?" + url.query;
                }

                if (!excludeFragment && url.fragment !== null) {
                    output += "#" + url.fragment;
                }

                return output;
            }

            function serializeOrigin(tuple) {
                let result = tuple.scheme + "://";
                result += serializeHost(tuple.host);

                if (tuple.port !== null) {
                    result += ":" + tuple.port;
                }

                return result;
            }

            module.exports.serializeURL = serializeURL;

            module.exports.serializeURLOrigin = function (url) {
                // https://url.spec.whatwg.org/#concept-url-origin
                switch (url.scheme) {
                    case "blob":
                        try {
                            return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
                        } catch (e) {
                            // serializing an opaque origin returns "null"
                            return "null";
                        }
                    case "ftp":
                    case "gopher":
                    case "http":
                    case "https":
                    case "ws":
                    case "wss":
                        return serializeOrigin({
                            scheme: url.scheme,
                            host: url.host,
                            port: url.port
                        });
                    case "file":
                        // spec says "exercise to the reader", chrome says "file://"
                        return "file://";
                    default:
                        // serializing an opaque origin returns "null"
                        return "null";
                }
            };

            module.exports.basicURLParse = function (input, options) {
                if (options === undefined) {
                    options = {};
                }

                const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
                if (usm.failure) {
                    return "failure";
                }

                return usm.url;
            };

            module.exports.setTheUsername = function (url, username) {
                url.username = "";
                const decoded = punycode.ucs2.decode(username);
                for (let i = 0; i < decoded.length; ++i) {
                    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
                }
            };

            module.exports.setThePassword = function (url, password) {
                url.password = "";
                const decoded = punycode.ucs2.decode(password);
                for (let i = 0; i < decoded.length; ++i) {
                    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
                }
            };

            module.exports.serializeHost = serializeHost;

            module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

            module.exports.serializeInteger = function (integer) {
                return String(integer);
            };

            module.exports.parseURL = function (input, options) {
                if (options === undefined) {
                    options = {};
                }

                // We don't handle blobs, so this just delegates:
                return module.exports.basicURLParse(input, {
                    baseURL: options.baseURL,
                    encodingOverride: options.encodingOverride
                });
            };


            /***/
        }),
        /* 841 */,
        /* 842 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.loadConfigsForDefaultMode = void 0;
            const loadConfigsForDefaultMode = (mode) => {
                switch (mode) {
                    case "standard":
                        return {
                            retryMode: "standard",
                            connectionTimeout: 3100,
                        };
                    case "in-region":
                        return {
                            retryMode: "standard",
                            connectionTimeout: 1100,
                        };
                    case "cross-region":
                        return {
                            retryMode: "standard",
                            connectionTimeout: 3100,
                        };
                    case "mobile":
                        return {
                            retryMode: "standard",
                            connectionTimeout: 30000,
                        };
                    default:
                        return {};
                }
            };
            exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;


            /***/
        }),
        /* 843 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListIdentitiesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class ListIdentitiesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "ListIdentitiesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListIdentitiesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListIdentitiesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryListIdentitiesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryListIdentitiesCommand)(output, context);
                }
            }

            exports.ListIdentitiesCommand = ListIdentitiesCommand;


            /***/
        }),
        /* 844 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveCredentialSource = void 0;
            const credential_provider_env_1 = __webpack_require__(240);
            const credential_provider_imds_1 = __webpack_require__(272);
            const property_provider_1 = __webpack_require__(118);
            const resolveCredentialSource = (credentialSource, profileName) => {
                const sourceProvidersMap = {
                    EcsContainer: credential_provider_imds_1.fromContainerMetadata,
                    Ec2InstanceMetadata: credential_provider_imds_1.fromInstanceMetadata,
                    Environment: credential_provider_env_1.fromEnv,
                };
                if (credentialSource in sourceProvidersMap) {
                    return sourceProvidersMap[credentialSource]();
                } else {
                    throw new property_provider_1.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, ` +
                        `expected EcsContainer or Ec2InstanceMetadata or Environment.`);
                }
            };
            exports.resolveCredentialSource = resolveCredentialSource;


            /***/
        }),
        /* 845 */,
        /* 846 */,
        /* 847 */,
        /* 848 */,
        /* 849 */,
        /* 850 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getSerdePlugin = exports.serializerMiddlewareOption = exports.deserializerMiddlewareOption = void 0;
            const deserializerMiddleware_1 = __webpack_require__(11);
            const serializerMiddleware_1 = __webpack_require__(274);
            exports.deserializerMiddlewareOption = {
                name: "deserializerMiddleware",
                step: "deserialize",
                tags: ["DESERIALIZER"],
                override: true,
            };
            exports.serializerMiddlewareOption = {
                name: "serializerMiddleware",
                step: "serialize",
                tags: ["SERIALIZER"],
                override: true,
            };

            function getSerdePlugin(config, serializer, deserializer) {
                return {
                    applyToStack: (commandStack) => {
                        commandStack.add((0, deserializerMiddleware_1.deserializerMiddleware)(config, deserializer), exports.deserializerMiddlewareOption);
                        commandStack.add((0, serializerMiddleware_1.serializerMiddleware)(config, serializer), exports.serializerMiddlewareOption);
                    },
                };
            }

            exports.getSerdePlugin = getSerdePlugin;


            /***/
        }),
        /* 851 */,
        /* 852 */,
        /* 853 */,
        /* 854 */,
        /* 855 */,
        /* 856 */,
        /* 857 */,
        /* 858 */,
        /* 859 */,
        /* 860 */,
        /* 861 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetIdentityNotificationAttributesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetIdentityNotificationAttributesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetIdentityNotificationAttributesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetIdentityNotificationAttributesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetIdentityNotificationAttributesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetIdentityNotificationAttributesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetIdentityNotificationAttributesCommand)(output, context);
                }
            }

            exports.GetIdentityNotificationAttributesCommand = GetIdentityNotificationAttributesCommand;


            /***/
        }),
        /* 862 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getResolvedHostname = void 0;
            const getResolvedHostname = (resolvedRegion, {regionHostname, partitionHostname}) => regionHostname
                ? regionHostname
                : partitionHostname
                    ? partitionHostname.replace("{region}", resolvedRegion)
                    : undefined;
            exports.getResolvedHostname = getResolvedHostname;


            /***/
        }),
        /* 863 */,
        /* 864 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.CreateConfigurationSetTrackingOptionsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class CreateConfigurationSetTrackingOptionsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "CreateConfigurationSetTrackingOptionsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.CreateConfigurationSetTrackingOptionsRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.CreateConfigurationSetTrackingOptionsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryCreateConfigurationSetTrackingOptionsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryCreateConfigurationSetTrackingOptionsCommand)(output, context);
                }
            }

            exports.CreateConfigurationSetTrackingOptionsCommand = CreateConfigurationSetTrackingOptionsCommand;


            /***/
        }),
        /* 865 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.isArrayBuffer = void 0;
            const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
                Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
            exports.isArrayBuffer = isArrayBuffer;


            /***/
        }),
        /* 866 */,
        /* 867 */,
        /* 868 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.isTransientError = exports.isThrottlingError = exports.isClockSkewError = exports.isRetryableByTrait = void 0;
            const constants_1 = __webpack_require__(4);
            const isRetryableByTrait = (error) => error.$retryable !== undefined;
            exports.isRetryableByTrait = isRetryableByTrait;
            const isClockSkewError = (error) => constants_1.CLOCK_SKEW_ERROR_CODES.includes(error.name);
            exports.isClockSkewError = isClockSkewError;
            const isThrottlingError = (error) => {
                var _a, _b;
                return ((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) === 429 ||
                    constants_1.THROTTLING_ERROR_CODES.includes(error.name) ||
                    ((_b = error.$retryable) === null || _b === void 0 ? void 0 : _b.throttling) == true;
            };
            exports.isThrottlingError = isThrottlingError;
            const isTransientError = (error) => {
                var _a;
                return constants_1.TRANSIENT_ERROR_CODES.includes(error.name) ||
                    constants_1.TRANSIENT_ERROR_STATUS_CODES.includes(((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) || 0);
            };
            exports.isTransientError = isTransientError;


            /***/
        }),
        /* 869 */,
        /* 870 */
        /***/ (function (module) {

            module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1000, 1000], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6000], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8000, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8000]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9000], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [30000]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13000, 13000], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43000, 43000], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64000, 64000], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66000, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[120000, 120000], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128000, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23000]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149000]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32000]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195000, 195000], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [40000]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918000, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];

            /***/
        }),
        /* 871 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetIdentityMailFromDomainAttributesCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetIdentityMailFromDomainAttributesCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetIdentityMailFromDomainAttributesCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetIdentityMailFromDomainAttributesRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetIdentityMailFromDomainAttributesResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetIdentityMailFromDomainAttributesCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetIdentityMailFromDomainAttributesCommand)(output, context);
                }
            }

            exports.GetIdentityMailFromDomainAttributesCommand = GetIdentityMailFromDomainAttributesCommand;


            /***/
        }),
        /* 872 */,
        /* 873 */,
        /* 874 */,
        /* 875 */,
        /* 876 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getExtendedInstanceMetadataCredentials = void 0;
            const STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 15 * 60;
            const STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
            const STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
            const getExtendedInstanceMetadataCredentials = (credentials, logger) => {
                var _a;
                const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS +
                    Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
                const newExpiration = new Date(Date.now() + refreshInterval * 1000);
                logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " +
                    "credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " +
                    STATIC_STABILITY_DOC_URL);
                const originalExpiration = (_a = credentials.originalExpiration) !== null && _a !== void 0 ? _a : credentials.expiration;
                return {
                    ...credentials,
                    ...(originalExpiration ? {originalExpiration} : {}),
                    expiration: newExpiration,
                };
            };
            exports.getExtendedInstanceMetadataCredentials = getExtendedInstanceMetadataCredentials;


            /***/
        }),
        /* 877 */,
        /* 878 */,
        /* 879 */,
        /* 880 */,
        /* 881 */
        /***/ (function (module) {

            module.exports = require("dns");

            /***/
        }),
        /* 882 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            const char = function (a) {
                return String.fromCharCode(a);
            };

            const chars = {
                nilChar: char(176),
                missingChar: char(201),
                nilPremitive: char(175),
                missingPremitive: char(200),

                emptyChar: char(178),
                emptyValue: char(177), //empty Premitive

                boundryChar: char(179),

                objStart: char(198),
                arrStart: char(204),
                arrayEnd: char(185),
            };

            const charsArr = [
                chars.nilChar,
                chars.nilPremitive,
                chars.missingChar,
                chars.missingPremitive,
                chars.boundryChar,
                chars.emptyChar,
                chars.emptyValue,
                chars.arrayEnd,
                chars.objStart,
                chars.arrStart,
            ];

            const _e = function (node, e_schema, options) {
                if (typeof e_schema === 'string') {
                    //premitive
                    if (node && node[0] && node[0].val !== undefined) {
                        return getValue(node[0].val, e_schema);
                    } else {
                        return getValue(node, e_schema);
                    }
                } else {
                    const hasValidData = hasData(node);
                    if (hasValidData === true) {
                        let str = '';
                        if (Array.isArray(e_schema)) {
                            //attributes can't be repeated. hence check in children tags only
                            str += chars.arrStart;
                            const itemSchema = e_schema[0];
                            //var itemSchemaType = itemSchema;
                            const arr_len = node.length;

                            if (typeof itemSchema === 'string') {
                                for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                                    const r = getValue(node[arr_i].val, itemSchema);
                                    str = processValue(str, r);
                                }
                            } else {
                                for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                                    const r = _e(node[arr_i], itemSchema, options);
                                    str = processValue(str, r);
                                }
                            }
                            str += chars.arrayEnd; //indicates that next item is not array item
                        } else {
                            //object
                            str += chars.objStart;
                            const keys = Object.keys(e_schema);
                            if (Array.isArray(node)) {
                                node = node[0];
                            }
                            for (let i in keys) {
                                const key = keys[i];
                                //a property defined in schema can be present either in attrsMap or children tags
                                //options.textNodeName will not present in both maps, take it's value from val
                                //options.attrNodeName will be present in attrsMap
                                let r;
                                if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {
                                    r = _e(node.attrsMap[key], e_schema[key], options);
                                } else if (key === options.textNodeName) {
                                    r = _e(node.val, e_schema[key], options);
                                } else {
                                    r = _e(node.child[key], e_schema[key], options);
                                }
                                str = processValue(str, r);
                            }
                        }
                        return str;
                    } else {
                        return hasValidData;
                    }
                }
            };

            const getValue = function (a /*, type*/) {
                switch (a) {
                    case undefined:
                        return chars.missingPremitive;
                    case null:
                        return chars.nilPremitive;
                    case '':
                        return chars.emptyValue;
                    default:
                        return a;
                }
            };

            const processValue = function (str, r) {
                if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {
                    str += chars.boundryChar;
                }
                return str + r;
            };

            const isAppChar = function (ch) {
                return charsArr.indexOf(ch) !== -1;
            };

            function hasData(jObj) {
                if (jObj === undefined) {
                    return chars.missingChar;
                } else if (jObj === null) {
                    return chars.nilChar;
                } else if (
                    jObj.child &&
                    Object.keys(jObj.child).length === 0 &&
                    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)
                ) {
                    return chars.emptyChar;
                } else {
                    return true;
                }
            }

            const x2j = __webpack_require__(259);
            const buildOptions = __webpack_require__(176).buildOptions;

            const convert2nimn = function (node, e_schema, options) {
                options = buildOptions(options, x2j.defaultOptions, x2j.props);
                return _e(node, e_schema, options);
            };

            exports.convert2nimn = convert2nimn;


            /***/
        }),
        /* 883 */,
        /* 884 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const EventEmitter = __webpack_require__(614);
            const PoolResource = __webpack_require__(897);
            const SMTPConnection = __webpack_require__(580);
            const wellKnown = __webpack_require__(999);
            const shared = __webpack_require__(190);
            const packageData = __webpack_require__(786);

            /**
             * Creates a SMTP pool transport object for Nodemailer
             *
             * @constructor
             * @param {Object} options SMTP Connection options
             */
            class SMTPPool extends EventEmitter {
                constructor(options) {
                    super();

                    options = options || {};
                    if (typeof options === 'string') {
                        options = {
                            url: options
                        };
                    }

                    let urlData;
                    let service = options.service;

                    if (typeof options.getSocket === 'function') {
                        this.getSocket = options.getSocket;
                    }

                    if (options.url) {
                        urlData = shared.parseConnectionUrl(options.url);
                        service = service || urlData.service;
                    }

                    this.options = shared.assign(
                        false, // create new object
                        options, // regular options
                        urlData, // url options
                        service && wellKnown(service) // wellknown options
                    );

                    this.options.maxConnections = this.options.maxConnections || 5;
                    this.options.maxMessages = this.options.maxMessages || 100;

                    this.logger = shared.getLogger(this.options, {
                        component: this.options.component || 'smtp-pool'
                    });

                    // temporary object
                    let connection = new SMTPConnection(this.options);

                    this.name = 'SMTP (pool)';
                    this.version = packageData.version + '[client:' + connection.version + ']';

                    this._rateLimit = {
                        counter: 0,
                        timeout: null,
                        waiting: [],
                        checkpoint: false,
                        delta: Number(this.options.rateDelta) || 1000,
                        limit: Number(this.options.rateLimit) || 0
                    };
                    this._closed = false;
                    this._queue = [];
                    this._connections = [];
                    this._connectionCounter = 0;

                    this.idling = true;

                    setImmediate(() => {
                        if (this.idling) {
                            this.emit('idle');
                        }
                    });
                }

                /**
                 * Placeholder function for creating proxy sockets. This method immediatelly returns
                 * without a socket
                 *
                 * @param {Object} options Connection options
                 * @param {Function} callback Callback function to run with the socket keys
                 */
                getSocket(options, callback) {
                    // return immediatelly
                    return setImmediate(() => callback(null, false));
                }

                /**
                 * Queues an e-mail to be sent using the selected settings
                 *
                 * @param {Object} mail Mail object
                 * @param {Function} callback Callback function
                 */
                send(mail, callback) {
                    if (this._closed) {
                        return false;
                    }

                    this._queue.push({
                        mail,
                        requeueAttempts: 0,
                        callback
                    });

                    if (this.idling && this._queue.length >= this.options.maxConnections) {
                        this.idling = false;
                    }

                    setImmediate(() => this._processMessages());

                    return true;
                }

                /**
                 * Closes all connections in the pool. If there is a message being sent, the connection
                 * is closed later
                 */
                close() {
                    let connection;
                    let len = this._connections.length;
                    this._closed = true;

                    // clear rate limit timer if it exists
                    clearTimeout(this._rateLimit.timeout);

                    if (!len && !this._queue.length) {
                        return;
                    }

                    // remove all available connections
                    for (let i = len - 1; i >= 0; i--) {
                        if (this._connections[i] && this._connections[i].available) {
                            connection = this._connections[i];
                            connection.close();
                            this.logger.info(
                                {
                                    tnx: 'connection',
                                    cid: connection.id,
                                    action: 'removed'
                                },
                                'Connection #%s removed',
                                connection.id
                            );
                        }
                    }

                    if (len && !this._connections.length) {
                        this.logger.debug(
                            {
                                tnx: 'connection'
                            },
                            'All connections removed'
                        );
                    }

                    if (!this._queue.length) {
                        return;
                    }

                    // make sure that entire queue would be cleaned
                    let invokeCallbacks = () => {
                        if (!this._queue.length) {
                            this.logger.debug(
                                {
                                    tnx: 'connection'
                                },
                                'Pending queue entries cleared'
                            );
                            return;
                        }
                        let entry = this._queue.shift();
                        if (entry && typeof entry.callback === 'function') {
                            try {
                                entry.callback(new Error('Connection pool was closed'));
                            } catch (E) {
                                this.logger.error(
                                    {
                                        err: E,
                                        tnx: 'callback',
                                        cid: connection.id
                                    },
                                    'Callback error for #%s: %s',
                                    connection.id,
                                    E.message
                                );
                            }
                        }
                        setImmediate(invokeCallbacks);
                    };
                    setImmediate(invokeCallbacks);
                }

                /**
                 * Check the queue and available connections. If there is a message to be sent and there is
                 * an available connection, then use this connection to send the mail
                 */
                _processMessages() {
                    let connection;
                    let i, len;

                    // do nothing if already closed
                    if (this._closed) {
                        return;
                    }

                    // do nothing if queue is empty
                    if (!this._queue.length) {
                        if (!this.idling) {
                            // no pending jobs
                            this.idling = true;
                            this.emit('idle');
                        }
                        return;
                    }

                    // find first available connection
                    for (i = 0, len = this._connections.length; i < len; i++) {
                        if (this._connections[i].available) {
                            connection = this._connections[i];
                            break;
                        }
                    }

                    if (!connection && this._connections.length < this.options.maxConnections) {
                        connection = this._createConnection();
                    }

                    if (!connection) {
                        // no more free connection slots available
                        this.idling = false;
                        return;
                    }

                    // check if there is free space in the processing queue
                    if (!this.idling && this._queue.length < this.options.maxConnections) {
                        this.idling = true;
                        this.emit('idle');
                    }

                    let entry = (connection.queueEntry = this._queue.shift());
                    entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\s]/g, '');

                    connection.available = false;

                    this.logger.debug(
                        {
                            tnx: 'pool',
                            cid: connection.id,
                            messageId: entry.messageId,
                            action: 'assign'
                        },
                        'Assigned message <%s> to #%s (%s)',
                        entry.messageId,
                        connection.id,
                        connection.messages + 1
                    );

                    if (this._rateLimit.limit) {
                        this._rateLimit.counter++;
                        if (!this._rateLimit.checkpoint) {
                            this._rateLimit.checkpoint = Date.now();
                        }
                    }

                    connection.send(entry.mail, (err, info) => {
                        // only process callback if current handler is not changed
                        if (entry === connection.queueEntry) {
                            try {
                                entry.callback(err, info);
                            } catch (E) {
                                this.logger.error(
                                    {
                                        err: E,
                                        tnx: 'callback',
                                        cid: connection.id
                                    },
                                    'Callback error for #%s: %s',
                                    connection.id,
                                    E.message
                                );
                            }
                            connection.queueEntry = false;
                        }
                    });
                }

                /**
                 * Creates a new pool resource
                 */
                _createConnection() {
                    let connection = new PoolResource(this);

                    connection.id = ++this._connectionCounter;

                    this.logger.info(
                        {
                            tnx: 'pool',
                            cid: connection.id,
                            action: 'conection'
                        },
                        'Created new pool resource #%s',
                        connection.id
                    );

                    // resource comes available
                    connection.on('available', () => {
                        this.logger.debug(
                            {
                                tnx: 'connection',
                                cid: connection.id,
                                action: 'available'
                            },
                            'Connection #%s became available',
                            connection.id
                        );

                        if (this._closed) {
                            // if already closed run close() that will remove this connections from connections list
                            this.close();
                        } else {
                            // check if there's anything else to send
                            this._processMessages();
                        }
                    });

                    // resource is terminated with an error
                    connection.once('error', err => {
                        if (err.code !== 'EMAXLIMIT') {
                            this.logger.error(
                                {
                                    err,
                                    tnx: 'pool',
                                    cid: connection.id
                                },
                                'Pool Error for #%s: %s',
                                connection.id,
                                err.message
                            );
                        } else {
                            this.logger.debug(
                                {
                                    tnx: 'pool',
                                    cid: connection.id,
                                    action: 'maxlimit'
                                },
                                'Max messages limit exchausted for #%s',
                                connection.id
                            );
                        }

                        if (connection.queueEntry) {
                            try {
                                connection.queueEntry.callback(err);
                            } catch (E) {
                                this.logger.error(
                                    {
                                        err: E,
                                        tnx: 'callback',
                                        cid: connection.id
                                    },
                                    'Callback error for #%s: %s',
                                    connection.id,
                                    E.message
                                );
                            }
                            connection.queueEntry = false;
                        }

                        // remove the erroneus connection from connections list
                        this._removeConnection(connection);

                        this._continueProcessing();
                    });

                    connection.once('close', () => {
                        this.logger.info(
                            {
                                tnx: 'connection',
                                cid: connection.id,
                                action: 'closed'
                            },
                            'Connection #%s was closed',
                            connection.id
                        );

                        this._removeConnection(connection);

                        if (connection.queueEntry) {
                            // If the connection closed when sending, add the message to the queue again
                            // if max number of requeues is not reached yet
                            // Note that we must wait a bit.. because the callback of the 'error' handler might be called
                            // in the next event loop
                            setTimeout(() => {
                                if (connection.queueEntry) {
                                    if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {
                                        this._requeueEntryOnConnectionClose(connection);
                                    } else {
                                        this._failDeliveryOnConnectionClose(connection);
                                    }
                                }
                                this._continueProcessing();
                            }, 50);
                        } else {
                            this._continueProcessing();
                        }
                    });

                    this._connections.push(connection);

                    return connection;
                }

                _shouldRequeuOnConnectionClose(queueEntry) {
                    if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {
                        return true;
                    }

                    return queueEntry.requeueAttempts < this.options.maxRequeues;
                }

                _failDeliveryOnConnectionClose(connection) {
                    if (connection.queueEntry && connection.queueEntry.callback) {
                        try {
                            connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));
                        } catch (E) {
                            this.logger.error(
                                {
                                    err: E,
                                    tnx: 'callback',
                                    messageId: connection.queueEntry.messageId,
                                    cid: connection.id
                                },
                                'Callback error for #%s: %s',
                                connection.id,
                                E.message
                            );
                        }
                        connection.queueEntry = false;
                    }
                }

                _requeueEntryOnConnectionClose(connection) {
                    connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;
                    this.logger.debug(
                        {
                            tnx: 'pool',
                            cid: connection.id,
                            messageId: connection.queueEntry.messageId,
                            action: 'requeue'
                        },
                        'Re-queued message <%s> for #%s. Attempt: #%s',
                        connection.queueEntry.messageId,
                        connection.id,
                        connection.queueEntry.requeueAttempts
                    );
                    this._queue.unshift(connection.queueEntry);
                    connection.queueEntry = false;
                }

                /**
                 * Continue to process message if the pool hasn't closed
                 */
                _continueProcessing() {
                    if (this._closed) {
                        this.close();
                    } else {
                        setTimeout(() => this._processMessages(), 100);
                    }
                }

                /**
                 * Remove resource from pool
                 *
                 * @param {Object} connection The PoolResource to remove
                 */
                _removeConnection(connection) {
                    let index = this._connections.indexOf(connection);

                    if (index !== -1) {
                        this._connections.splice(index, 1);
                    }
                }

                /**
                 * Checks if connections have hit current rate limit and if so, queues the availability callback
                 *
                 * @param {Function} callback Callback function to run once rate limiter has been cleared
                 */
                _checkRateLimit(callback) {
                    if (!this._rateLimit.limit) {
                        return callback();
                    }

                    let now = Date.now();

                    if (this._rateLimit.counter < this._rateLimit.limit) {
                        return callback();
                    }

                    this._rateLimit.waiting.push(callback);

                    if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {
                        return this._clearRateLimit();
                    } else if (!this._rateLimit.timeout) {
                        this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));
                        this._rateLimit.checkpoint = now;
                    }
                }

                /**
                 * Clears current rate limit limitation and runs paused callback
                 */
                _clearRateLimit() {
                    clearTimeout(this._rateLimit.timeout);
                    this._rateLimit.timeout = null;
                    this._rateLimit.counter = 0;
                    this._rateLimit.checkpoint = false;

                    // resume all paused connections
                    while (this._rateLimit.waiting.length) {
                        let cb = this._rateLimit.waiting.shift();
                        setImmediate(cb);
                    }
                }

                /**
                 * Returns true if there are free slots in the queue
                 */
                isIdle() {
                    return this.idling;
                }

                /**
                 * Verifies SMTP configuration
                 *
                 * @param {Function} callback Callback function
                 */
                verify(callback) {
                    let promise;

                    if (!callback) {
                        promise = new Promise((resolve, reject) => {
                            callback = shared.callbackPromise(resolve, reject);
                        });
                    }

                    let auth = new PoolResource(this).auth;

                    this.getSocket(this.options, (err, socketOptions) => {
                        if (err) {
                            return callback(err);
                        }

                        let options = this.options;
                        if (socketOptions && socketOptions.connection) {
                            this.logger.info(
                                {
                                    tnx: 'proxy',
                                    remoteAddress: socketOptions.connection.remoteAddress,
                                    remotePort: socketOptions.connection.remotePort,
                                    destHost: options.host || '',
                                    destPort: options.port || '',
                                    action: 'connected'
                                },
                                'Using proxied socket from %s:%s to %s:%s',
                                socketOptions.connection.remoteAddress,
                                socketOptions.connection.remotePort,
                                options.host || '',
                                options.port || ''
                            );
                            options = shared.assign(false, options);
                            Object.keys(socketOptions).forEach(key => {
                                options[key] = socketOptions[key];
                            });
                        }

                        let connection = new SMTPConnection(options);
                        let returned = false;

                        connection.once('error', err => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            connection.close();
                            return callback(err);
                        });

                        connection.once('end', () => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            return callback(new Error('Connection closed'));
                        });

                        let finalize = () => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            connection.quit();
                            return callback(null, true);
                        };

                        connection.connect(() => {
                            if (returned) {
                                return;
                            }

                            if (auth && (connection.allowsAuth || options.forceAuth)) {
                                connection.login(auth, err => {
                                    if (returned) {
                                        return;
                                    }

                                    if (err) {
                                        returned = true;
                                        connection.close();
                                        return callback(err);
                                    }

                                    finalize();
                                });
                            } else {
                                finalize();
                            }
                        });
                    });

                    return promise;
                }
            }

// expose to the world
            module.exports = SMTPPool;


            /***/
        }),
        /* 885 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(936), exports);
            tslib_1.__exportStar(__webpack_require__(532), exports);


            /***/
        }),
        /* 886 */,
        /* 887 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _v = _interopRequireDefault(__webpack_require__(541));

            var _sha = _interopRequireDefault(__webpack_require__(228));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            const v5 = (0, _v.default)('v5', 0x50, _sha.default);
            var _default = v5;
            exports.default = _default;

            /***/
        }),
        /* 888 */,
        /* 889 */,
        /* 890 */,
        /* 891 */,
        /* 892 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRuntimeConfig = void 0;
            const tslib_1 = __webpack_require__(84);
            const package_json_1 = tslib_1.__importDefault(__webpack_require__(145));
            const client_sts_1 = __webpack_require__(231);
            const config_resolver_1 = __webpack_require__(772);
            const credential_provider_node_1 = __webpack_require__(277);
            const hash_node_1 = __webpack_require__(974);
            const middleware_retry_1 = __webpack_require__(806);
            const node_config_provider_1 = __webpack_require__(588);
            const node_http_handler_1 = __webpack_require__(720);
            const util_base64_node_1 = __webpack_require__(295);
            const util_body_length_node_1 = __webpack_require__(237);
            const util_user_agent_node_1 = __webpack_require__(623);
            const util_utf8_node_1 = __webpack_require__(495);
            const runtimeConfig_shared_1 = __webpack_require__(689);
            const smithy_client_1 = __webpack_require__(449);
            const util_defaults_mode_node_1 = __webpack_require__(770);
            const getRuntimeConfig = (config) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
                const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
                const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
                const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
                return {
                    ...clientSharedValues,
                    ...config,
                    runtime: "node",
                    defaultsMode,
                    base64Decoder: (_a = config === null || config === void 0 ? void 0 : config.base64Decoder) !== null && _a !== void 0 ? _a : util_base64_node_1.fromBase64,
                    base64Encoder: (_b = config === null || config === void 0 ? void 0 : config.base64Encoder) !== null && _b !== void 0 ? _b : util_base64_node_1.toBase64,
                    bodyLengthChecker: (_c = config === null || config === void 0 ? void 0 : config.bodyLengthChecker) !== null && _c !== void 0 ? _c : util_body_length_node_1.calculateBodyLength,
                    credentialDefaultProvider: (_d = config === null || config === void 0 ? void 0 : config.credentialDefaultProvider) !== null && _d !== void 0 ? _d : (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
                    defaultUserAgentProvider: (_e = config === null || config === void 0 ? void 0 : config.defaultUserAgentProvider) !== null && _e !== void 0 ? _e : (0, util_user_agent_node_1.defaultUserAgent)({
                        serviceId: clientSharedValues.serviceId,
                        clientVersion: package_json_1.default.version
                    }),
                    maxAttempts: (_f = config === null || config === void 0 ? void 0 : config.maxAttempts) !== null && _f !== void 0 ? _f : (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
                    region: (_g = config === null || config === void 0 ? void 0 : config.region) !== null && _g !== void 0 ? _g : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
                    requestHandler: (_h = config === null || config === void 0 ? void 0 : config.requestHandler) !== null && _h !== void 0 ? _h : new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
                    retryMode: (_j = config === null || config === void 0 ? void 0 : config.retryMode) !== null && _j !== void 0 ? _j : (0, node_config_provider_1.loadConfig)({
                        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                        default: async () => (await defaultConfigProvider()).retryMode || middleware_retry_1.DEFAULT_RETRY_MODE,
                    }),
                    sha256: (_k = config === null || config === void 0 ? void 0 : config.sha256) !== null && _k !== void 0 ? _k : hash_node_1.Hash.bind(null, "sha256"),
                    streamCollector: (_l = config === null || config === void 0 ? void 0 : config.streamCollector) !== null && _l !== void 0 ? _l : node_http_handler_1.streamCollector,
                    useDualstackEndpoint: (_m = config === null || config === void 0 ? void 0 : config.useDualstackEndpoint) !== null && _m !== void 0 ? _m : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
                    useFipsEndpoint: (_o = config === null || config === void 0 ? void 0 : config.useFipsEndpoint) !== null && _o !== void 0 ? _o : (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
                    utf8Decoder: (_p = config === null || config === void 0 ? void 0 : config.utf8Decoder) !== null && _p !== void 0 ? _p : util_utf8_node_1.fromUtf8,
                    utf8Encoder: (_q = config === null || config === void 0 ? void 0 : config.utf8Encoder) !== null && _q !== void 0 ? _q : util_utf8_node_1.toUtf8,
                };
            };
            exports.getRuntimeConfig = getRuntimeConfig;


            /***/
        }),
        /* 893 */,
        /* 894 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ENDPOINT_MODE_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_MODE_NAME = exports.ENV_ENDPOINT_MODE_NAME = void 0;
            const EndpointMode_1 = __webpack_require__(130);
            exports.ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
            exports.CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
            exports.ENDPOINT_MODE_CONFIG_OPTIONS = {
                environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_MODE_NAME],
                configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_MODE_NAME],
                default: EndpointMode_1.EndpointMode.IPv4,
            };


            /***/
        }),
        /* 895 */,
        /* 896 */,
        /* 897 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const SMTPConnection = __webpack_require__(580);
            const assign = __webpack_require__(190).assign;
            const XOAuth2 = __webpack_require__(800);
            const EventEmitter = __webpack_require__(614);

            /**
             * Creates an element for the pool
             *
             * @constructor
             * @param {Object} options SMTPPool instance
             */
            class PoolResource extends EventEmitter {
                constructor(pool) {
                    super();

                    this.pool = pool;
                    this.options = pool.options;
                    this.logger = this.pool.logger;

                    if (this.options.auth) {
                        switch ((this.options.auth.type || '').toString().toUpperCase()) {
                            case 'OAUTH2': {
                                let oauth2 = new XOAuth2(this.options.auth, this.logger);
                                oauth2.provisionCallback = (this.pool.mailer && this.pool.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;
                                this.auth = {
                                    type: 'OAUTH2',
                                    user: this.options.auth.user,
                                    oauth2,
                                    method: 'XOAUTH2'
                                };
                                oauth2.on('token', token => this.pool.mailer.emit('token', token));
                                oauth2.on('error', err => this.emit('error', err));
                                break;
                            }
                            default:
                                if (!this.options.auth.user && !this.options.auth.pass) {
                                    break;
                                }
                                this.auth = {
                                    type: (this.options.auth.type || '').toString().toUpperCase() || 'LOGIN',
                                    user: this.options.auth.user,
                                    credentials: {
                                        user: this.options.auth.user || '',
                                        pass: this.options.auth.pass,
                                        options: this.options.auth.options
                                    },
                                    method: (this.options.auth.method || '').trim().toUpperCase() || this.options.authMethod || false
                                };
                        }
                    }

                    this._connection = false;
                    this._connected = false;

                    this.messages = 0;
                    this.available = true;
                }

                /**
                 * Initiates a connection to the SMTP server
                 *
                 * @param {Function} callback Callback function to run once the connection is established or failed
                 */
                connect(callback) {
                    this.pool.getSocket(this.options, (err, socketOptions) => {
                        if (err) {
                            return callback(err);
                        }

                        let returned = false;
                        let options = this.options;
                        if (socketOptions && socketOptions.connection) {
                            this.logger.info(
                                {
                                    tnx: 'proxy',
                                    remoteAddress: socketOptions.connection.remoteAddress,
                                    remotePort: socketOptions.connection.remotePort,
                                    destHost: options.host || '',
                                    destPort: options.port || '',
                                    action: 'connected'
                                },
                                'Using proxied socket from %s:%s to %s:%s',
                                socketOptions.connection.remoteAddress,
                                socketOptions.connection.remotePort,
                                options.host || '',
                                options.port || ''
                            );

                            options = assign(false, options);
                            Object.keys(socketOptions).forEach(key => {
                                options[key] = socketOptions[key];
                            });
                        }

                        this.connection = new SMTPConnection(options);

                        this.connection.once('error', err => {
                            this.emit('error', err);
                            if (returned) {
                                return;
                            }
                            returned = true;
                            return callback(err);
                        });

                        this.connection.once('end', () => {
                            this.close();
                            if (returned) {
                                return;
                            }
                            returned = true;

                            let timer = setTimeout(() => {
                                if (returned) {
                                    return;
                                }
                                // still have not returned, this means we have an unexpected connection close
                                let err = new Error('Unexpected socket close');
                                if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
                                    // starttls connection errors
                                    err.code = 'ETLS';
                                }
                                callback(err);
                            }, 1000);

                            try {
                                timer.unref();
                            } catch (E) {
                                // Ignore. Happens on envs with non-node timer implementation
                            }
                        });

                        this.connection.connect(() => {
                            if (returned) {
                                return;
                            }

                            if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
                                this.connection.login(this.auth, err => {
                                    if (returned) {
                                        return;
                                    }
                                    returned = true;

                                    if (err) {
                                        this.connection.close();
                                        this.emit('error', err);
                                        return callback(err);
                                    }

                                    this._connected = true;
                                    callback(null, true);
                                });
                            } else {
                                returned = true;
                                this._connected = true;
                                return callback(null, true);
                            }
                        });
                    });
                }

                /**
                 * Sends an e-mail to be sent using the selected settings
                 *
                 * @param {Object} mail Mail object
                 * @param {Function} callback Callback function
                 */
                send(mail, callback) {
                    if (!this._connected) {
                        return this.connect(err => {
                            if (err) {
                                return callback(err);
                            }
                            return this.send(mail, callback);
                        });
                    }

                    let envelope = mail.message.getEnvelope();
                    let messageId = mail.message.messageId();

                    let recipients = [].concat(envelope.to || []);
                    if (recipients.length > 3) {
                        recipients.push('...and ' + recipients.splice(2).length + ' more');
                    }
                    this.logger.info(
                        {
                            tnx: 'send',
                            messageId,
                            cid: this.id
                        },
                        'Sending message %s using #%s to <%s>',
                        messageId,
                        this.id,
                        recipients.join(', ')
                    );

                    if (mail.data.dsn) {
                        envelope.dsn = mail.data.dsn;
                    }

                    this.connection.send(envelope, mail.message.createReadStream(), (err, info) => {
                        this.messages++;

                        if (err) {
                            this.connection.close();
                            this.emit('error', err);
                            return callback(err);
                        }

                        info.envelope = {
                            from: envelope.from,
                            to: envelope.to
                        };
                        info.messageId = messageId;

                        setImmediate(() => {
                            let err;
                            if (this.messages >= this.options.maxMessages) {
                                err = new Error('Resource exhausted');
                                err.code = 'EMAXLIMIT';
                                this.connection.close();
                                this.emit('error', err);
                            } else {
                                this.pool._checkRateLimit(() => {
                                    this.available = true;
                                    this.emit('available');
                                });
                            }
                        });

                        callback(null, info);
                    });
                }

                /**
                 * Closes the connection
                 */
                close() {
                    this._connected = false;
                    if (this.auth && this.auth.oauth2) {
                        this.auth.oauth2.removeAllListeners();
                    }
                    if (this.connection) {
                        this.connection.close();
                    }
                    this.emit('close');
                }
            }

            module.exports = PoolResource;


            /***/
        }),
        /* 898 */,
        /* 899 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getInstanceMetadataEndpoint = void 0;
            const node_config_provider_1 = __webpack_require__(588);
            const url_parser_1 = __webpack_require__(834);
            const Endpoint_1 = __webpack_require__(937);
            const EndpointConfigOptions_1 = __webpack_require__(387);
            const EndpointMode_1 = __webpack_require__(130);
            const EndpointModeConfigOptions_1 = __webpack_require__(894);
            const getInstanceMetadataEndpoint = async () => (0, url_parser_1.parseUrl)((await getFromEndpointConfig()) || (await getFromEndpointModeConfig()));
            exports.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
            const getFromEndpointConfig = async () => (0, node_config_provider_1.loadConfig)(EndpointConfigOptions_1.ENDPOINT_CONFIG_OPTIONS)();
            const getFromEndpointModeConfig = async () => {
                const endpointMode = await (0, node_config_provider_1.loadConfig)(EndpointModeConfigOptions_1.ENDPOINT_MODE_CONFIG_OPTIONS)();
                switch (endpointMode) {
                    case EndpointMode_1.EndpointMode.IPv4:
                        return Endpoint_1.Endpoint.IPv4;
                    case EndpointMode_1.EndpointMode.IPv6:
                        return Endpoint_1.Endpoint.IPv6;
                    default:
                        throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode_1.EndpointMode)}`);
                }
            };


            /***/
        }),
        /* 900 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.defaultRegionInfoProvider = void 0;
            const config_resolver_1 = __webpack_require__(772);
            const regionHash = {
                "ap-northeast-1": {
                    variants: [
                        {
                            hostname: "portal.sso.ap-northeast-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "ap-northeast-1",
                },
                "ap-northeast-2": {
                    variants: [
                        {
                            hostname: "portal.sso.ap-northeast-2.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "ap-northeast-2",
                },
                "ap-south-1": {
                    variants: [
                        {
                            hostname: "portal.sso.ap-south-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "ap-south-1",
                },
                "ap-southeast-1": {
                    variants: [
                        {
                            hostname: "portal.sso.ap-southeast-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "ap-southeast-1",
                },
                "ap-southeast-2": {
                    variants: [
                        {
                            hostname: "portal.sso.ap-southeast-2.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "ap-southeast-2",
                },
                "ca-central-1": {
                    variants: [
                        {
                            hostname: "portal.sso.ca-central-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "ca-central-1",
                },
                "eu-central-1": {
                    variants: [
                        {
                            hostname: "portal.sso.eu-central-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "eu-central-1",
                },
                "eu-north-1": {
                    variants: [
                        {
                            hostname: "portal.sso.eu-north-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "eu-north-1",
                },
                "eu-west-1": {
                    variants: [
                        {
                            hostname: "portal.sso.eu-west-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "eu-west-1",
                },
                "eu-west-2": {
                    variants: [
                        {
                            hostname: "portal.sso.eu-west-2.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "eu-west-2",
                },
                "eu-west-3": {
                    variants: [
                        {
                            hostname: "portal.sso.eu-west-3.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "eu-west-3",
                },
                "sa-east-1": {
                    variants: [
                        {
                            hostname: "portal.sso.sa-east-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "sa-east-1",
                },
                "us-east-1": {
                    variants: [
                        {
                            hostname: "portal.sso.us-east-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "us-east-1",
                },
                "us-east-2": {
                    variants: [
                        {
                            hostname: "portal.sso.us-east-2.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "us-east-2",
                },
                "us-gov-east-1": {
                    variants: [
                        {
                            hostname: "portal.sso.us-gov-east-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "us-gov-east-1",
                },
                "us-gov-west-1": {
                    variants: [
                        {
                            hostname: "portal.sso.us-gov-west-1.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "us-gov-west-1",
                },
                "us-west-2": {
                    variants: [
                        {
                            hostname: "portal.sso.us-west-2.amazonaws.com",
                            tags: [],
                        },
                    ],
                    signingRegion: "us-west-2",
                },
            };
            const partitionHash = {
                aws: {
                    regions: [
                        "af-south-1",
                        "ap-east-1",
                        "ap-northeast-1",
                        "ap-northeast-2",
                        "ap-northeast-3",
                        "ap-south-1",
                        "ap-southeast-1",
                        "ap-southeast-2",
                        "ap-southeast-3",
                        "ca-central-1",
                        "eu-central-1",
                        "eu-north-1",
                        "eu-south-1",
                        "eu-west-1",
                        "eu-west-2",
                        "eu-west-3",
                        "me-south-1",
                        "sa-east-1",
                        "us-east-1",
                        "us-east-2",
                        "us-west-1",
                        "us-west-2",
                    ],
                    regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "portal.sso.{region}.amazonaws.com",
                            tags: [],
                        },
                        {
                            hostname: "portal.sso-fips.{region}.amazonaws.com",
                            tags: ["fips"],
                        },
                        {
                            hostname: "portal.sso-fips.{region}.api.aws",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "portal.sso.{region}.api.aws",
                            tags: ["dualstack"],
                        },
                    ],
                },
                "aws-cn": {
                    regions: ["cn-north-1", "cn-northwest-1"],
                    regionRegex: "^cn\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "portal.sso.{region}.amazonaws.com.cn",
                            tags: [],
                        },
                        {
                            hostname: "portal.sso-fips.{region}.amazonaws.com.cn",
                            tags: ["fips"],
                        },
                        {
                            hostname: "portal.sso-fips.{region}.api.amazonwebservices.com.cn",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "portal.sso.{region}.api.amazonwebservices.com.cn",
                            tags: ["dualstack"],
                        },
                    ],
                },
                "aws-iso": {
                    regions: ["us-iso-east-1", "us-iso-west-1"],
                    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "portal.sso.{region}.c2s.ic.gov",
                            tags: [],
                        },
                        {
                            hostname: "portal.sso-fips.{region}.c2s.ic.gov",
                            tags: ["fips"],
                        },
                    ],
                },
                "aws-iso-b": {
                    regions: ["us-isob-east-1"],
                    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "portal.sso.{region}.sc2s.sgov.gov",
                            tags: [],
                        },
                        {
                            hostname: "portal.sso-fips.{region}.sc2s.sgov.gov",
                            tags: ["fips"],
                        },
                    ],
                },
                "aws-us-gov": {
                    regions: ["us-gov-east-1", "us-gov-west-1"],
                    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
                    variants: [
                        {
                            hostname: "portal.sso.{region}.amazonaws.com",
                            tags: [],
                        },
                        {
                            hostname: "portal.sso-fips.{region}.amazonaws.com",
                            tags: ["fips"],
                        },
                        {
                            hostname: "portal.sso-fips.{region}.api.aws",
                            tags: ["dualstack", "fips"],
                        },
                        {
                            hostname: "portal.sso.{region}.api.aws",
                            tags: ["dualstack"],
                        },
                    ],
                },
            };
            const defaultRegionInfoProvider = async (region, options) => (0, config_resolver_1.getRegionInfo)(region, {
                ...options,
                signingService: "awsssoportal",
                regionHash,
                partitionHash,
            });
            exports.defaultRegionInfoProvider = defaultRegionInfoProvider;


            /***/
        }),
        /* 901 */,
        /* 902 */,
        /* 903 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.NodeHttpHandler = void 0;
            const protocol_http_1 = __webpack_require__(197);
            const querystring_builder_1 = __webpack_require__(242);
            const http_1 = __webpack_require__(605);
            const https_1 = __webpack_require__(211);
            const constants_1 = __webpack_require__(243);
            const get_transformed_headers_1 = __webpack_require__(797);
            const set_connection_timeout_1 = __webpack_require__(948);
            const set_socket_timeout_1 = __webpack_require__(633);
            const write_request_body_1 = __webpack_require__(367);

            class NodeHttpHandler {
                constructor(options) {
                    this.metadata = {handlerProtocol: "http/1.1"};
                    if (typeof options === "function") {
                        this.configProvider = async () => {
                            return this.resolveDefaultConfig(await options());
                        };
                    } else {
                        this.config = this.resolveDefaultConfig(options);
                    }
                }

                resolveDefaultConfig(options) {
                    const {connectionTimeout, socketTimeout, httpAgent, httpsAgent} = options || {};
                    const keepAlive = true;
                    const maxSockets = 50;
                    return {
                        connectionTimeout,
                        socketTimeout,
                        httpAgent: httpAgent || new http_1.Agent({keepAlive, maxSockets}),
                        httpsAgent: httpsAgent || new https_1.Agent({keepAlive, maxSockets}),
                    };
                }

                destroy() {
                    var _a, _b, _c, _d;
                    (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.httpAgent) === null || _b === void 0 ? void 0 : _b.destroy();
                    (_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.httpsAgent) === null || _d === void 0 ? void 0 : _d.destroy();
                }

                async handle(request, {abortSignal} = {}) {
                    if (!this.config && this.configProvider) {
                        this.config = await this.configProvider();
                    }
                    return new Promise((resolve, reject) => {
                        if (!this.config) {
                            throw new Error("Node HTTP request handler config is not resolved");
                        }
                        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                            const abortError = new Error("Request aborted");
                            abortError.name = "AbortError";
                            reject(abortError);
                            return;
                        }
                        const isSSL = request.protocol === "https:";
                        const queryString = (0, querystring_builder_1.buildQueryString)(request.query || {});
                        const nodeHttpsOptions = {
                            headers: request.headers,
                            host: request.hostname,
                            method: request.method,
                            path: queryString ? `${request.path}?${queryString}` : request.path,
                            port: request.port,
                            agent: isSSL ? this.config.httpsAgent : this.config.httpAgent,
                        };
                        const requestFunc = isSSL ? https_1.request : http_1.request;
                        const req = requestFunc(nodeHttpsOptions, (res) => {
                            const httpResponse = new protocol_http_1.HttpResponse({
                                statusCode: res.statusCode || -1,
                                headers: (0, get_transformed_headers_1.getTransformedHeaders)(res.headers),
                                body: res,
                            });
                            resolve({response: httpResponse});
                        });
                        req.on("error", (err) => {
                            if (constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                                reject(Object.assign(err, {name: "TimeoutError"}));
                            } else {
                                reject(err);
                            }
                        });
                        (0, set_connection_timeout_1.setConnectionTimeout)(req, reject, this.config.connectionTimeout);
                        (0, set_socket_timeout_1.setSocketTimeout)(req, reject, this.config.socketTimeout);
                        if (abortSignal) {
                            abortSignal.onabort = () => {
                                req.abort();
                                const abortError = new Error("Request aborted");
                                abortError.name = "AbortError";
                                reject(abortError);
                            };
                        }
                        (0, write_request_body_1.writeRequestBody)(req, request);
                    });
                }
            }

            exports.NodeHttpHandler = NodeHttpHandler;


            /***/
        }),
        /* 904 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.LogoutCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(518);
            const Aws_restJson1_1 = __webpack_require__(492);

            class LogoutCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SSOClient";
                    const commandName = "LogoutCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.LogoutRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_restJson1_1.serializeAws_restJson1LogoutCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_restJson1_1.deserializeAws_restJson1LogoutCommand)(output, context);
                }
            }

            exports.LogoutCommand = LogoutCommand;


            /***/
        }),
        /* 905 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromTokenFile = void 0;
            const property_provider_1 = __webpack_require__(118);
            const fs_1 = __webpack_require__(747);
            const fromWebToken_1 = __webpack_require__(591);
            const ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
            const ENV_ROLE_ARN = "AWS_ROLE_ARN";
            const ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
            const fromTokenFile = (init = {}) => async () => {
                return resolveTokenFile(init);
            };
            exports.fromTokenFile = fromTokenFile;
            const resolveTokenFile = (init) => {
                var _a, _b, _c;
                const webIdentityTokenFile = (_a = init === null || init === void 0 ? void 0 : init.webIdentityTokenFile) !== null && _a !== void 0 ? _a : process.env[ENV_TOKEN_FILE];
                const roleArn = (_b = init === null || init === void 0 ? void 0 : init.roleArn) !== null && _b !== void 0 ? _b : process.env[ENV_ROLE_ARN];
                const roleSessionName = (_c = init === null || init === void 0 ? void 0 : init.roleSessionName) !== null && _c !== void 0 ? _c : process.env[ENV_ROLE_SESSION_NAME];
                if (!webIdentityTokenFile || !roleArn) {
                    throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified");
                }
                return (0, fromWebToken_1.fromWebToken)({
                    ...init,
                    webIdentityToken: (0, fs_1.readFileSync)(webIdentityTokenFile, {encoding: "ascii"}),
                    roleArn,
                    roleSessionName,
                })();
            };


            /***/
        }),
        /* 906 */,
        /* 907 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SendTemplatedEmailCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SendTemplatedEmailCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SendTemplatedEmailCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SendTemplatedEmailRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SendTemplatedEmailResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySendTemplatedEmailCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySendTemplatedEmailCommand)(output, context);
                }
            }

            exports.SendTemplatedEmailCommand = SendTemplatedEmailCommand;


            /***/
        }),
        /* 908 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.DeleteTemplateResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteTemplateCommand)(output, context);
                }
            }

            exports.DeleteTemplateCommand = DeleteTemplateCommand;


            /***/
        }),
        /* 909 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.Client = void 0;
            const middleware_stack_1 = __webpack_require__(519);

            class Client {
                constructor(config) {
                    this.middlewareStack = (0, middleware_stack_1.constructStack)();
                    this.config = config;
                }

                send(command, optionsOrCb, cb) {
                    const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
                    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
                    const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
                    if (callback) {
                        handler(command)
                            .then((result) => callback(null, result.output), (err) => callback(err))
                            .catch(() => {
                            });
                    } else {
                        return handler(command).then((result) => result.output);
                    }
                }

                destroy() {
                    if (this.config.requestHandler.destroy)
                        this.config.requestHandler.destroy();
                }
            }

            exports.Client = Client;


            /***/
        }),
        /* 910 */,
        /* 911 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            var request = __webpack_require__(339);
            var universalUserAgent = __webpack_require__(922);

            const VERSION = "4.8.0";

            function _buildMessageForResponseErrors(data) {
                return `Request failed due to following response errors:\n` + data.errors.map(e => ` - ${e.message}`).join("\n");
            }

            class GraphqlResponseError extends Error {
                constructor(request, headers, response) {
                    super(_buildMessageForResponseErrors(response));
                    this.request = request;
                    this.headers = headers;
                    this.response = response;
                    this.name = "GraphqlResponseError"; // Expose the errors and response data in their shorthand properties.

                    this.errors = response.errors;
                    this.data = response.data; // Maintains proper stack trace (only available on V8)

                    /* istanbul ignore next */

                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                    }
                }

            }

            const NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
            const FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
            const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;

            function graphql(request, query, options) {
                if (options) {
                    if (typeof query === "string" && "query" in options) {
                        return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
                    }

                    for (const key in options) {
                        if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
                        return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
                    }
                }

                const parsedOptions = typeof query === "string" ? Object.assign({
                    query
                }, options) : query;
                const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
                    if (NON_VARIABLE_OPTIONS.includes(key)) {
                        result[key] = parsedOptions[key];
                        return result;
                    }

                    if (!result.variables) {
                        result.variables = {};
                    }

                    result.variables[key] = parsedOptions[key];
                    return result;
                }, {}); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
                // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451

                const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;

                if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
                    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
                }

                return request(requestOptions).then(response => {
                    if (response.data.errors) {
                        const headers = {};

                        for (const key of Object.keys(response.headers)) {
                            headers[key] = response.headers[key];
                        }

                        throw new GraphqlResponseError(requestOptions, headers, response.data);
                    }

                    return response.data.data;
                });
            }

            function withDefaults(request$1, newDefaults) {
                const newRequest = request$1.defaults(newDefaults);

                const newApi = (query, options) => {
                    return graphql(newRequest, query, options);
                };

                return Object.assign(newApi, {
                    defaults: withDefaults.bind(null, newRequest),
                    endpoint: request.request.endpoint
                });
            }

            const graphql$1 = withDefaults(request.request, {
                headers: {
                    "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`
                },
                method: "POST",
                url: "/graphql"
            });

            function withCustomRequest(customRequest) {
                return withDefaults(customRequest, {
                    method: "POST",
                    url: "/graphql"
                });
            }

            exports.GraphqlResponseError = GraphqlResponseError;
            exports.graphql = graphql$1;
            exports.withCustomRequest = withCustomRequest;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 912 */,
        /* 913 */,
        /* 914 */,
        /* 915 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.extendedEncodeURIComponent = void 0;

            function extendedEncodeURIComponent(str) {
                return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
                    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
                });
            }

            exports.extendedEncodeURIComponent = extendedEncodeURIComponent;


            /***/
        }),
        /* 916 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.TestRenderTemplateCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class TestRenderTemplateCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "TestRenderTemplateCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.TestRenderTemplateRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.TestRenderTemplateResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryTestRenderTemplateCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryTestRenderTemplateCommand)(output, context);
                }
            }

            exports.TestRenderTemplateCommand = TestRenderTemplateCommand;


            /***/
        }),
        /* 917 */,
        /* 918 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(76), exports);
            tslib_1.__exportStar(__webpack_require__(409), exports);
            tslib_1.__exportStar(__webpack_require__(493), exports);


            /***/
        }),
        /* 919 */,
        /* 920 */,
        /* 921 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.waitUntilIdentityExists = exports.waitForIdentityExists = void 0;
            const util_waiter_1 = __webpack_require__(885);
            const GetIdentityVerificationAttributesCommand_1 = __webpack_require__(370);
            const checkState = async (client, input) => {
                let reason;
                try {
                    const result = await client.send(new GetIdentityVerificationAttributesCommand_1.GetIdentityVerificationAttributesCommand(input));
                    reason = result;
                    try {
                        const returnComparator = () => {
                            const objectProjection_2 = Object.values(result.VerificationAttributes).map((element_1) => {
                                return element_1.VerificationStatus;
                            });
                            return objectProjection_2;
                        };
                        let allStringEq_4 = returnComparator().length > 0;
                        for (const element_3 of returnComparator()) {
                            allStringEq_4 = allStringEq_4 && element_3 == "Success";
                        }
                        if (allStringEq_4) {
                            return {state: util_waiter_1.WaiterState.SUCCESS, reason};
                        }
                    } catch (e) {
                    }
                } catch (exception) {
                    reason = exception;
                }
                return {state: util_waiter_1.WaiterState.RETRY, reason};
            };
            const waitForIdentityExists = async (params, input) => {
                const serviceDefaults = {minDelay: 3, maxDelay: 120};
                return (0, util_waiter_1.createWaiter)({...serviceDefaults, ...params}, input, checkState);
            };
            exports.waitForIdentityExists = waitForIdentityExists;
            const waitUntilIdentityExists = async (params, input) => {
                const serviceDefaults = {minDelay: 3, maxDelay: 120};
                const result = await (0, util_waiter_1.createWaiter)({...serviceDefaults, ...params}, input, checkState);
                return (0, util_waiter_1.checkExceptions)(result);
            };
            exports.waitUntilIdentityExists = waitUntilIdentityExists;


            /***/
        }),
        /* 922 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";


            Object.defineProperty(exports, '__esModule', {value: true});

            function getUserAgent() {
                if (typeof navigator === "object" && "userAgent" in navigator) {
                    return navigator.userAgent;
                }

                if (typeof process === "object" && "version" in process) {
                    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
                }

                return "<environment undetectable>";
            }

            exports.getUserAgent = getUserAgent;
//# sourceMappingURL=index.js.map


            /***/
        }),
        /* 923 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromStatic = void 0;
            const property_provider_1 = __webpack_require__(118);
            const isFunction = (func) => typeof func === "function";
            const fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : (0, property_provider_1.fromStatic)(defaultValue);
            exports.fromStatic = fromStatic;


            /***/
        }),
        /* 924 */,
        /* 925 */,
        /* 926 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SetReceiptRulePositionCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SetReceiptRulePositionCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SetReceiptRulePositionCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SetReceiptRulePositionRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SetReceiptRulePositionResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySetReceiptRulePositionCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySetReceiptRulePositionCommand)(output, context);
                }
            }

            exports.SetReceiptRulePositionCommand = SetReceiptRulePositionCommand;


            /***/
        }),
        /* 927 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(162), exports);
            tslib_1.__exportStar(__webpack_require__(722), exports);


            /***/
        }),
        /* 928 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.loadSharedConfigFiles = exports.ENV_CONFIG_PATH = exports.ENV_CREDENTIALS_PATH = void 0;
            const path_1 = __webpack_require__(622);
            const getHomeDir_1 = __webpack_require__(567);
            const normalizeConfigFile_1 = __webpack_require__(164);
            const parseIni_1 = __webpack_require__(980);
            const slurpFile_1 = __webpack_require__(386);
            exports.ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
            exports.ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
            const swallowError = () => ({});
            const loadSharedConfigFiles = async (init = {}) => {
                const {
                    filepath = process.env[exports.ENV_CREDENTIALS_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "credentials"),
                    configFilepath = process.env[exports.ENV_CONFIG_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "config"),
                } = init;
                const parsedFiles = await Promise.all([
                    (0, slurpFile_1.slurpFile)(configFilepath).then(parseIni_1.parseIni).then(normalizeConfigFile_1.normalizeConfigFile).catch(swallowError),
                    (0, slurpFile_1.slurpFile)(filepath).then(parseIni_1.parseIni).catch(swallowError),
                ]);
                return {
                    configFile: parsedFiles[0],
                    credentialsFile: parsedFiles[1],
                };
            };
            exports.loadSharedConfigFiles = loadSharedConfigFiles;


            /***/
        }),
        /* 929 */,
        /* 930 */,
        /* 931 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.parseKnownFiles = void 0;
            const loadSharedConfigFiles_1 = __webpack_require__(928);
            const parseKnownFiles = async (init) => {
                const {loadedConfig = (0, loadSharedConfigFiles_1.loadSharedConfigFiles)(init)} = init;
                const parsedFiles = await loadedConfig;
                return {
                    ...parsedFiles.configFile,
                    ...parsedFiles.credentialsFile,
                };
            };
            exports.parseKnownFiles = parseKnownFiles;


            /***/
        }),
        /* 932 */,
        /* 933 */,
        /* 934 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetAccessKeyInfoCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const middleware_signing_1 = __webpack_require__(22);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(575);
            const Aws_query_1 = __webpack_require__(139);

            class GetAccessKeyInfoCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "STSClient";
                    const commandName = "GetAccessKeyInfoCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetAccessKeyInfoRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetAccessKeyInfoResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetAccessKeyInfoCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetAccessKeyInfoCommand)(output, context);
                }
            }

            exports.GetAccessKeyInfoCommand = GetAccessKeyInfoCommand;


            /***/
        }),
        /* 935 */,
        /* 936 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.createWaiter = void 0;
            const poller_1 = __webpack_require__(336);
            const utils_1 = __webpack_require__(780);
            const waiter_1 = __webpack_require__(532);
            const abortTimeout = async (abortSignal) => {
                return new Promise((resolve) => {
                    abortSignal.onabort = () => resolve({state: waiter_1.WaiterState.ABORTED});
                });
            };
            const createWaiter = async (options, input, acceptorChecks) => {
                const params = {
                    ...waiter_1.waiterServiceDefaults,
                    ...options,
                };
                (0, utils_1.validateWaiterOptions)(params);
                const exitConditions = [(0, poller_1.runPolling)(params, input, acceptorChecks)];
                if (options.abortController) {
                    exitConditions.push(abortTimeout(options.abortController.signal));
                }
                if (options.abortSignal) {
                    exitConditions.push(abortTimeout(options.abortSignal));
                }
                return Promise.race(exitConditions);
            };
            exports.createWaiter = createWaiter;


            /***/
        }),
        /* 937 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.Endpoint = void 0;
            var Endpoint;
            (function (Endpoint) {
                Endpoint["IPv4"] = "http://169.254.169.254";
                Endpoint["IPv6"] = "http://[fd00:ec2::254]";
            })(Endpoint = exports.Endpoint || (exports.Endpoint = {}));


            /***/
        }),
        /* 938 */,
        /* 939 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.booleanSelector = exports.SelectorType = void 0;
            var SelectorType;
            (function (SelectorType) {
                SelectorType["ENV"] = "env";
                SelectorType["CONFIG"] = "shared config entry";
            })(SelectorType = exports.SelectorType || (exports.SelectorType = {}));
            const booleanSelector = (obj, key, type) => {
                if (!(key in obj))
                    return undefined;
                if (obj[key] === "true")
                    return true;
                if (obj[key] === "false")
                    return false;
                throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
            };
            exports.booleanSelector = booleanSelector;


            /***/
        }),
        /* 940 */,
        /* 941 */,
        /* 942 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.AssumeRoleCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const middleware_signing_1 = __webpack_require__(22);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(575);
            const Aws_query_1 = __webpack_require__(139);

            class AssumeRoleCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "STSClient";
                    const commandName = "AssumeRoleCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.AssumeRoleRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.AssumeRoleResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryAssumeRoleCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryAssumeRoleCommand)(output, context);
                }
            }

            exports.AssumeRoleCommand = AssumeRoleCommand;


            /***/
        }),
        /* 943 */,
        /* 944 */,
        /* 945 */,
        /* 946 */,
        /* 947 */,
        /* 948 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.setConnectionTimeout = void 0;
            const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
                if (!timeoutInMs) {
                    return;
                }
                request.on("socket", (socket) => {
                    if (socket.connecting) {
                        const timeoutId = setTimeout(() => {
                            request.destroy();
                            reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
                                name: "TimeoutError",
                            }));
                        }, timeoutInMs);
                        socket.on("connect", () => {
                            clearTimeout(timeoutId);
                        });
                    }
                });
            };
            exports.setConnectionTimeout = setConnectionTimeout;


            /***/
        }),
        /* 949 */,
        /* 950 */,
        /* 951 */,
        /* 952 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});


            /***/
        }),
        /* 953 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            const util = __webpack_require__(176);
            const buildOptions = __webpack_require__(176).buildOptions;
            const x2j = __webpack_require__(259);

//TODO: do it later
            const convertToJsonString = function (node, options) {
                options = buildOptions(options, x2j.defaultOptions, x2j.props);

                options.indentBy = options.indentBy || '';
                return _cToJsonStr(node, options, 0);
            };

            const _cToJsonStr = function (node, options, level) {
                let jObj = '{';

                //traver through all the children
                const keys = Object.keys(node.child);

                for (let index = 0; index < keys.length; index++) {
                    var tagname = keys[index];
                    if (node.child[tagname] && node.child[tagname].length > 1) {
                        jObj += '"' + tagname + '" : [ ';
                        for (var tag in node.child[tagname]) {
                            jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';
                        }
                        jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last
                    } else {
                        jObj += '"' + tagname + '" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';
                    }
                }
                util.merge(jObj, node.attrsMap);
                //add attrsMap as new children
                if (util.isEmptyObject(jObj)) {
                    return util.isExist(node.val) ? node.val : '';
                } else {
                    if (util.isExist(node.val)) {
                        if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {
                            jObj += '"' + options.textNodeName + '" : ' + stringval(node.val);
                        }
                    }
                }
                //add value
                if (jObj[jObj.length - 1] === ',') {
                    jObj = jObj.substr(0, jObj.length - 2);
                }
                return jObj + '}';
            };

            function stringval(v) {
                if (v === true || v === false || !isNaN(v)) {
                    return v;
                } else {
                    return '"' + v + '"';
                }
            }

            function indentate(options, level) {
                return options.indentBy.repeat(level);
            }

            exports.convertToJsonString = convertToJsonString;


            /***/
        }),
        /* 954 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DeleteVerifiedEmailAddressCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class DeleteVerifiedEmailAddressCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "DeleteVerifiedEmailAddressCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.DeleteVerifiedEmailAddressRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryDeleteVerifiedEmailAddressCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryDeleteVerifiedEmailAddressCommand)(output, context);
                }
            }

            exports.DeleteVerifiedEmailAddressCommand = DeleteVerifiedEmailAddressCommand;


            /***/
        }),
        /* 955 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                Object.defineProperty(o, k2, {
                    enumerable: true, get: function () {
                        return m[k];
                    }
                });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", {enumerable: true, value: v});
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getOctokit = exports.context = void 0;
            const Context = __importStar(__webpack_require__(433));
            const utils_1 = __webpack_require__(638);
            exports.context = new Context.Context();

            /**
             * Returns a hydrated octokit ready to use for GitHub Actions
             *
             * @param     token    the repo PAT or GITHUB_TOKEN
             * @param     options  other options to set
             */
            function getOctokit(token, options) {
                return new utils_1.GitHub(utils_1.getOctokitOptions(token, options));
            }

            exports.getOctokit = getOctokit;
//# sourceMappingURL=github.js.map

            /***/
        }),
        /* 956 */,
        /* 957 */,
        /* 958 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.parseEpochTimestamp = exports.parseRfc7231DateTime = exports.parseRfc3339DateTime = exports.dateToUtcString = void 0;
            const parse_utils_1 = __webpack_require__(80);
            const DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
            const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

            function dateToUtcString(date) {
                const year = date.getUTCFullYear();
                const month = date.getUTCMonth();
                const dayOfWeek = date.getUTCDay();
                const dayOfMonthInt = date.getUTCDate();
                const hoursInt = date.getUTCHours();
                const minutesInt = date.getUTCMinutes();
                const secondsInt = date.getUTCSeconds();
                const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
                const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
                const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
                const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
                return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
            }

            exports.dateToUtcString = dateToUtcString;
            const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
            const parseRfc3339DateTime = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                if (typeof value !== "string") {
                    throw new TypeError("RFC-3339 date-times must be expressed as strings");
                }
                const match = RFC3339.exec(value);
                if (!match) {
                    throw new TypeError("Invalid RFC-3339 date-time value");
                }
                const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
                const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
                const month = parseDateValue(monthStr, "month", 1, 12);
                const day = parseDateValue(dayStr, "day", 1, 31);
                return buildDate(year, month, day, {hours, minutes, seconds, fractionalMilliseconds});
            };
            exports.parseRfc3339DateTime = parseRfc3339DateTime;
            const IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
            const RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
            const ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
            const parseRfc7231DateTime = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                if (typeof value !== "string") {
                    throw new TypeError("RFC-7231 date-times must be expressed as strings");
                }
                let match = IMF_FIXDATE.exec(value);
                if (match) {
                    const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
                    return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
                        hours,
                        minutes,
                        seconds,
                        fractionalMilliseconds
                    });
                }
                match = RFC_850_DATE.exec(value);
                if (match) {
                    const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
                    return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
                        hours,
                        minutes,
                        seconds,
                        fractionalMilliseconds,
                    }));
                }
                match = ASC_TIME.exec(value);
                if (match) {
                    const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
                    return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), {
                        hours,
                        minutes,
                        seconds,
                        fractionalMilliseconds
                    });
                }
                throw new TypeError("Invalid RFC-7231 date-time value");
            };
            exports.parseRfc7231DateTime = parseRfc7231DateTime;
            const parseEpochTimestamp = (value) => {
                if (value === null || value === undefined) {
                    return undefined;
                }
                let valueAsDouble;
                if (typeof value === "number") {
                    valueAsDouble = value;
                } else if (typeof value === "string") {
                    valueAsDouble = (0, parse_utils_1.strictParseDouble)(value);
                } else {
                    throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
                }
                if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
                    throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
                }
                return new Date(Math.round(valueAsDouble * 1000));
            };
            exports.parseEpochTimestamp = parseEpochTimestamp;
            const buildDate = (year, month, day, time) => {
                const adjustedMonth = month - 1;
                validateDayOfMonth(year, adjustedMonth, day);
                return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
            };
            const parseTwoDigitYear = (value) => {
                const thisYear = new Date().getUTCFullYear();
                const valueInThisCentury = Math.floor(thisYear / 100) * 100 + (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(value));
                if (valueInThisCentury < thisYear) {
                    return valueInThisCentury + 100;
                }
                return valueInThisCentury;
            };
            const FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
            const adjustRfc850Year = (input) => {
                if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
                    return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
                }
                return input;
            };
            const parseMonthByShortName = (value) => {
                const monthIdx = MONTHS.indexOf(value);
                if (monthIdx < 0) {
                    throw new TypeError(`Invalid month: ${value}`);
                }
                return monthIdx + 1;
            };
            const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            const validateDayOfMonth = (year, month, day) => {
                let maxDays = DAYS_IN_MONTH[month];
                if (month === 1 && isLeapYear(year)) {
                    maxDays = 29;
                }
                if (day > maxDays) {
                    throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
                }
            };
            const isLeapYear = (year) => {
                return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
            };
            const parseDateValue = (value, type, lower, upper) => {
                const dateVal = (0, parse_utils_1.strictParseByte)(stripLeadingZeroes(value));
                if (dateVal < lower || dateVal > upper) {
                    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
                }
                return dateVal;
            };
            const parseMilliseconds = (value) => {
                if (value === null || value === undefined) {
                    return 0;
                }
                return (0, parse_utils_1.strictParseFloat32)("0." + value) * 1000;
            };
            const stripLeadingZeroes = (value) => {
                let idx = 0;
                while (idx < value.length - 1 && value.charAt(idx) === "0") {
                    idx++;
                }
                if (idx === 0) {
                    return value;
                }
                return value.slice(idx);
            };


            /***/
        }),
        /* 959 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.fromInstanceMetadata = void 0;
            const property_provider_1 = __webpack_require__(118);
            const httpRequest_1 = __webpack_require__(214);
            const ImdsCredentials_1 = __webpack_require__(50);
            const RemoteProviderInit_1 = __webpack_require__(116);
            const retry_1 = __webpack_require__(545);
            const getInstanceMetadataEndpoint_1 = __webpack_require__(899);
            const staticStabilityProvider_1 = __webpack_require__(802);
            const IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
            const IMDS_TOKEN_PATH = "/latest/api/token";
            const fromInstanceMetadata = (init = {}) => (0, staticStabilityProvider_1.staticStabilityProvider)(getInstanceImdsProvider(init), {logger: init.logger});
            exports.fromInstanceMetadata = fromInstanceMetadata;
            const getInstanceImdsProvider = (init) => {
                let disableFetchToken = false;
                const {timeout, maxRetries} = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
                const getCredentials = async (maxRetries, options) => {
                    const profile = (await (0, retry_1.retry)(async () => {
                        let profile;
                        try {
                            profile = await getProfile(options);
                        } catch (err) {
                            if (err.statusCode === 401) {
                                disableFetchToken = false;
                            }
                            throw err;
                        }
                        return profile;
                    }, maxRetries)).trim();
                    return (0, retry_1.retry)(async () => {
                        let creds;
                        try {
                            creds = await getCredentialsFromProfile(profile, options);
                        } catch (err) {
                            if (err.statusCode === 401) {
                                disableFetchToken = false;
                            }
                            throw err;
                        }
                        return creds;
                    }, maxRetries);
                };
                return async () => {
                    const endpoint = await (0, getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint)();
                    if (disableFetchToken) {
                        return getCredentials(maxRetries, {...endpoint, timeout});
                    } else {
                        let token;
                        try {
                            token = (await getMetadataToken({...endpoint, timeout})).toString();
                        } catch (error) {
                            if ((error === null || error === void 0 ? void 0 : error.statusCode) === 400) {
                                throw Object.assign(error, {
                                    message: "EC2 Metadata token request returned error",
                                });
                            } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
                                disableFetchToken = true;
                            }
                            return getCredentials(maxRetries, {...endpoint, timeout});
                        }
                        return getCredentials(maxRetries, {
                            ...endpoint,
                            headers: {
                                "x-aws-ec2-metadata-token": token,
                            },
                            timeout,
                        });
                    }
                };
            };
            const getMetadataToken = async (options) => (0, httpRequest_1.httpRequest)({
                ...options,
                path: IMDS_TOKEN_PATH,
                method: "PUT",
                headers: {
                    "x-aws-ec2-metadata-token-ttl-seconds": "21600",
                },
            });
            const getProfile = async (options) => (await (0, httpRequest_1.httpRequest)({
                ...options,
                path: IMDS_PATH
            })).toString();
            const getCredentialsFromProfile = async (profile, options) => {
                const credsResponse = JSON.parse((await (0, httpRequest_1.httpRequest)({
                    ...options,
                    path: IMDS_PATH + profile,
                })).toString());
                if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
                    throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
                }
                return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
            };


            /***/
        }),
        /* 960 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _regex = _interopRequireDefault(__webpack_require__(784));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            function validate(uuid) {
                return typeof uuid === 'string' && _regex.default.test(uuid);
            }

            var _default = validate;
            exports.default = _default;

            /***/
        }),
        /* 961 */,
        /* 962 */,
        /* 963 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            const tslib_1 = __webpack_require__(84);
            tslib_1.__exportStar(__webpack_require__(575), exports);


            /***/
        }),
        /* 964 */,
        /* 965 */,
        /* 966 */,
        /* 967 */,
        /* 968 */,
        /* 969 */,
        /* 970 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.VerifyEmailAddressCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class VerifyEmailAddressCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "VerifyEmailAddressCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.VerifyEmailAddressRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: (output) => output,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryVerifyEmailAddressCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryVerifyEmailAddressCommand)(output, context);
                }
            }

            exports.VerifyEmailAddressCommand = VerifyEmailAddressCommand;


            /***/
        }),
        /* 971 */,
        /* 972 */,
        /* 973 */,
        /* 974 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.Hash = void 0;
            const util_buffer_from_1 = __webpack_require__(75);
            const buffer_1 = __webpack_require__(670);
            const crypto_1 = __webpack_require__(417);

            class Hash {
                constructor(algorithmIdentifier, secret) {
                    this.hash = secret ? (0, crypto_1.createHmac)(algorithmIdentifier, castSourceData(secret)) : (0, crypto_1.createHash)(algorithmIdentifier);
                }

                update(toHash, encoding) {
                    this.hash.update(castSourceData(toHash, encoding));
                }

                digest() {
                    return Promise.resolve(this.hash.digest());
                }
            }

            exports.Hash = Hash;

            function castSourceData(toCast, encoding) {
                if (buffer_1.Buffer.isBuffer(toCast)) {
                    return toCast;
                }
                if (typeof toCast === "string") {
                    return (0, util_buffer_from_1.fromString)(toCast, encoding);
                }
                if (ArrayBuffer.isView(toCast)) {
                    return (0, util_buffer_from_1.fromArrayBuffer)(toCast.buffer, toCast.byteOffset, toCast.byteLength);
                }
                return (0, util_buffer_from_1.fromArrayBuffer)(toCast);
            }


            /***/
        }),
        /* 975 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const EventEmitter = __webpack_require__(614);
            const SMTPConnection = __webpack_require__(580);
            const wellKnown = __webpack_require__(999);
            const shared = __webpack_require__(190);
            const XOAuth2 = __webpack_require__(800);
            const packageData = __webpack_require__(786);

            /**
             * Creates a SMTP transport object for Nodemailer
             *
             * @constructor
             * @param {Object} options Connection options
             */
            class SMTPTransport extends EventEmitter {
                constructor(options) {
                    super();

                    options = options || {};
                    if (typeof options === 'string') {
                        options = {
                            url: options
                        };
                    }

                    let urlData;
                    let service = options.service;

                    if (typeof options.getSocket === 'function') {
                        this.getSocket = options.getSocket;
                    }

                    if (options.url) {
                        urlData = shared.parseConnectionUrl(options.url);
                        service = service || urlData.service;
                    }

                    this.options = shared.assign(
                        false, // create new object
                        options, // regular options
                        urlData, // url options
                        service && wellKnown(service) // wellknown options
                    );

                    this.logger = shared.getLogger(this.options, {
                        component: this.options.component || 'smtp-transport'
                    });

                    // temporary object
                    let connection = new SMTPConnection(this.options);

                    this.name = 'SMTP';
                    this.version = packageData.version + '[client:' + connection.version + ']';

                    if (this.options.auth) {
                        this.auth = this.getAuth({});
                    }
                }

                /**
                 * Placeholder function for creating proxy sockets. This method immediatelly returns
                 * without a socket
                 *
                 * @param {Object} options Connection options
                 * @param {Function} callback Callback function to run with the socket keys
                 */
                getSocket(options, callback) {
                    // return immediatelly
                    return setImmediate(() => callback(null, false));
                }

                getAuth(authOpts) {
                    if (!authOpts) {
                        return this.auth;
                    }

                    let hasAuth = false;
                    let authData = {};

                    if (this.options.auth && typeof this.options.auth === 'object') {
                        Object.keys(this.options.auth).forEach(key => {
                            hasAuth = true;
                            authData[key] = this.options.auth[key];
                        });
                    }

                    if (authOpts && typeof authOpts === 'object') {
                        Object.keys(authOpts).forEach(key => {
                            hasAuth = true;
                            authData[key] = authOpts[key];
                        });
                    }

                    if (!hasAuth) {
                        return false;
                    }

                    switch ((authData.type || '').toString().toUpperCase()) {
                        case 'OAUTH2': {
                            if (!authData.service && !authData.user) {
                                return false;
                            }
                            let oauth2 = new XOAuth2(authData, this.logger);
                            oauth2.provisionCallback = (this.mailer && this.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;
                            oauth2.on('token', token => this.mailer.emit('token', token));
                            oauth2.on('error', err => this.emit('error', err));
                            return {
                                type: 'OAUTH2',
                                user: authData.user,
                                oauth2,
                                method: 'XOAUTH2'
                            };
                        }
                        default:
                            return {
                                type: (authData.type || '').toString().toUpperCase() || 'LOGIN',
                                user: authData.user,
                                credentials: {
                                    user: authData.user || '',
                                    pass: authData.pass,
                                    options: authData.options
                                },
                                method: (authData.method || '').trim().toUpperCase() || this.options.authMethod || false
                            };
                    }
                }

                /**
                 * Sends an e-mail using the selected settings
                 *
                 * @param {Object} mail Mail object
                 * @param {Function} callback Callback function
                 */
                send(mail, callback) {
                    this.getSocket(this.options, (err, socketOptions) => {
                        if (err) {
                            return callback(err);
                        }

                        let returned = false;
                        let options = this.options;
                        if (socketOptions && socketOptions.connection) {
                            this.logger.info(
                                {
                                    tnx: 'proxy',
                                    remoteAddress: socketOptions.connection.remoteAddress,
                                    remotePort: socketOptions.connection.remotePort,
                                    destHost: options.host || '',
                                    destPort: options.port || '',
                                    action: 'connected'
                                },
                                'Using proxied socket from %s:%s to %s:%s',
                                socketOptions.connection.remoteAddress,
                                socketOptions.connection.remotePort,
                                options.host || '',
                                options.port || ''
                            );

                            // only copy options if we need to modify it
                            options = shared.assign(false, options);
                            Object.keys(socketOptions).forEach(key => {
                                options[key] = socketOptions[key];
                            });
                        }

                        let connection = new SMTPConnection(options);

                        connection.once('error', err => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            connection.close();
                            return callback(err);
                        });

                        connection.once('end', () => {
                            if (returned) {
                                return;
                            }

                            let timer = setTimeout(() => {
                                if (returned) {
                                    return;
                                }
                                returned = true;
                                // still have not returned, this means we have an unexpected connection close
                                let err = new Error('Unexpected socket close');
                                if (connection && connection._socket && connection._socket.upgrading) {
                                    // starttls connection errors
                                    err.code = 'ETLS';
                                }
                                callback(err);
                            }, 1000);

                            try {
                                timer.unref();
                            } catch (E) {
                                // Ignore. Happens on envs with non-node timer implementation
                            }
                        });

                        let sendMessage = () => {
                            let envelope = mail.message.getEnvelope();
                            let messageId = mail.message.messageId();

                            let recipients = [].concat(envelope.to || []);
                            if (recipients.length > 3) {
                                recipients.push('...and ' + recipients.splice(2).length + ' more');
                            }

                            if (mail.data.dsn) {
                                envelope.dsn = mail.data.dsn;
                            }

                            this.logger.info(
                                {
                                    tnx: 'send',
                                    messageId
                                },
                                'Sending message %s to <%s>',
                                messageId,
                                recipients.join(', ')
                            );

                            connection.send(envelope, mail.message.createReadStream(), (err, info) => {
                                returned = true;
                                connection.close();
                                if (err) {
                                    this.logger.error(
                                        {
                                            err,
                                            tnx: 'send'
                                        },
                                        'Send error for %s: %s',
                                        messageId,
                                        err.message
                                    );
                                    return callback(err);
                                }
                                info.envelope = {
                                    from: envelope.from,
                                    to: envelope.to
                                };
                                info.messageId = messageId;
                                try {
                                    return callback(null, info);
                                } catch (E) {
                                    this.logger.error(
                                        {
                                            err: E,
                                            tnx: 'callback'
                                        },
                                        'Callback error for %s: %s',
                                        messageId,
                                        E.message
                                    );
                                }
                            });
                        };

                        connection.connect(() => {
                            if (returned) {
                                return;
                            }

                            let auth = this.getAuth(mail.data.auth);

                            if (auth && (connection.allowsAuth || options.forceAuth)) {
                                connection.login(auth, err => {
                                    if (auth && auth !== this.auth && auth.oauth2) {
                                        auth.oauth2.removeAllListeners();
                                    }
                                    if (returned) {
                                        return;
                                    }

                                    if (err) {
                                        returned = true;
                                        connection.close();
                                        return callback(err);
                                    }

                                    sendMessage();
                                });
                            } else {
                                sendMessage();
                            }
                        });
                    });
                }

                /**
                 * Verifies SMTP configuration
                 *
                 * @param {Function} callback Callback function
                 */
                verify(callback) {
                    let promise;

                    if (!callback) {
                        promise = new Promise((resolve, reject) => {
                            callback = shared.callbackPromise(resolve, reject);
                        });
                    }

                    this.getSocket(this.options, (err, socketOptions) => {
                        if (err) {
                            return callback(err);
                        }

                        let options = this.options;
                        if (socketOptions && socketOptions.connection) {
                            this.logger.info(
                                {
                                    tnx: 'proxy',
                                    remoteAddress: socketOptions.connection.remoteAddress,
                                    remotePort: socketOptions.connection.remotePort,
                                    destHost: options.host || '',
                                    destPort: options.port || '',
                                    action: 'connected'
                                },
                                'Using proxied socket from %s:%s to %s:%s',
                                socketOptions.connection.remoteAddress,
                                socketOptions.connection.remotePort,
                                options.host || '',
                                options.port || ''
                            );

                            options = shared.assign(false, options);
                            Object.keys(socketOptions).forEach(key => {
                                options[key] = socketOptions[key];
                            });
                        }

                        let connection = new SMTPConnection(options);
                        let returned = false;

                        connection.once('error', err => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            connection.close();
                            return callback(err);
                        });

                        connection.once('end', () => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            return callback(new Error('Connection closed'));
                        });

                        let finalize = () => {
                            if (returned) {
                                return;
                            }
                            returned = true;
                            connection.quit();
                            return callback(null, true);
                        };

                        connection.connect(() => {
                            if (returned) {
                                return;
                            }

                            let authData = this.getAuth({});

                            if (authData && (connection.allowsAuth || options.forceAuth)) {
                                connection.login(authData, err => {
                                    if (returned) {
                                        return;
                                    }

                                    if (err) {
                                        returned = true;
                                        connection.close();
                                        return callback(err);
                                    }

                                    finalize();
                                });
                            } else {
                                finalize();
                            }
                        });
                    });

                    return promise;
                }

                /**
                 * Releases resources
                 */
                close() {
                    if (this.auth && this.auth.oauth2) {
                        this.auth.oauth2.removeAllListeners();
                    }
                    this.emit('close');
                }
            }

// expose to the world
            module.exports = SMTPTransport;


            /***/
        }),
        /* 976 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SetIdentityMailFromDomainCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class SetIdentityMailFromDomainCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "SetIdentityMailFromDomainCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.SetIdentityMailFromDomainRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.SetIdentityMailFromDomainResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_querySetIdentityMailFromDomainCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_querySetIdentityMailFromDomainCommand)(output, context);
                }
            }

            exports.SetIdentityMailFromDomainCommand = SetIdentityMailFromDomainCommand;


            /***/
        }),
        /* 977 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});

            class BasicCredentialHandler {
                constructor(username, password) {
                    this.username = username;
                    this.password = password;
                }

                prepareRequest(options) {
                    options.headers['Authorization'] =
                        'Basic ' +
                        Buffer.from(this.username + ':' + this.password).toString('base64');
                }

                // This handler cannot handle 401
                canHandleAuthentication(response) {
                    return false;
                }

                handleAuthentication(httpClient, requestInfo, objs) {
                    return null;
                }
            }

            exports.BasicCredentialHandler = BasicCredentialHandler;

            class BearerCredentialHandler {
                constructor(token) {
                    this.token = token;
                }

                // currently implements pre-authorization
                // TODO: support preAuth = false where it hooks on 401
                prepareRequest(options) {
                    options.headers['Authorization'] = 'Bearer ' + this.token;
                }

                // This handler cannot handle 401
                canHandleAuthentication(response) {
                    return false;
                }

                handleAuthentication(httpClient, requestInfo, objs) {
                    return null;
                }
            }

            exports.BearerCredentialHandler = BearerCredentialHandler;

            class PersonalAccessTokenCredentialHandler {
                constructor(token) {
                    this.token = token;
                }

                // currently implements pre-authorization
                // TODO: support preAuth = false where it hooks on 401
                prepareRequest(options) {
                    options.headers['Authorization'] =
                        'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');
                }

                // This handler cannot handle 401
                canHandleAuthentication(response) {
                    return false;
                }

                handleAuthentication(httpClient, requestInfo, objs) {
                    return null;
                }
            }

            exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;


            /***/
        }),
        /* 978 */,
        /* 979 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetCallerIdentityCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const middleware_signing_1 = __webpack_require__(22);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(575);
            const Aws_query_1 = __webpack_require__(139);

            class GetCallerIdentityCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "STSClient";
                    const commandName = "GetCallerIdentityCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.GetCallerIdentityRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.GetCallerIdentityResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetCallerIdentityCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetCallerIdentityCommand)(output, context);
                }
            }

            exports.GetCallerIdentityCommand = GetCallerIdentityCommand;


            /***/
        }),
        /* 980 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.parseIni = void 0;
            const profileNameBlockList = ["__proto__", "profile __proto__"];
            const parseIni = (iniData) => {
                const map = {};
                let currentSection;
                for (let line of iniData.split(/\r?\n/)) {
                    line = line.split(/(^|\s)[;#]/)[0];
                    const section = line.match(/^\s*\[([^\[\]]+)]\s*$/);
                    if (section) {
                        currentSection = section[1];
                        if (profileNameBlockList.includes(currentSection)) {
                            throw new Error(`Found invalid profile name "${currentSection}"`);
                        }
                    } else if (currentSection) {
                        const item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
                        if (item) {
                            map[currentSection] = map[currentSection] || {};
                            map[currentSection][item[1]] = item[2];
                        }
                    }
                }
                return map;
            };
            exports.parseIni = parseIni;


            /***/
        }),
        /* 981 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.getRuntimeConfig = void 0;
            const url_parser_1 = __webpack_require__(834);
            const endpoints_1 = __webpack_require__(900);
            const getRuntimeConfig = (config) => {
                var _a, _b, _c, _d, _e;
                return ({
                    apiVersion: "2019-06-10",
                    disableHostPrefix: (_a = config === null || config === void 0 ? void 0 : config.disableHostPrefix) !== null && _a !== void 0 ? _a : false,
                    logger: (_b = config === null || config === void 0 ? void 0 : config.logger) !== null && _b !== void 0 ? _b : {},
                    regionInfoProvider: (_c = config === null || config === void 0 ? void 0 : config.regionInfoProvider) !== null && _c !== void 0 ? _c : endpoints_1.defaultRegionInfoProvider,
                    serviceId: (_d = config === null || config === void 0 ? void 0 : config.serviceId) !== null && _d !== void 0 ? _d : "SSO",
                    urlParser: (_e = config === null || config === void 0 ? void 0 : config.urlParser) !== null && _e !== void 0 ? _e : url_parser_1.parseUrl,
                });
            };
            exports.getRuntimeConfig = getRuntimeConfig;


            /***/
        }),
        /* 982 */
        /***/ (function (__unusedmodule, exports) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.resolveUserAgentConfig = void 0;

            function resolveUserAgentConfig(input) {
                return {
                    ...input,
                    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
                };
            }

            exports.resolveUserAgentConfig = resolveUserAgentConfig;


            /***/
        }),
        /* 983 */,
        /* 984 */,
        /* 985 */,
        /* 986 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            /**
             * Minimal HTTP/S proxy client
             */

            const net = __webpack_require__(631);
            const tls = __webpack_require__(16);
            const urllib = __webpack_require__(835);

            /**
             * Establishes proxied connection to destinationPort
             *
             * httpProxyClient("http://localhost:3128/", 80, "google.com", function(err, socket){
             *     socket.write("GET / HTTP/1.0\r\n\r\n");
             * });
             *
             * @param {String} proxyUrl proxy configuration, etg "http://proxy.host:3128/"
             * @param {Number} destinationPort Port to open in destination host
             * @param {String} destinationHost Destination hostname
             * @param {Function} callback Callback to run with the rocket object once connection is established
             */
            function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {
                let proxy = urllib.parse(proxyUrl);

                // create a socket connection to the proxy server
                let options;
                let connect;
                let socket;

                options = {
                    host: proxy.hostname,
                    port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80
                };

                if (proxy.protocol === 'https:') {
                    // we can use untrusted proxies as long as we verify actual SMTP certificates
                    options.rejectUnauthorized = false;
                    connect = tls.connect.bind(tls);
                } else {
                    connect = net.connect.bind(net);
                }

                // Error harness for initial connection. Once connection is established, the responsibility
                // to handle errors is passed to whoever uses this socket
                let finished = false;
                let tempSocketErr = function (err) {
                    if (finished) {
                        return;
                    }
                    finished = true;
                    try {
                        socket.destroy();
                    } catch (E) {
                        // ignore
                    }
                    callback(err);
                };

                socket = connect(options, () => {
                    if (finished) {
                        return;
                    }

                    let reqHeaders = {
                        Host: destinationHost + ':' + destinationPort,
                        Connection: 'close'
                    };
                    if (proxy.auth) {
                        reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');
                    }

                    socket.write(
                        // HTTP method
                        'CONNECT ' +
                        destinationHost +
                        ':' +
                        destinationPort +
                        ' HTTP/1.1\r\n' +
                        // HTTP request headers
                        Object.keys(reqHeaders)
                            .map(key => key + ': ' + reqHeaders[key])
                            .join('\r\n') +
                        // End request
                        '\r\n\r\n'
                    );

                    let headers = '';
                    let onSocketData = chunk => {
                        let match;
                        let remainder;

                        if (finished) {
                            return;
                        }

                        headers += chunk.toString('binary');
                        if ((match = headers.match(/\r\n\r\n/))) {
                            socket.removeListener('data', onSocketData);

                            remainder = headers.substr(match.index + match[0].length);
                            headers = headers.substr(0, match.index);
                            if (remainder) {
                                socket.unshift(Buffer.from(remainder, 'binary'));
                            }

                            // proxy connection is now established
                            finished = true;

                            // check response code
                            match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
                            if (!match || (match[1] || '').charAt(0) !== '2') {
                                try {
                                    socket.destroy();
                                } catch (E) {
                                    // ignore
                                }
                                return callback(new Error('Invalid response from proxy' + ((match && ': ' + match[1]) || '')));
                            }

                            socket.removeListener('error', tempSocketErr);
                            return callback(null, socket);
                        }
                    };
                    socket.on('data', onSocketData);
                });

                socket.once('error', tempSocketErr);
            }

            module.exports = httpProxyClient;


            /***/
        }),
        /* 987 */,
        /* 988 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const EventEmitter = __webpack_require__(614);
            const shared = __webpack_require__(190);
            const mimeTypes = __webpack_require__(332);
            const MailComposer = __webpack_require__(293);
            const DKIM = __webpack_require__(260);
            const httpProxyClient = __webpack_require__(986);
            const util = __webpack_require__(669);
            const urllib = __webpack_require__(835);
            const packageData = __webpack_require__(786);
            const MailMessage = __webpack_require__(12);
            const net = __webpack_require__(631);
            const dns = __webpack_require__(881);
            const crypto = __webpack_require__(417);

            /**
             * Creates an object for exposing the Mail API
             *
             * @constructor
             * @param {Object} transporter Transport object instance to pass the mails to
             */
            class Mail extends EventEmitter {
                constructor(transporter, options, defaults) {
                    super();

                    this.options = options || {};
                    this._defaults = defaults || {};

                    this._defaultPlugins = {
                        compile: [(...args) => this._convertDataImages(...args)],
                        stream: []
                    };

                    this._userPlugins = {
                        compile: [],
                        stream: []
                    };

                    this.meta = new Map();

                    this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;

                    this.transporter = transporter;
                    this.transporter.mailer = this;

                    this.logger = shared.getLogger(this.options, {
                        component: this.options.component || 'mail'
                    });

                    this.logger.debug(
                        {
                            tnx: 'create'
                        },
                        'Creating transport: %s',
                        this.getVersionString()
                    );

                    // setup emit handlers for the transporter
                    if (typeof this.transporter.on === 'function') {
                        // deprecated log interface
                        this.transporter.on('log', log => {
                            this.logger.debug(
                                {
                                    tnx: 'transport'
                                },
                                '%s: %s',
                                log.type,
                                log.message
                            );
                        });

                        // transporter errors
                        this.transporter.on('error', err => {
                            this.logger.error(
                                {
                                    err,
                                    tnx: 'transport'
                                },
                                'Transport Error: %s',
                                err.message
                            );
                            this.emit('error', err);
                        });

                        // indicates if the sender has became idle
                        this.transporter.on('idle', (...args) => {
                            this.emit('idle', ...args);
                        });
                    }

                    /**
                     * Optional methods passed to the underlying transport object
                     */
                    ['close', 'isIdle', 'verify'].forEach(method => {
                        this[method] = (...args) => {
                            if (typeof this.transporter[method] === 'function') {
                                if (method === 'verify' && typeof this.getSocket === 'function') {
                                    this.transporter.getSocket = this.getSocket;
                                    this.getSocket = false;
                                }
                                return this.transporter[method](...args);
                            } else {
                                this.logger.warn(
                                    {
                                        tnx: 'transport',
                                        methodName: method
                                    },
                                    'Non existing method %s called for transport',
                                    method
                                );
                                return false;
                            }
                        };
                    });

                    // setup proxy handling
                    if (this.options.proxy && typeof this.options.proxy === 'string') {
                        this.setupProxy(this.options.proxy);
                    }
                }

                use(step, plugin) {
                    step = (step || '').toString();
                    if (!this._userPlugins.hasOwnProperty(step)) {
                        this._userPlugins[step] = [plugin];
                    } else {
                        this._userPlugins[step].push(plugin);
                    }

                    return this;
                }

                /**
                 * Sends an email using the preselected transport object
                 *
                 * @param {Object} data E-data description
                 * @param {Function?} callback Callback to run once the sending succeeded or failed
                 */
                sendMail(data, callback) {
                    let promise;

                    if (!callback) {
                        promise = new Promise((resolve, reject) => {
                            callback = shared.callbackPromise(resolve, reject);
                        });
                    }

                    if (typeof this.getSocket === 'function') {
                        this.transporter.getSocket = this.getSocket;
                        this.getSocket = false;
                    }

                    let mail = new MailMessage(this, data);

                    this.logger.debug(
                        {
                            tnx: 'transport',
                            name: this.transporter.name,
                            version: this.transporter.version,
                            action: 'send'
                        },
                        'Sending mail using %s/%s',
                        this.transporter.name,
                        this.transporter.version
                    );

                    this._processPlugins('compile', mail, err => {
                        if (err) {
                            this.logger.error(
                                {
                                    err,
                                    tnx: 'plugin',
                                    action: 'compile'
                                },
                                'PluginCompile Error: %s',
                                err.message
                            );
                            return callback(err);
                        }

                        mail.message = new MailComposer(mail.data).compile();

                        mail.setMailerHeader();
                        mail.setPriorityHeaders();
                        mail.setListHeaders();

                        this._processPlugins('stream', mail, err => {
                            if (err) {
                                this.logger.error(
                                    {
                                        err,
                                        tnx: 'plugin',
                                        action: 'stream'
                                    },
                                    'PluginStream Error: %s',
                                    err.message
                                );
                                return callback(err);
                            }

                            if (mail.data.dkim || this.dkim) {
                                mail.message.processFunc(input => {
                                    let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
                                    this.logger.debug(
                                        {
                                            tnx: 'DKIM',
                                            messageId: mail.message.messageId(),
                                            dkimDomains: dkim.keys.map(key => key.keySelector + '.' + key.domainName).join(', ')
                                        },
                                        'Signing outgoing message with %s keys',
                                        dkim.keys.length
                                    );
                                    return dkim.sign(input, mail.data._dkim);
                                });
                            }

                            this.transporter.send(mail, (...args) => {
                                if (args[0]) {
                                    this.logger.error(
                                        {
                                            err: args[0],
                                            tnx: 'transport',
                                            action: 'send'
                                        },
                                        'Send Error: %s',
                                        args[0].message
                                    );
                                }
                                callback(...args);
                            });
                        });
                    });

                    return promise;
                }

                getVersionString() {
                    return util.format('%s (%s; +%s; %s/%s)', packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
                }

                _processPlugins(step, mail, callback) {
                    step = (step || '').toString();

                    if (!this._userPlugins.hasOwnProperty(step)) {
                        return callback();
                    }

                    let userPlugins = this._userPlugins[step] || [];
                    let defaultPlugins = this._defaultPlugins[step] || [];

                    if (userPlugins.length) {
                        this.logger.debug(
                            {
                                tnx: 'transaction',
                                pluginCount: userPlugins.length,
                                step
                            },
                            'Using %s plugins for %s',
                            userPlugins.length,
                            step
                        );
                    }

                    if (userPlugins.length + defaultPlugins.length === 0) {
                        return callback();
                    }

                    let pos = 0;
                    let block = 'default';
                    let processPlugins = () => {
                        let curplugins = block === 'default' ? defaultPlugins : userPlugins;
                        if (pos >= curplugins.length) {
                            if (block === 'default' && userPlugins.length) {
                                block = 'user';
                                pos = 0;
                                curplugins = userPlugins;
                            } else {
                                return callback();
                            }
                        }
                        let plugin = curplugins[pos++];
                        plugin(mail, err => {
                            if (err) {
                                return callback(err);
                            }
                            processPlugins();
                        });
                    };

                    processPlugins();
                }

                /**
                 * Sets up proxy handler for a Nodemailer object
                 *
                 * @param {String} proxyUrl Proxy configuration url
                 */
                setupProxy(proxyUrl) {
                    let proxy = urllib.parse(proxyUrl);

                    // setup socket handler for the mailer object
                    this.getSocket = (options, callback) => {
                        let protocol = proxy.protocol.replace(/:$/, '').toLowerCase();

                        if (this.meta.has('proxy_handler_' + protocol)) {
                            return this.meta.get('proxy_handler_' + protocol)(proxy, options, callback);
                        }

                        switch (protocol) {
                            // Connect using a HTTP CONNECT method
                            case 'http':
                            case 'https':
                                httpProxyClient(proxy.href, options.port, options.host, (err, socket) => {
                                    if (err) {
                                        return callback(err);
                                    }
                                    return callback(null, {
                                        connection: socket
                                    });
                                });
                                return;
                            case 'socks':
                            case 'socks5':
                            case 'socks4':
                            case 'socks4a': {
                                if (!this.meta.has('proxy_socks_module')) {
                                    return callback(new Error('Socks module not loaded'));
                                }
                                let connect = ipaddress => {
                                    let proxyV2 = !!this.meta.get('proxy_socks_module').SocksClient;
                                    let socksClient = proxyV2 ? this.meta.get('proxy_socks_module').SocksClient : this.meta.get('proxy_socks_module');
                                    let proxyType = Number(proxy.protocol.replace(/\D/g, '')) || 5;
                                    let connectionOpts = {
                                        proxy: {
                                            ipaddress,
                                            port: Number(proxy.port),
                                            type: proxyType
                                        },
                                        [proxyV2 ? 'destination' : 'target']: {
                                            host: options.host,
                                            port: options.port
                                        },
                                        command: 'connect'
                                    };

                                    if (proxy.auth) {
                                        let username = decodeURIComponent(proxy.auth.split(':').shift());
                                        let password = decodeURIComponent(proxy.auth.split(':').pop());
                                        if (proxyV2) {
                                            connectionOpts.proxy.userId = username;
                                            connectionOpts.proxy.password = password;
                                        } else if (proxyType === 4) {
                                            connectionOpts.userid = username;
                                        } else {
                                            connectionOpts.authentication = {
                                                username,
                                                password
                                            };
                                        }
                                    }

                                    socksClient.createConnection(connectionOpts, (err, info) => {
                                        if (err) {
                                            return callback(err);
                                        }
                                        return callback(null, {
                                            connection: info.socket || info
                                        });
                                    });
                                };

                                if (net.isIP(proxy.hostname)) {
                                    return connect(proxy.hostname);
                                }

                                return dns.resolve(proxy.hostname, (err, address) => {
                                    if (err) {
                                        return callback(err);
                                    }
                                    connect(Array.isArray(address) ? address[0] : address);
                                });
                            }
                        }
                        callback(new Error('Unknown proxy configuration'));
                    };
                }

                _convertDataImages(mail, callback) {
                    if ((!this.options.attachDataUrls && !mail.data.attachDataUrls) || !mail.data.html) {
                        return callback();
                    }
                    mail.resolveContent(mail.data, 'html', (err, html) => {
                        if (err) {
                            return callback(err);
                        }
                        let cidCounter = 0;
                        html = (html || '').toString().replace(/(<img\b[^>]* src\s*=[\s"']*)(data:([^;]+);[^"'>\s]+)/gi, (match, prefix, dataUri, mimeType) => {
                            let cid = crypto.randomBytes(10).toString('hex') + '@localhost';
                            if (!mail.data.attachments) {
                                mail.data.attachments = [];
                            }
                            if (!Array.isArray(mail.data.attachments)) {
                                mail.data.attachments = [].concat(mail.data.attachments || []);
                            }
                            mail.data.attachments.push({
                                path: dataUri,
                                cid,
                                filename: 'image-' + ++cidCounter + '.' + mimeTypes.detectExtension(mimeType)
                            });
                            return prefix + 'cid:' + cid;
                        });
                        mail.data.html = html;
                        callback();
                    });
                }

                set(key, value) {
                    return this.meta.set(key, value);
                }

                get(key) {
                    return this.meta.get(key);
                }
            }

            module.exports = Mail;


            /***/
        }),
        /* 989 */,
        /* 990 */,
        /* 991 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.PutConfigurationSetDeliveryOptionsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class PutConfigurationSetDeliveryOptionsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "PutConfigurationSetDeliveryOptionsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.PutConfigurationSetDeliveryOptionsRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.PutConfigurationSetDeliveryOptionsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryPutConfigurationSetDeliveryOptionsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryPutConfigurationSetDeliveryOptionsCommand)(output, context);
                }
            }

            exports.PutConfigurationSetDeliveryOptionsCommand = PutConfigurationSetDeliveryOptionsCommand;


            /***/
        }),
        /* 992 */,
        /* 993 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _validate = _interopRequireDefault(__webpack_require__(960));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            /**
             * Convert array of 16 byte values to UUID string format of the form:
             * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
             */
            const byteToHex = [];

            for (let i = 0; i < 256; ++i) {
                byteToHex.push((i + 0x100).toString(16).substr(1));
            }

            function stringify(arr, offset = 0) {
                // Note: Be careful editing this code!  It's been tuned for performance
                // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
                const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
                // of the following:
                // - One or more input array values don't map to a hex octet (leading to
                // "undefined" in the uuid)
                // - Invalid input values for the RFC `version` or `variant` fields

                if (!(0, _validate.default)(uuid)) {
                    throw TypeError('Stringified UUID is invalid');
                }

                return uuid;
            }

            var _default = stringify;
            exports.default = _default;

            /***/
        }),
        /* 994 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ListAccountsCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(518);
            const Aws_restJson1_1 = __webpack_require__(492);

            class ListAccountsCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SSOClient";
                    const commandName = "ListAccountsCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: models_0_1.ListAccountsRequest.filterSensitiveLog,
                        outputFilterSensitiveLog: models_0_1.ListAccountsResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_restJson1_1.serializeAws_restJson1ListAccountsCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_restJson1_1.deserializeAws_restJson1ListAccountsCommand)(output, context);
                }
            }

            exports.ListAccountsCommand = ListAccountsCommand;


            /***/
        }),
        /* 995 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SSOClient = void 0;
            const config_resolver_1 = __webpack_require__(772);
            const middleware_content_length_1 = __webpack_require__(193);
            const middleware_host_header_1 = __webpack_require__(318);
            const middleware_logger_1 = __webpack_require__(676);
            const middleware_retry_1 = __webpack_require__(806);
            const middleware_user_agent_1 = __webpack_require__(624);
            const smithy_client_1 = __webpack_require__(449);
            const runtimeConfig_1 = __webpack_require__(661);

            class SSOClient extends smithy_client_1.Client {
                constructor(configuration) {
                    const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
                    const _config_1 = (0, config_resolver_1.resolveRegionConfig)(_config_0);
                    const _config_2 = (0, config_resolver_1.resolveEndpointsConfig)(_config_1);
                    const _config_3 = (0, middleware_retry_1.resolveRetryConfig)(_config_2);
                    const _config_4 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_3);
                    const _config_5 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_4);
                    super(_config_5);
                    this.config = _config_5;
                    this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
                    this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
                }

                destroy() {
                    super.destroy();
                }
            }

            exports.SSOClient = SSOClient;


            /***/
        }),
        /* 996 */,
        /* 997 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = void 0;

            var _v = _interopRequireDefault(__webpack_require__(541));

            var _md = _interopRequireDefault(__webpack_require__(85));

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {default: obj};
            }

            const v3 = (0, _v.default)('v3', 0x30, _md.default);
            var _default = v3;
            exports.default = _default;

            /***/
        }),
        /* 998 */
        /***/ (function (__unusedmodule, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {value: true});
            exports.GetSendQuotaCommand = void 0;
            const middleware_serde_1 = __webpack_require__(645);
            const smithy_client_1 = __webpack_require__(449);
            const models_0_1 = __webpack_require__(222);
            const Aws_query_1 = __webpack_require__(407);

            class GetSendQuotaCommand extends smithy_client_1.Command {
                constructor(input) {
                    super();
                    this.input = input;
                }

                resolveMiddleware(clientStack, configuration, options) {
                    this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
                    const stack = clientStack.concat(this.middlewareStack);
                    const {logger} = configuration;
                    const clientName = "SESClient";
                    const commandName = "GetSendQuotaCommand";
                    const handlerExecutionContext = {
                        logger,
                        clientName,
                        commandName,
                        inputFilterSensitiveLog: (input) => input,
                        outputFilterSensitiveLog: models_0_1.GetSendQuotaResponse.filterSensitiveLog,
                    };
                    const {requestHandler} = configuration;
                    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
                }

                serialize(input, context) {
                    return (0, Aws_query_1.serializeAws_queryGetSendQuotaCommand)(input, context);
                }

                deserialize(output, context) {
                    return (0, Aws_query_1.deserializeAws_queryGetSendQuotaCommand)(output, context);
                }
            }

            exports.GetSendQuotaCommand = GetSendQuotaCommand;


            /***/
        }),
        /* 999 */
        /***/ (function (module, __unusedexports, __webpack_require__) {

            "use strict";


            const services = __webpack_require__(704);
            const normalized = {};

            Object.keys(services).forEach(key => {
                let service = services[key];

                normalized[normalizeKey(key)] = normalizeService(service);

                [].concat(service.aliases || []).forEach(alias => {
                    normalized[normalizeKey(alias)] = normalizeService(service);
                });

                [].concat(service.domains || []).forEach(domain => {
                    normalized[normalizeKey(domain)] = normalizeService(service);
                });
            });

            function normalizeKey(key) {
                return key.replace(/[^a-zA-Z0-9.-]/g, '').toLowerCase();
            }

            function normalizeService(service) {
                let filter = ['domains', 'aliases'];
                let response = {};

                Object.keys(service).forEach(key => {
                    if (filter.indexOf(key) < 0) {
                        response[key] = service[key];
                    }
                });

                return response;
            }

            /**
             * Resolves SMTP config for given key. Key can be a name (like 'Gmail'), alias (like 'Google Mail') or
             * an email address (like 'test@googlemail.com').
             *
             * @param {String} key [description]
             * @returns {Object} SMTP config or false if not found
             */
            module.exports = function (key) {
                key = normalizeKey(key.split('@').pop());
                return normalized[key] || false;
            };


            /***/
        })
        /******/]);
